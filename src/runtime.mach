use mem:     std.system.memory;

pub ext main: fun([][]u8) i64;

val WORD_BYTES: u64 = 8;

#@if (OS == OS_WINDOWS)

val WIN_CP_UTF8: u32 = 65001;

ext "C:GetCommandLineW"     win32_get_command_line_w:      fun() *u16;
ext "C:CommandLineToArgvW"  win32_command_line_to_argv_w:  fun(*u16, *i32) **u16;
ext "C:LocalFree"           win32_local_free:              fun(*u8) *u8;
ext "C:WideCharToMultiByte" win32_wide_char_to_multi_byte: fun(u32, u32, *u16, i32, *u8, i32, *u8, *u8) i32;
ext "C:ExitProcess"         win32_exit_process:            fun(u32);

fun utf16_length(s: *u16) u64 {
    if (s == nil) {
        ret 0;
    }

    var length: u64 = 0;
    var cursor: *u16 = s;
    for {
        if (@cursor == 0::u16) {
            brk;
        }
        length = length + 1;
        cursor = cursor + 1;
    }

    ret length;
}

fun utf16_to_utf8(src: *u16) []u8 {
    if (src == nil) {
        ret []u8{ nil, 0 };
    }

    val char_count64: u64 = utf16_length(src);
    if (char_count64 == 0) {
        ret []u8{ nil, 0 };
    }

    val char_count: i32 = char_count64::i32;
    val required: i32 = win32_wide_char_to_multi_byte(WIN_CP_UTF8, 0, src, char_count, nil, 0, nil, nil);
    if (required <= 0) {
        ret []u8{ nil, 0 };
    }

    val buffer_size: u64 = required::u64;
    val buffer: *u8 = mem.allocate(buffer_size);
    if (buffer == nil) {
        ret []u8{ nil, 0 };
    }

    val written: i32 = win32_wide_char_to_multi_byte(WIN_CP_UTF8, 0, src, char_count, buffer, required, nil, nil);
    if (written <= 0) {
        mem.deallocate(buffer, buffer_size);
        ret []u8{ nil, 0 };
    }

    ret []u8{ buffer, written::u64 };
}

fun build_args_windows(argc: u64, argv_wide: **u16) [][]u8 {
    if (argc == 0 || argv_wide == nil) {
        ret [][]u8{ nil, 0 };
    }

    val entry_size: u64 = size_of([]u8{ nil, 0 });
    val total_bytes: u64 = argc * entry_size;
    val storage: *u8 = mem.allocate(total_bytes);
    if (storage == nil) {
        ret [][]u8{ nil, 0 };
    }

    var index: u64 = 0;
    for (index < argc) {
        val wide_arg: *u16 = @(argv_wide + index);
        val utf8: []u8 = utf16_to_utf8(wide_arg);

        val slot_offset: u64 = index * entry_size;
        val slot_addr: *u8 = storage + slot_offset;

        val data_slot: **u8 = slot_addr::**u8;
        @data_slot = utf8.data;

        val length_addr: *u8 = slot_addr + WORD_BYTES;
        val length_slot: *u64 = length_addr::*u64;
        @length_slot = utf8.len;

        index = index + 1;
    }

    ret [][]u8{ storage::*[]u8, argc };
}

fun collect_args_windows() [][]u8 {
    val cmd_line: *u16 = win32_get_command_line_w();
    var argc32: i32 = 0;
    val argv_wide: **u16 = win32_command_line_to_argv_w(cmd_line, (?argc32)::*i32);

    if (argv_wide == nil || argc32 <= 0) {
        if (argv_wide != nil) {
            win32_local_free(argv_wide::*u8);
        }
        ret [][]u8{ nil, 0 };
    }

    val argc: u64 = argc32::u64;
    val args: [][]u8 = build_args_windows(argc, argv_wide);
    win32_local_free(argv_wide::*u8);
    ret args;
}

#@symbol("mach_runtime_entry")
fun mach_runtime_entry() {
    val args: [][]u8 = collect_args_windows();
    val exit_code: i64 = main(args);
    mach_runtime_exit(exit_code);
}

pub ext "mach_runtime_exit" mach_runtime_exit: fun(i64);

asm {
.text
.globl _start
_start:
    and $-16, %rsp
    sub $32, %rsp
    call mach_runtime_entry
    hlt
;
.globl mach_runtime_exit
mach_runtime_exit:
    mov %rcx, %rcx
    call win32_exit_process
    hlt
}

#@or (OS == OS_LINUX || OS == OS_DARWIN)

fun cstring_length(s: *u8) u64 {
    if (s == nil) {
        ret 0;
    }

    var length: u64 = 0;
    var cursor: *u8 = s;
    for {
        if (@cursor == 0::u8) {
            brk;
        }
        length = length + 1;
        cursor = cursor + 1;
    }

    ret length;
}

fun build_args_posix(argc: u64, stack: *u8) [][]u8 {
    if (argc == 0) {
        ret [][]u8{ nil, 0 };
    }

    val entry_size: u64 = size_of([]u8{ nil, 0 });
    val total_bytes: u64 = argc * entry_size;
    val storage: *u8 = mem.allocate(total_bytes);
    if (storage == nil) {
        ret [][]u8{ nil, 0 };
    }

    val argv_base: *u8 = stack + WORD_BYTES;

    var index: u64 = 0;
    for (index < argc) {
        val offset: u64 = index * WORD_BYTES;
        val addr: *u8 = argv_base + offset;
        val raw: u64 = @(addr::*u64);
        val arg_ptr: *u8 = raw::*u8;
        val length: u64 = cstring_length(arg_ptr);

        val slot_offset: u64 = index * entry_size;
        val slot_addr: *u8 = storage + slot_offset;

        val data_slot: **u8 = slot_addr::**u8;
        @data_slot = arg_ptr;

        val length_addr: *u8 = slot_addr + WORD_BYTES;
        val length_slot: *u64 = length_addr::*u64;
        @length_slot = length;

        index = index + 1;
    }

    ret [][]u8{ storage::*[]u8, argc };
}

#@symbol("mach_runtime_entry")
fun mach_runtime_entry(stack: *u8) i64 {
    val argc: u64 = @(stack::*u64);
    val args: [][]u8 = build_args_posix(argc, stack);
    ret main(args);
}

pub ext "mach_runtime_exit" mach_runtime_exit: fun(i64);

#@if (OS == OS_LINUX)

asm {
.text
.globl _start
_start:
    mov %rsp, %rdi
    call mach_runtime_entry
    mov %rax, %rdi
    call mach_runtime_exit
    hlt
;
.globl mach_runtime_exit
mach_runtime_exit:
    mov $60, %rax
    syscall
    hlt
};

#@or (OS == OS_DARWIN)

asm {
.text
.globl _start
_start:
    mov %rsp, %rdi
    call mach_runtime_entry
    mov %rax, %rdi
    call mach_runtime_exit
    hlt
;
.globl mach_runtime_exit
mach_runtime_exit:
    mov $0x2000001, %rax
    syscall
    hlt
};

#@end
#@end

pub fun mach_panic(message: []u8) i64 {
    if (message.data == nil || message.len == 0) {
        # console.error("panic: abort\n");
        # placeholder
    }
    or {
        # console.error("panic: %s\n", message);
        # placeholder
    }

    mach_runtime_exit(255);
    ret 255;
}

#@symbol("abort")
pub fun abort() i64 {
    ret mach_panic("abort");
}
