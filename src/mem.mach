use target;
use std.os.linux.sys;

# posix constants (subset) (linux/bsd/darwin)
pub val PROT_READ:   i32 = 1;
pub val PROT_WRITE:  i32 = 2;
pub val MAP_PRIVATE: i32 = 2;
pub val MAP_ANON:    i32 = 32; # MAP_ANONYMOUS

pub fun mem_zero(p: *u8, size: u64) {
    if (p == nil || size == 0) {
        ret;
    }

    var i: u64 = 0;
    for (i < size) {
        @(p + i) = 0;
        i = i + 1;
    }
}

pub fun mem_fill(p: *u8, value: u8, size: u64) {
    if (p == nil || size == 0) {
        ret;
    }

    var i: u64 = 0;
    for (i < size) {
        @(p + i) = value;
        i = i + 1;
    }
}

pub fun mem_copy(dst: *u8, src: *u8, size: u64) {
    if (dst == nil || src == nil || size == 0) {
        ret;
    }

    var i: u64 = 0;
    for (i < size) {
        val b: u8 = @(src + i);
        @(dst + i) = b;
        i = i + 1;
    }
}

pub fun raw_copy(dst: *u8, src: *u8, size: u64) {
    mem_copy(dst, src, size);
}

# reserve+commit readable/writable anonymous memory (page aligned by kernel)
pub fun allocate(size: u64) *u8 {
    if (size == 0) {
        ret nil;
    }

    if (OS == OS_LINUX) {
        val ptr: *u8 = sys_mmap(nil, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
        if ((ptr :: i64) == -1) {
            ret nil;
        }

        ret ptr;
    }
    or (OS == OS_DARWIN || OS == OS_FREEBSD || OS == OS_NETBSD || OS == OS_OPENBSD || OS == OS_DRAGONFLY) {
        # TODO: add BSD/darwin variants (mmap via future raw syscall or platform glue)
        ret nil;
    }
    or {
        # windows path placeholder (will use VirtualAlloc or NtAllocateVirtualMemory)
        ret nil;
    }
}

pub fun deallocate(p: *u8, size: u64) u8 {
    if (p == nil || size == 0) {
        ret 0;
    }

    if (OS == OS_LINUX) {
        val r: i32 = sys_munmap(p, size);
        if (r == 0) {
            ret 0;
        }
        or {
            ret 1; # error
        }
    } or (OS == OS_DARWIN || OS == OS_FREEBSD || OS == OS_NETBSD || OS == OS_OPENBSD || OS == OS_DRAGONFLY) {
        ret 1; # unsupported
    } or {
        ret 1; # unsupported
    }
}

# simplistic reallocate: allocate new block, copy, free old
pub fun reallocate(p: *u8, old_size: u64, new_size: u64) *u8 {
    if (p == nil) {
        ret allocate(new_size);
    }

    if (new_size == 0) {
        deallocate(p, old_size);
        ret nil; 
    }

    val n: *u8 = allocate(new_size);
    if (n == nil) {
        ret nil;
    }

    var to_copy: u64 = 0;
    if (old_size < new_size) {
        to_copy = old_size;
    }
    or {
        to_copy = new_size;
    }

    mem_copy(n, p, to_copy);
    deallocate(p, old_size);

    ret n;
}
