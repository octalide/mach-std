use      std.types.size;
use      std.types.string;
use      std.types.cstring;
use      std.types.bool;
use      std.types.option;
use      std.types.result;
use mem: std.memory;

$if($mach.build.target.os.id == $mach.os.windows.id) {
    val PATH_SEPARATOR: u8 = '\\';
}
or {
    val PATH_SEPARATOR: u8 = '/';
}

pub def Path: String;

# create path from string (copies the string data)
pub fun path_from_string(s: str) Result[Path, str] {
    if (s.data == nil || s.len == 0) {
        ret err[Path, str]("cannot create path from empty string");
    }

    val res_clone: Result[String, str] = clone(s);
    if (res_clone.is_err()) {
        ret err[Path, str](res_clone.unwrap_err());
    }

    val cloned: String = res_clone.unwrap_ok();

    var path: Path;
    path.data = cloned.data;
    path.len  = cloned.len;

    ret ok[Path, str](path);
}

pub fun (this: *Path) init(len: usize) Option[str] {
    if (len == 0) {
        ret some[str]("cannot init string with zero length");
    }

    val opt_alloc: Option[*char] = mem.allocate[char](len);
    if (opt_alloc.is_none()) {
        ret some[str]("out of memory");
    }

    this.data = opt_alloc.unwrap();
    this.len  = len;

    ret none[str]();
}

pub fun (this: *Path) dnit() {
    mem.deallocate[char](this.data, this.len);
    mem.zero[Path](this, 1);
}

pub fun (this: Path) clone() Result[Path, str] {
    if (this.len == 0 || this.data == nil) {
        ret err[Path, str]("cannot clone empty path");
    }

    val opt_alloc: Option[*char] = mem.allocate[char](this.len);
    if (opt_alloc.is_none()) {
        ret err[Path, str]("allocation failed");
    }

    val new_data: *char = opt_alloc.unwrap();
    mem.copy[char](new_data, this.data, this.len);

    var new_path: Path;
    new_path.data = new_data;
    new_path.len  = this.len;

    ret ok[Path, str](new_path);
}

# convert path to string (borrows path data, does not allocate)
pub fun (this: Path) as_str() str {
    var s: str;
    s.data = this.data;
    s.len  = this.len;
    ret s;
}

pub fun (this: Path) as_cstr() Option[CString] {
    ret as_cstr(this.as_str());
}

pub fun (this: Path) basename() Option[str] {
    if (this.len == 0 || this.data == nil) {
        ret none[str]();
    }

    val s: str = this.as_str();
    
    # find last path separator
    var i: usize = s.len;
    for (i > 0) {
        i = i - 1;
        if (s.data[i] == PATH_SEPARATOR) {
            ret some[str](str{ s.data + i + 1, s.len - i - 1 });
        }
    }

    ret some[str](s);
}

pub fun (this: Path) dirname() Option[str] {
    if (this.len == 0 || this.data == nil) {
        ret none[str]();
    }

    val s: str = this.as_str();
    
    # find last path separator
    var i: usize = s.len;
    for (i > 0) {
        i = i - 1;
        if (s.data[i] == PATH_SEPARATOR) {
            ret some[str](str{ s.data, i });
        }
    }

    ret none[str]();
}

pub fun (this: Path) extension() Option[str] {
    if (this.len == 0 || this.data == nil) {
        ret none[str]();
    }

    val s: str = this.as_str();
    
    # find the last separator to avoid matching dots in directory names
    var start_pos: usize = 0;
    var j: usize = s.len;
    for (j > 0) {
        j = j - 1;
        if (s.data[j] == PATH_SEPARATOR) {
            start_pos = j + 1;
            brk;
        }
    }

    # search for dot after the last separator
    var i: usize = s.len;
    for (i > start_pos) {
        i = i - 1;
        if (s.data[i] == '.') {
            ret some[str](str{ s.data + i + 1, s.len - i - 1 });
        }
    }

    ret none[str]();
}

pub fun path_join(a: Path, b: Path) Result[Path, str] {
    if (a.len == 0) {
        ret ok[Path, str](a);
    }
    if (b.len == 0) {
        ret ok[Path, str](b);
    }

    val needs_sep: bool = a.data[a.len - 1] != PATH_SEPARATOR;
    var new_len:   usize = a.len + b.len;
    if (needs_sep) {
        new_len = new_len + 1;
    }

    val opt_alloc: Option[*char] = mem.allocate[char](new_len);
    if (opt_alloc.is_none()) {
        ret err[Path, str]("allocation failed");
    }

    val joined_data: *char = opt_alloc.unwrap();

    var offset: usize = 0;
    mem.copy[char](joined_data + offset, a.data, a.len);
    offset = offset + a.len;
    if (needs_sep) {
        joined_data[offset] = PATH_SEPARATOR;
        offset = offset + 1;
    }
    mem.copy[char](joined_data + offset, b.data, b.len);

    var joined: Path;
    joined.data = joined_data;
    joined.len  = new_len;

    ret ok[Path, str](joined);
}
