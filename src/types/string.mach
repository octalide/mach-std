use std.system.memory;
use std.types.bool;

pub def char:   u8;
pub def string: []char;

fun ensure_capacity(buf_ptr: **u8, cap_ptr: *u64, len: u64, needed: u64) u8 {
	val required: u64 = len + needed;
	var cap: u64 = @cap_ptr;
	if (required <= cap) { ret 1; }

	var new_cap: u64 = cap;
	if (new_cap == 0) { new_cap = 64; }

	for (new_cap < required) {
		new_cap = new_cap + (new_cap >> 1) + 16;
	}

	val current: *u8 = @buf_ptr;

	var fresh: *u8 = nil;
	if (current == nil) {
		fresh = allocate(new_cap);
	}
	or {
		fresh = reallocate(current, cap, new_cap);
	}

	if (fresh == nil) { ret 0; }

	@buf_ptr = fresh;
	@cap_ptr = new_cap;
	ret 1;
}


fun append_byte(buf_ptr: **u8, len_ptr: *u64, cap_ptr: *u64, ch: u8) u8 {
	val len: u64 = @len_ptr;
	if (ensure_capacity(buf_ptr, cap_ptr, len, 1) == 0) { ret 0; }

	val buf: *u8 = @buf_ptr;
	@(buf + len) = ch;
	@len_ptr = len + 1;
	ret 1;
}

fun append_slice(buf_ptr: **u8, len_ptr: *u64, cap_ptr: *u64, data: *u8, size: u64) u8 {
	if (size == 0 || data == nil) { ret 1; }

	val len: u64 = @len_ptr;
	if (ensure_capacity(buf_ptr, cap_ptr, len, size) == 0) { ret 0; }

	val buf: *u8 = @buf_ptr;
	memory_copy(buf + len, data, size);
	@len_ptr = len + size;
	ret 1;
}

fun append_string(buf_ptr: **u8, len_ptr: *u64, cap_ptr: *u64, value: string) u8 {
	if (value.length == 0 || value.data == nil) { ret 1; }
	ret append_slice(buf_ptr, len_ptr, cap_ptr, value.data, value.length);
}

fun append_unsigned_recursive(buf_ptr: **u8, len_ptr: *u64, cap_ptr: *u64, value: u64) u8 {
	if (value >= 10) {
		if (append_unsigned_recursive(buf_ptr, len_ptr, cap_ptr, value / 10) == 0) { ret 0; }
	}

	val digit_value: u64 = value % 10;
	val digit: u8 = ('0' :: u8) + (digit_value :: u8);
	ret append_byte(buf_ptr, len_ptr, cap_ptr, digit);
}

fun append_hex_recursive(buf_ptr: **u8, len_ptr: *u64, cap_ptr: *u64, value: u64, uppercase: u8) u8 {
	if (value >= 16) {
		if (append_hex_recursive(buf_ptr, len_ptr, cap_ptr, value / 16, uppercase) == 0) { ret 0; }
	}

	val digit: u64 = value % 16;
	var ch: u8 = '0' :: u8;
	if (digit < 10) {
		ch = ('0' :: u8) + (digit :: u8);
	}
	or {
		var base: u8 = 'a' :: u8;
		if (uppercase != 0) { base = 'A' :: u8; }
		val offset: u64 = digit - 10;
		ch = base + (offset :: u8);
	}

	ret append_byte(buf_ptr, len_ptr, cap_ptr, ch);
}

fun append_signed(buf_ptr: **u8, len_ptr: *u64, cap_ptr: *u64, value: i64) u8 {
	if (value < 0) {
		if (append_byte(buf_ptr, len_ptr, cap_ptr, '-' :: u8) == 0) { ret 0; }
		var magnitude: u64 = value :: u64;
		magnitude = (~magnitude) + 1;
		ret append_unsigned_recursive(buf_ptr, len_ptr, cap_ptr, magnitude);
	}

	ret append_unsigned_recursive(buf_ptr, len_ptr, cap_ptr, value :: u64);
}

fun append_unsigned(buf_ptr: **u8, len_ptr: *u64, cap_ptr: *u64, value: u64) u8 {
	ret append_unsigned_recursive(buf_ptr, len_ptr, cap_ptr, value);
}

fun append_hex(buf_ptr: **u8, len_ptr: *u64, cap_ptr: *u64, value: u64, uppercase: u8) u8 {
	if (value == 0) { ret append_byte(buf_ptr, len_ptr, cap_ptr, '0' :: u8); }
	ret append_hex_recursive(buf_ptr, len_ptr, cap_ptr, value, uppercase);
}

fun append_float(buf_ptr: **u8, len_ptr: *u64, cap_ptr: *u64, value: f64, precision: u64) u8 {
	# normalize special cases
	if (value != value) {
		val nan_text: []u8 = "nan";
		ret append_slice(buf_ptr, len_ptr, cap_ptr, nan_text.data, nan_text.length);
	}

	var local_precision: u64 = precision;
	if (local_precision == 0) {
		local_precision = 6;
	}

	var local_value: f64 = value;
	if (local_value < 0.0) {
		if (append_byte(buf_ptr, len_ptr, cap_ptr, '-' :: u8) == 0) { ret 0; }
		local_value = -local_value;
	}

	val integral_part: u64 = local_value :: u64;
	if (append_unsigned(buf_ptr, len_ptr, cap_ptr, integral_part) == 0) {
		ret 0;
	}

	if (append_byte(buf_ptr, len_ptr, cap_ptr, '.' :: u8) == 0) {
		ret 0;
	}

	var fractional: f64 = local_value - (integral_part :: f64);
	var index: u64 = 0;
	for (index < local_precision) {
		fractional = fractional * 10.0;
		val digit: u64 = fractional :: u64;
		if (append_byte(buf_ptr, len_ptr, cap_ptr, ('0' :: u8) + (digit :: u8)) == 0) {
			ret 0;
		}
		fractional = fractional - (digit :: f64);
		index = index + 1;
	}

	ret 1;
}

fun append_float_default(buf_ptr: **u8, len_ptr: *u64, cap_ptr: *u64, value: f64) u8 {
	ret append_float(buf_ptr, len_ptr, cap_ptr, value, 6);
}

fun append_bool(buf_ptr: **u8, len_ptr: *u64, cap_ptr: *u64, flag: u8) u8 {
	val true_text: []u8 = "true";
	val false_text: []u8 = "false";
	if (flag != 0) {
		ret append_slice(buf_ptr, len_ptr, cap_ptr, true_text.data, true_text.length);
	}
	ret append_slice(buf_ptr, len_ptr, cap_ptr, false_text.data, false_text.length);
}

fun append_escape(buf_ptr: **u8, len_ptr: *u64, cap_ptr: *u64, esc: u8) u8 {
	var mapped: u8 = esc;
	if (esc == 'n' :: u8) { mapped = 10 :: u8; }
	or (esc == 't' :: u8) { mapped = 9 :: u8; }
	or (esc == 'r' :: u8) { mapped = 13 :: u8; }
	or (esc == '0' :: u8) { mapped = 0 :: u8; }
	or (esc == '\\' :: u8) { mapped = '\\' :: u8; }
	or (esc == '"' :: u8) { mapped = '"' :: u8; }
	or (esc == '\'' :: u8) { mapped = '\'' :: u8; }

	ret append_byte(buf_ptr, len_ptr, cap_ptr, mapped);
}

fun finalize_buffer(buffer: *u8, capacity: u64, length: u64) string {
	if (length == 0) {
		if (buffer != nil && capacity != 0) { deallocate(buffer, capacity); }
		ret []u8{ nil, 0 };
	}

	if (buffer == nil) {
		ret []u8{ nil, 0 };
	}

	if (capacity > length) {
		val shrunk: *u8 = reallocate(buffer, capacity, length);
		if (shrunk != nil) {
			ret []u8{ shrunk, length };
		}
	}

	ret []u8{ buffer, length };
}

pub fun string_equal(a: string, b: string) bool {
	if (a.length != b.length)           { ret false; }
	if (a.length == 0)                  { ret true; }
	if (a.data == nil || b.data == nil) { ret false; }

	var i: u64 = 0;
	for (i < a.length) {
		val ac: u8 = @(a.data + i);
		val bc: u8 = @(b.data + i);
		if (ac != bc) { ret false; }
		i = i + 1;
	}

	ret true;
}

pub fun string_copy(value: string) string {
	if (value.length == 0 || value.data == nil) { ret []u8{ nil, 0 }; }

	val fresh: *u8 = allocate(value.length);
	if (fresh == nil) { ret []u8{ nil, 0 }; }

	memory_copy(fresh, value.data, value.length);
	ret []u8{ fresh, value.length };
}

pub fun string_ends_with(value: string, suffix: string) bool {
	if (suffix.length == 0) { ret true; }
	if (value.length < suffix.length) { ret false; }
	if (value.data == nil || suffix.data == nil) { ret false; }

	val start: u64 = value.length - suffix.length;
	var i: u64 = 0;
	for (i < suffix.length) {
		val vc: u8 = @(value.data + start + i);
		val sc: u8 = @(suffix.data + i);
		if (vc != sc) { ret false; }
		i = i + 1;
	}

	ret true;
}

pub fun string_starts_with(value: string, prefix: string) bool {
	if (prefix.length == 0) { ret true; }
	if (value.length < prefix.length) { ret false; }
	if (value.data == nil || prefix.data == nil) { ret false; }

	var i: u64 = 0;
	for (i < prefix.length) {
		val vc: u8 = @(value.data + i);
		val pc: u8 = @(prefix.data + i);
		if (vc != pc) { ret false; }
		i = i + 1;
	}

	ret true;
}

pub fun string_contains(value: string, segment: string) bool {
	if (segment.length == 0) { ret true; }
	if (value.length < segment.length) { ret false; }
	if (value.data == nil || segment.data == nil) { ret false; }

	var i: u64 = 0;
	val limit: u64 = value.length - segment.length + 1;
	for (i < limit) {
		var j: u64 = 0;
		for (j < segment.length) {
			val vc: u8 = @(value.data + i + j);
			val sc: u8 = @(segment.data + j);
			if (vc != sc) { brk; }
			j = j + 1;
		}
		if (j == segment.length) { ret true; }
		i = i + 1;
	}

	ret false;
}

pub fun string_last_index_of(value: string, ch: u8) i64 {
	if (value.length == 0 || value.data == nil) { ret -1; }

	var i: i64 = (value.length::i64) - 1;
	for (i >= 0) {
		val current: u8 = @(value.data + (i::u64));
		if (current == ch) { ret i; }
		i = i - 1;
	}

	ret -1;
}

pub fun string_substring(value: string, start: u64, end: u64) string {
	if (value.length == 0 || value.data == nil) { ret []u8{ nil, 0 }; }
	if (start >= value.length) { ret []u8{ nil, 0 }; }
	if (end > value.length)   { end = value.length; }
	if (start >= end)         { ret []u8{ nil, 0 }; }

	val size: u64 = end - start;
	val fresh: *u8 = allocate(size);
	if (fresh == nil) { ret []u8{ nil, 0 }; }

	memory_copy(fresh, value.data + start, size);
	ret []u8{ fresh, size };
}

pub fun string_length(value: string) u64 {
	if (value.data == nil) { ret 0; }
	ret value.length;
}

pub fun string_free(value: string) {
	if (value.data == nil || value.length == 0) { ret; }
	deallocate(value.data, value.length);
}

pub fun format(pattern: string, ...) string {
	if (pattern.length == 0 || pattern.data == nil) {
		ret []u8{ nil, 0 };
	}

	var buffer: *u8 = nil;
	var length: u64 = 0;
	var capacity: u64 = 0;

	val buffer_ptr: **u8 = (?buffer) :: **u8;
	val length_ptr: *u64 = (?length) :: *u64;
	val capacity_ptr: *u64 = (?capacity) :: *u64;

	var i: u64 = 0;
	var arg_index: u64 = 0;
	val arg_total: u64 = va_count();
	var ok: u8 = 1;

	for (i < pattern.length) {
		if (ok == 0) { brk; }

		val ch: u8 = @(pattern.data + i);

		if (ch == '\\' :: u8) {
			if ((i + 1) < pattern.length) {
				val next: u8 = @(pattern.data + i + 1);
				ok = append_escape(buffer_ptr, length_ptr, capacity_ptr, next);
				i = i + 2;
			}
			or {
				ok = append_byte(buffer_ptr, length_ptr, capacity_ptr, ch);
				i = i + 1;
			}
		}
		or (ch == '%' :: u8) {
			if ((i + 1) >= pattern.length) {
				ok = append_byte(buffer_ptr, length_ptr, capacity_ptr, ch);
				i = i + 1;
			}
			or {
				val spec: u8 = @(pattern.data + i + 1);
				if (spec == '%' :: u8) {
					ok = append_byte(buffer_ptr, length_ptr, capacity_ptr, '%' :: u8);
					i = i + 2;
				}
				or (arg_index >= arg_total) {
					ok = append_byte(buffer_ptr, length_ptr, capacity_ptr, '%' :: u8);
					if (ok != 0) { ok = append_byte(buffer_ptr, length_ptr, capacity_ptr, spec); }
					i = i + 2;
				}
				or {
					if (spec == 's' :: u8) {
						val ptr_s: *string = va_arg(arg_index)::*string;
						arg_index = arg_index + 1;
						val segment: string = @ptr_s;
						ok = append_string(buffer_ptr, length_ptr, capacity_ptr, segment);
					}
					or (spec == 'c' :: u8) {
						val ptr_c: *i32 = va_arg(arg_index)::*i32;
						arg_index = arg_index + 1;
						val ch_val: u8 = (@ptr_c) :: u8;
						ok = append_byte(buffer_ptr, length_ptr, capacity_ptr, ch_val);
					}
					or (spec == 'd' :: u8) {
						val ptr_d: *i64 = va_arg(arg_index)::*i64;
						arg_index = arg_index + 1;
						ok = append_signed(buffer_ptr, length_ptr, capacity_ptr, @ptr_d);
					}
					or (spec == 'i' :: u8) {
						val ptr_i: *i64 = va_arg(arg_index)::*i64;
						arg_index = arg_index + 1;
						ok = append_signed(buffer_ptr, length_ptr, capacity_ptr, @ptr_i);
					}
					or (spec == 'u' :: u8) {
						val ptr_u: *u64 = va_arg(arg_index)::*u64;
						arg_index = arg_index + 1;
						ok = append_unsigned(buffer_ptr, length_ptr, capacity_ptr, @ptr_u);
					}
					or (spec == 'x' :: u8) {
						val ptr_x: *u64 = va_arg(arg_index)::*u64;
						arg_index = arg_index + 1;
						ok = append_hex(buffer_ptr, length_ptr, capacity_ptr, @ptr_x, 0 :: u8);
					}
					or (spec == 'X' :: u8) {
						val ptr_X: *u64 = va_arg(arg_index)::*u64;
						arg_index = arg_index + 1;
						ok = append_hex(buffer_ptr, length_ptr, capacity_ptr, @ptr_X, 1 :: u8);
					}
					or (spec == 'f' :: u8) {
						val ptr_f: *f64 = va_arg(arg_index)::*f64;
						arg_index = arg_index + 1;
						ok = append_float_default(buffer_ptr, length_ptr, capacity_ptr, @ptr_f);
					}
					or (spec == 'F' :: u8) {
						val ptr_F: *f64 = va_arg(arg_index)::*f64;
						arg_index = arg_index + 1;
						ok = append_float_default(buffer_ptr, length_ptr, capacity_ptr, @ptr_F);
					}
					or (spec == 'b' :: u8) {
						val ptr_b: *u8 = va_arg(arg_index)::*u8;
						arg_index = arg_index + 1;
						ok = append_bool(buffer_ptr, length_ptr, capacity_ptr, @ptr_b);
					}
					or (spec == 'p' :: u8) {
						val ptr_p: *u8 = va_arg(arg_index)::*u8;
						arg_index = arg_index + 1;
						val prefix: []u8 = "0x";
						ok = append_slice(buffer_ptr, length_ptr, capacity_ptr, prefix.data, prefix.length);
						if (ok != 0) { ok = append_hex(buffer_ptr, length_ptr, capacity_ptr, (ptr_p :: u64), 0 :: u8); }
					}
					or {
						ok = append_byte(buffer_ptr, length_ptr, capacity_ptr, '%' :: u8);
						if (ok != 0) { ok = append_byte(buffer_ptr, length_ptr, capacity_ptr, spec); }
					}

					i = i + 2;
				}
			}
		}
		or {
			ok = append_byte(buffer_ptr, length_ptr, capacity_ptr, ch);
			i = i + 1;
		}

		if (ok == 0) { brk; }
	}

	if (ok == 0) {
		if (buffer != nil && capacity != 0) { deallocate(buffer, capacity); }
		ret []u8{ nil, 0 };
	}

	ret finalize_buffer(buffer, capacity, length);
}
