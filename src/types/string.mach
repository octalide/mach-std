use      std.types.bool;
use      std.types.option;
use      std.types.result;
use      std.types.size;
use mem: std.system.memory;

## Basic character type representing a single byte.
pub def char: u8;

## A mutable string type.
pub rec String {
    data: *u8;
    len:  usize;
}

## Create a string from a str (copies the str data)
## ---
## s:   The source str
## ret: The resulting String or an error message
pub fun string_make(s: str) Result[String, str] {
    if (s.data == nil || s.len == 0) {
        ret err[String, str]("cannot create string from empty data");
    }

    val string: String;
    val opt_init: Option[str] = string.init(s.len);
    if (opt_init.is_some()) {
        ret err[String, str](opt_init.unwrap());
    }

    mem.copy[char](string.data, s.data, s.len);

    ret ok[String, str](string);
}

## Initialize the string with the specified length.
## ---
## len: The length of the string.
## ret: An optional error message if initialization fails.
pub fun (this: *String) init(len: usize) Option[str] {
    if (this.data != nil) {
        ret some[str]("string is already initialized");
    }

    if (len == 0) {
        ret some[str]("cannot init string with zero length");
    }

    val res_alloc: Option[*char] = mem.zallocate[char](len);
    if (res_alloc.is_none()) {
        ret some[str]("out of memory");
    }

    this.data = res_alloc.unwrap();
    this.len  = len;

    ret none[str]();
}

## Deinitializes the string, deallocating and zeroing its data.
pub fun (this: *String) dnit() {
    mem.deallocate[char](this.data, this.len);
    mem.zero[String](this, 1);
}

## Returns a str view of the string's data.
## ---
## ret: A str representing the string's data.
pub fun (this: String) as_str() str {
    var view: str;
    view.data = this.data;
    view.len  = this.len;
    ret view;
}

## Ensures that the string has at least the specified length.
## ---
## new_len: The desired minimum length.
## ret:     True if the operation succeeded, false otherwise.
pub fun (this: *String) ensure_len(new_len: usize) bool {
    if (new_len <= this.len) {
        ret true;
    }

    val new_data: Option[*char] = mem.reallocate[char](this.data, this.len, new_len);
    if (new_data.is_none()) {
        ret false;
    }

    this.data = new_data.unwrap();

    # zero the new part
    mem.zero[char](this.data + this.len, new_len - this.len);

    this.len = new_len;

    ret true;
}

## Appends a single character to the end of the string.
## ---
## ch:  The character to append.
## ret: True if the operation succeeded, false otherwise.
pub fun (this: *String) push(ch: char) bool {
    val current_len: usize = this.len;

    if (this.ensure_len(this.len + 1) == false) {
        ret false;
    }

    this.data[current_len] = ch;

    ret true;
}

## Appends a str to the end of the string.
## ---
## s:   The str to append.
## ret: True if the operation succeeded, false otherwise.
pub fun (this: *String) append(s: str) bool {
    if (s.len == 0) {
        ret true;
    }

    val old_len: usize = this.len;

    if (this.ensure_len(this.len + s.len) == false) {
        ret false;
    }

    mem.copy[char](this.data + old_len, s.data, s.len);

    ret true;
}

## Appends an escape sequence character to the string.
## ---
## s:  Pointer to the String to append to.
## ch: The escape sequence character.
## ret: True if the operation succeeded, false otherwise.
fun append_escape_sequence(s: *String, ch: char) bool {
    var mapped: char = ch;
    if (ch == 'n')  { mapped = 10; }
    or (ch == 't')  { mapped = 9; }
    or (ch == 'r')  { mapped = 13; }
    or (ch == '0')  { mapped = 0; }
    or (ch == '\\') { mapped = '\\'; }
    or (ch == '"')  { mapped = '"'; }
    or (ch == '\'') { mapped = '\''; }

    ret s.push(mapped);
}

## Appends an unsigned decimal number to the string.
## ---
## s:     Pointer to the String to append to.
## value: The unsigned decimal number to append.
## ret:   True if the operation succeeded, false otherwise.
fun append_unsigned_decimal(s: *String, value: usize) bool {
    if (value == 0) {
        ret s.push('0');
    }

    var digits: [20]char;
    var count:  usize = 0;

    var n: usize = value;
    for (n > 0) {
        digits[count] = ('0' + (n % 10)::char);
        count = count + 1;
        n = n / 10;
    }

    # append in reverse order
    for (count > 0) {
        count = count - 1;
        if (s.push(digits[count]) == false) {
            ret false;
        }
    }

    ret true;
}

## Appends a signed decimal number to the string.
## ---
## s:     Pointer to the String to append to.
## value: The signed decimal number to append.
## ret:   True if the operation succeeded, false otherwise.
fun append_signed_decimal(s: *String, value: isize) bool {
    if (value < 0) {
        if (s.push('-') == false) {
            ret false;
        }
        val abs_value: usize = (0 - value)::usize;
        ret append_unsigned_decimal(s, abs_value);
    }

    ret append_unsigned_decimal(s, value::usize);
}

## Appends a hexadecimal number to the string.
## ---
## s:         Pointer to the String to append to.
## value:     The hexadecimal number to append.
## uppercase: Whether to use uppercase letters for A-F.
## ret:       True if the operation succeeded, false otherwise.
fun append_hex(s: *String, value: usize, uppercase: bool) bool {
    if (value == 0) {
        ret s.push('0');
    }

    var digits: [16]char;
    var count: usize = 0;

    var n: usize = value;
    for (n > 0) {
        val digit: char = (n % 16)::char;
        if (digit < 10) {
            digits[count] = '0' + digit;
        } or {
            if (uppercase) {
                digits[count] = 'A' + (digit - 10);
            } or {
                digits[count] = 'a' + (digit - 10);
            }
        }
        count = count + 1;
        n = n / 16;
    }

    # append in reverse order
    for (count > 0) {
        count = count - 1;
        if (s.push(digits[count]) == false) {
            ret false;
        }
    }

    ret true;
}

## Appends a boolean value to the string.
## ---
## s:     Pointer to the String to append to.
## value: The boolean value to append.
## ret:   True if the operation succeeded, false otherwise.
fun append_bool(s: *String, value: bool) bool {
    if (value) {
        ret s.append("true");
    }
    ret s.append("false");
}

## Appends a pointer value to the string in hexadecimal format.
## ---
## s:     Pointer to the String to append to.
## value: The pointer value to append.
## ret:   True if the operation succeeded, false otherwise.
fun append_pointer(s: *String, value: ptr) bool {
    if (s.append("0x") == false) {
        ret false;
    }

    val addr: usize = value::usize;
    ret append_hex(s, addr, false);
}

## Formats a string using a pattern and variable arguments.
## Supported format specifiers:
##   %s - string
##   %d - signed decimal integer
##   %u - unsigned decimal integer
##   %x - hexadecimal integer (lowercase)
##   %X - hexadecimal integer (uppercase)
##   %b - boolean
##   %p - pointer
## ---
## pattern: The format pattern string.
## ...:     Variable arguments corresponding to format specifiers.
## ret:     An Option[String] containing the formatted string, or none on failure.
pub fun format(pattern: str, ...) Option[String] {
    if (pattern.data == nil && pattern.len > 0) {
        ret none[String]();
    }

    # if no format specifiers needed, just clone the pattern
    val arg_count: usize = va_count();
    if (arg_count == 0) {
        # no arguments - check if pattern needs escaping
        var needs_processing: bool = false;
        var i: usize = 0;
        for (i < pattern.len) {
            val ch: char = pattern.data[i];
            if (ch == '\\' || ch == '%') {
                needs_processing = true;
                brk;
            }
            i = i + 1;
        }

        if (needs_processing == false) {
            # just clone
            val res_clone: Result[String, str] = clone(pattern);
            if (res_clone.is_err()) {
                ret none[String]();
            }

            ret some[String](res_clone.unwrap_ok());
        }
    }

    var result: String;
    val opt_init: Option[str] = result.init(pattern.len);
    if (opt_init.is_some()) {
        ret none[String]();
    }

    var arg_index: usize = 0;
    var pos:       usize = 0;

    for (pos < pattern.len) {
        val ch: char = pattern.data[pos];

        if (ch == '\\' && (pos + 1) < pattern.len) {
            val next: char = pattern.data[pos + 1];
            if (append_escape_sequence(?result, next) == false) {
                result.dnit();
                ret none[String]();
            }
            pos = pos + 2;
        }
        or (ch == '%' && (pos + 1) < pattern.len) {
            val spec: char = pattern.data[pos + 1];

            if (spec == '%') {
                # literal '%'
                if (result.push('%') == false) {
                    result.dnit();
                    ret none[String]();
                }
                pos = pos + 2;
            }
            or (arg_index >= arg_count) {
                # not enough arguments - keep literal
                if (result.push('%') == false || result.push(spec) == false) {
                    result.dnit();
                    ret none[String]();
                }
                pos = pos + 2;
            }
            or (spec == 's') {
                val arg_str: *str = va_arg(arg_index)::*str;
                if (result.append(@arg_str) == false) {
                    result.dnit();
                    ret none[String]();
                }
                arg_index = arg_index + 1;
                pos = pos + 2;
            }
            or (spec == 'd') {
                val arg_int: *isize = va_arg(arg_index)::*isize;
                if (append_signed_decimal(?result, @arg_int) == false) {
                    result.dnit();
                    ret none[String]();
                }
                arg_index = arg_index + 1;
                pos = pos + 2;
            }
            or (spec == 'u') {
                val arg_uint: *usize = va_arg(arg_index)::*usize;
                if (append_unsigned_decimal(?result, @arg_uint) == false) {
                    result.dnit();
                    ret none[String]();
                }
                arg_index = arg_index + 1;
                pos = pos + 2;
            }
            or (spec == 'x') {
                val arg_hex: *usize = va_arg(arg_index)::*usize;
                if (append_hex(?result, @arg_hex, false) == false) {
                    result.dnit();
                    ret none[String]();
                }
                arg_index = arg_index + 1;
                pos = pos + 2;
            }
            or (spec == 'X') {
                val arg_hex: *usize = va_arg(arg_index)::*usize;
                if (append_hex(?result, @arg_hex, true) == false) {
                    result.dnit();
                    ret none[String]();
                }
                arg_index = arg_index + 1;
                pos = pos + 2;
            }
            or (spec == 'b') {
                val arg_bool: *bool = va_arg(arg_index)::*bool;
                if (append_bool(?result, @arg_bool) == false) {
                    result.dnit();
                    ret none[String]();
                }
                arg_index = arg_index + 1;
                pos = pos + 2;
            }
            or (spec == 'p') {
                val arg_ptr: *ptr = va_arg(arg_index)::*ptr;
                if (append_pointer(?result, @arg_ptr) == false) {
                    result.dnit();
                    ret none[String]();
                }
                arg_index = arg_index + 1;
                pos = pos + 2;
            }
            or {
                # unknown specifier - keep literal
                if (result.push('%') == false || result.push(spec) == false) {
                    result.dnit();
                    ret none[String]();
                }
                pos = pos + 2;
            }
        }
        or {
            if (result.push(ch) == false) {
                result.dnit();
                ret none[String]();
            }
            pos = pos + 1;
        }
    }

    ret some[String](result);
}
