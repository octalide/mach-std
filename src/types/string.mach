use      std.types.bool;
use      std.types.option;
use      std.types.result;
use mem: std.system.memory;

pub def char:   u8;
pub def string: []char;

pub fun string.is_empty(this: string) bool {
    ret this.len == 0;
}

pub fun string.is_valid(this: string) bool {
    ret this.data != nil || this.len == 0;
}

pub fun string.equals(this: string, other: string) bool {
    if (this.len != other.len) {
        ret false;
    }

    var i: u64 = 0;
    for (i < this.len) {
        if (@(this.data + i) != @(other.data + i)) {
            ret false;
        }
        i = i + 1;
    }

    ret true;
}

pub fun string.compare(this: string, other: string) i64 {
    var min_len: u64 = this.len;
    if (other.len < min_len) {
        min_len = other.len;
    }
    
    var i: u64 = 0;
    for (i < min_len) {
        val a: u8 = @(this.data + i);
        val b: u8 = @(other.data + i);
        
        if (a < b) {
            ret -1;
        }
        or (a > b) {
            ret 1;
        }
        
        i = i + 1;
    }
    
    if (this.len < other.len) {
        ret -1;
    }
    or (this.len > other.len) {
        ret 1;
    }
    ret 0;
}

pub fun string.starts_with(this: string, prefix: string) bool {
    if (this.len < prefix.len) {
        ret false;
    }

    var i: u64 = 0;
    for (i < prefix.len) {
        if (@(this.data + i) != @(prefix.data + i)) {
            ret false;
        }
        i = i + 1;
    }

    ret true;
}

pub fun string.ends_with(this: string, suffix: string) bool {
    if (this.len < suffix.len) {
        ret false;
    }

    val offset: u64 = this.len - suffix.len;
    var i: u64 = 0;
    for (i < suffix.len) {
        if (@(this.data + offset + i) != @(suffix.data + i)) {
            ret false;
        }
        i = i + 1;
    }

    ret true;
}

pub fun string.contains(this: string, segment: string) bool {
    if (this.data == nil || segment.data == nil || segment.len == 0 || segment.len > this.len) {
        ret false;
    }

    var i: u64 = 0;
    for (i <= this.len - segment.len) {
        var found: bool = true;

        var j: u64 = 0;
        for (j < segment.len) {
            if (@(this.data + i + j) != @(segment.data + j)) {
                found = false;
                brk;
            }
            j = j + 1;
        }

        if (found) {
            ret true;
        }

        i = i + 1;
    }

    ret false;
}

pub fun string.index_of(this: string, segment: string) Option<u64> {
    if (this.data == nil || segment.data == nil || segment.len == 0 || segment.len > this.len) {
        ret none<u64>();
    }

    var i: u64 = 0;
    for (i <= this.len - segment.len) {
        var found: bool = true;

        var j: u64 = 0;
        for (j < segment.len) {
            if (@(this.data + i + j) != @(segment.data + j)) {
                found = false;
                brk;
            }
            j = j + 1;
        }

        if (found) {
            ret some<u64>(i);
        }

        i = i + 1;
    }

    ret none<u64>();
}

pub fun string.last_index_of(this: string, segment: string) Option<u64> {
    if (this.data == nil || segment.data == nil || segment.len == 0 || segment.len > this.len) {
        ret none<u64>();
    }

    var i: u64 = this.len - segment.len;
    for (i >= 0) {
        var found: bool = true;

        var j: u64 = 0;
        for (j < segment.len) {
            if (@(this.data + i + j) != @(segment.data + j)) {
                found = false;
                brk;
            }
            j = j + 1;
        }

        if (found) {
            ret some<u64>(i);
        }

        if (i == 0) {
            brk;
        }
        i = i - 1;
    }

    ret none<u64>();
}

pub fun string.substring(this: string, start: u64, end: u64) Option<string> {
    if (this.data == nil || start >= end || end > this.len) {
        ret none<string>();
    }

    val sub_len:  u64   = end - start;
    val sub_data: *char = mem.alloc<char>(sub_len);
    if (sub_data == nil) {
        ret none<string>();
    }

    mem.raw_copy(sub_data::ptr, (this.data + start)::ptr, sub_len);

    var substring: string;
    substring.data = sub_data;
    substring.len  = sub_len;

    ret some<string>(substring);
}

pub fun string.clone(this: string) Option<string> {
    if (this.len == 0) {
        var empty: string;
        empty.data = nil;
        empty.len = 0;
        ret some<string>(empty);
    }

    val new_data: *char = mem.alloc<char>(this.len);
    if (new_data == nil) {
        ret none<string>();
    }

    mem.raw_copy(new_data::ptr, this.data::ptr, this.len);

    var cloned: string;
    cloned.data = new_data;
    cloned.len  = this.len;

    ret some<string>(cloned);
}

pub fun string.free(this: *string) {
    if (this.data != nil && this.len > 0) {
        mem.dealloc<char>(this.data, this.len);
        this.data = nil;
        this.len = 0;
    }
}

str StringBuilder {
    data: *u8;
    len:  u64;
    cap:  u64;
}

fun StringBuilder.init(this: *StringBuilder, initial_cap: u64) bool {
    this.data = nil;
    this.len = 0;
    this.cap = 0;

    if (initial_cap == 0) {
        ret true;
    }

    this.data = mem.alloc<u8>(initial_cap);
    if (this.data == nil) {
        ret false;
    }

    this.cap = initial_cap;
    ret true;
}

fun StringBuilder.ensure_capacity(this: *StringBuilder, needed: u64) bool {
    if (this.len + needed <= this.cap) {
        ret true;
    }

    var new_cap: u64 = this.cap;
    if (new_cap == 0) {
        new_cap = 64;
    }

    for (new_cap < this.len + needed) {
        if (new_cap >= 0xFFFFFFFFFFFFFFFF / 2) {
            new_cap = this.len + needed;
            brk;
        }
        new_cap = new_cap * 2;
    }

    val new_data: *u8 = mem.realloc<u8>(this.data, this.cap, new_cap);
    if (new_data == nil) {
        ret false;
    }

    this.data = new_data;
    this.cap = new_cap;
    ret true;
}

fun StringBuilder.append_byte(this: *StringBuilder, ch: u8) bool {
    if (this.ensure_capacity(1) == false) {
        ret false;
    }

    @(this.data + this.len) = ch;
    this.len = this.len + 1;
    ret true;
}

fun StringBuilder.append_bytes(this: *StringBuilder, data: *u8, len: u64) bool {
    if (len == 0) {
        ret true;
    }

    if (this.ensure_capacity(len) == false) {
        ret false;
    }

    mem.raw_copy((this.data + this.len)::ptr, data::ptr, len);
    this.len = this.len + len;
    ret true;
}

fun StringBuilder.append_string(this: *StringBuilder, s: string) bool {
    ret this.append_bytes(s.data, s.len);
}

fun StringBuilder.finalize(this: *StringBuilder) Result<string, string> {
    if (this.len == 0) {
        if (this.data != nil && this.cap > 0) {
            mem.dealloc<u8>(this.data, this.cap);
        }
        
        var empty: string;
        empty.data = nil;
        empty.len = 0;
        ret ok<string, string>(empty);
    }

    if (this.data == nil) {
        ret err<string, string>("invalid builder state");
    }

    # shrink to exact size if needed
    if (this.cap > this.len) {
        val shrunk: *u8 = mem.realloc<u8>(this.data, this.cap, this.len);
        if (shrunk != nil) {
            this.data = shrunk;
            this.cap = this.len;
        }
    }

    var result: string;
    result.data = this.data;
    result.len  = this.len;

    # transfer ownership
    this.data = nil;
    this.len = 0;
    this.cap = 0;

    ret ok<string, string>(result);
}

fun StringBuilder.free(this: *StringBuilder) {
    if (this.data != nil && this.cap > 0) {
        mem.dealloc<u8>(this.data, this.cap);
        this.data = nil;
        this.len = 0;
        this.cap = 0;
    }
}

fun append_escape_sequence(sb: *StringBuilder, ch: u8) bool {
    var mapped: u8 = ch;
    if (ch == 'n')  { mapped = 10; }
    or (ch == 't')  { mapped = 9; }
    or (ch == 'r')  { mapped = 13; }
    or (ch == '0')  { mapped = 0; }
    or (ch == '\\') { mapped = '\\'; }
    or (ch == '"')  { mapped = '"'; }
    or (ch == '\'') { mapped = '\''; }

    ret sb.append_byte(mapped);
}

fun append_unsigned_decimal(sb: *StringBuilder, value: u64) bool {
    if (value == 0) {
        ret sb.append_byte('0');
    }

    var digits: [20]u8;
    var count: u64 = 0;

    var n: u64 = value;
    for (n > 0) {
        digits[count] = ('0' + (n % 10)::u8);
        count = count + 1;
        n = n / 10;
    }

    # append in reverse order
    for (count > 0) {
        count = count - 1;
        if (sb.append_byte(digits[count]) == false) {
            ret false;
        }
    }

    ret true;
}

fun append_signed_decimal(sb: *StringBuilder, value: i64) bool {
    if (value < 0) {
        if (sb.append_byte('-') == false) {
            ret false;
        }
        val abs_value: u64 = (0 - value)::u64;
        ret append_unsigned_decimal(sb, abs_value);
    }

    ret append_unsigned_decimal(sb, value::u64);
}

fun append_hex(sb: *StringBuilder, value: u64, uppercase: bool) bool {
    if (value == 0) {
        ret sb.append_byte('0');
    }

    var digits: [16]u8;
    var count: u64 = 0;

    var n: u64 = value;
    for (n > 0) {
        val digit: u8 = (n % 16)::u8;
        if (digit < 10) {
            digits[count] = '0' + digit;
        } or {
            if (uppercase) {
                digits[count] = 'A' + (digit - 10);
            } or {
                digits[count] = 'a' + (digit - 10);
            }
        }
        count = count + 1;
        n = n / 16;
    }

    # append in reverse order
    for (count > 0) {
        count = count - 1;
        if (sb.append_byte(digits[count]) == false) {
            ret false;
        }
    }

    ret true;
}

fun append_bool(sb: *StringBuilder, value: bool) bool {
    if (value) {
        ret sb.append_string("true");
    }
    ret sb.append_string("false");
}

fun append_pointer(sb: *StringBuilder, value: ptr) bool {
    if (sb.append_string("0x") == false) {
        ret false;
    }

    val addr: u64 = value::u64;
    ret append_hex(sb, addr, false);
}

pub fun format(pattern: string, ...) Result<string, string> {
    if (pattern.data == nil && pattern.len > 0) {
        ret err<string, string>("invalid pattern: null data with non-zero length");
    }

    val arg_count: u64 = va_count();

    if (arg_count == 0) {
        # no arguments - just return the pattern
        # check if pattern needs escaping
        var needs_processing: bool = false;
        var i: u64 = 0;
        for (i < pattern.len) {
            val ch: u8 = @(pattern.data + i);
            if (ch == '\\' || ch == '%') {
                needs_processing = true;
                brk;
            }
            i = i + 1;
        }
        
        if (needs_processing == false) {
            ret ok<string, string>(pattern);
        }
    }

    var sb: StringBuilder;
    if (sb.init(pattern.len + 64) == false) {
        ret err<string, string>("failed to initialize string builder");
    }

    var arg_index: u64 = 0;
    var pos: u64 = 0;

    for (pos < pattern.len) {
        val ch: u8 = @(pattern.data + pos);

        if (ch == '\\' && (pos + 1) < pattern.len) {
            val next: u8 = @(pattern.data + pos + 1);
            if (append_escape_sequence(?sb, next) == false) {
                sb.free();
                ret err<string, string>("allocation failed during escape sequence");
            }
            pos = pos + 2;
        }
        or (ch == '%' && (pos + 1) < pattern.len) {
            val spec: u8 = @(pattern.data + pos + 1);

            if (spec == '%') {
                # literal '%'
                if (sb.append_byte('%') == false) {
                    sb.free();
                    ret err<string, string>("allocation failed");
                }
                pos = pos + 2;
            }
            or (arg_index >= arg_count) {
                # not enough arguments - keep literal
                if (sb.append_byte('%') == false || sb.append_byte(spec) == false) {
                    sb.free();
                    ret err<string, string>("allocation failed");
                }
                pos = pos + 2;
            }
            or (spec == 's') {
                val arg_str: *string = va_arg(arg_index)::*string;
                if (sb.append_string(@arg_str) == false) {
                    sb.free();
                    ret err<string, string>("allocation failed during string append");
                }
                arg_index = arg_index + 1;
                pos = pos + 2;
            }
            or (spec == 'd') {
                val arg_int: *i64 = va_arg(arg_index)::*i64;
                if (append_signed_decimal(?sb, @arg_int) == false) {
                    sb.free();
                    ret err<string, string>("allocation failed during signed decimal");
                }
                arg_index = arg_index + 1;
                pos = pos + 2;
            }
            or (spec == 'u') {
                # DEBUG: We hit the %u handler
                val arg_uint: *u64 = va_arg(arg_index)::*u64;
                val val_copy: u64 = @arg_uint;
                if (append_unsigned_decimal(?sb, val_copy) == false) {
                    sb.free();
                    ret err<string, string>("allocation failed during unsigned decimal");
                }
                arg_index = arg_index + 1;
                pos = pos + 2;
            }
            or (spec == 'x') {
                val arg_hex: *u64 = va_arg(arg_index)::*u64;
                if (append_hex(?sb, @arg_hex, false) == false) {
                    sb.free();
                    ret err<string, string>("allocation failed during hex");
                }
                arg_index = arg_index + 1;
                pos = pos + 2;
            }
            or (spec == 'X') {
                val arg_hex: *u64 = va_arg(arg_index)::*u64;
                if (append_hex(?sb, @arg_hex, true) == false) {
                    sb.free();
                    ret err<string, string>("allocation failed during hex");
                }
                arg_index = arg_index + 1;
                pos = pos + 2;
            }
            or (spec == 'b') {
                val arg_bool: *bool = va_arg(arg_index)::*bool;
                if (append_bool(?sb, @arg_bool) == false) {
                    sb.free();
                    ret err<string, string>("allocation failed during bool");
                }
                arg_index = arg_index + 1;
                pos = pos + 2;
            }
            or (spec == 'p') {
                val arg_ptr: *ptr = va_arg(arg_index)::*ptr;
                if (append_pointer(?sb, @arg_ptr) == false) {
                    sb.free();
                    ret err<string, string>("allocation failed during pointer");
                }
                arg_index = arg_index + 1;
                pos = pos + 2;
            }
            or {
                # unknown specifier - keep literal
                if (sb.append_byte('%') == false || sb.append_byte(spec) == false) {
                    sb.free();
                    ret err<string, string>("allocation failed");
                }
                pos = pos + 2;
            }
        }
        or {
            if (sb.append_byte(ch) == false) {
                sb.free();
                ret err<string, string>("allocation failed during character append");
            }
            pos = pos + 1;
        }
    }

    ret sb.finalize();
}
