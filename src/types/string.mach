use      std.types.bool;
use      std.types.option;
use      std.types.result;
use mem: std.system.memory;

pub def char:   u8;
pub def string: []char;

pub fun string.substring(this: string, start: u64, end: u64) Option<string> {
    var result: Option<string>;

    if (this.data == nil || start >= end || end > this.len) {
        result.is_some = false;
        ret result;
    }

    val sub_len:  u64   = end - start;
    val sub_data: *char = mem.alloc<char>(sub_len);
    if (sub_data == nil) {
        result.is_some = false;
        ret result;
    }

    var i: u64 = 0;
    for (i < sub_len) {
        @(sub_data + i) = @(this.data + start + i);
        i = i + 1;
    }

    result.is_some = true;

    var substring: string;
    substring.data  = sub_data;
    substring.len   = sub_len;
    result.value    = substring;

    ret result;
}

pub fun string.index_of(this: string, segment: string) Option<u64> {
    var result: Option<u64>;
    result.is_some = false;

    if (this.data == nil || segment.data == nil || segment.len == 0 || segment.len > this.len) {
        ret result;
    }

    var i: u64 = 0;
    for (i <= this.len - segment.len) {
        var found: bool = true;

        var j: u64 = 0;
        for (j < segment.len) {
            if (@(this.data + i + j) != @(segment.data + j)) {
                found = false;
                brk;
            }
            j = j + 1;
        }

        if (found) {
            result.is_some = true;
            result.value   = i;
            ret result;
        }

        i = i + 1;
    }

    ret result;
}

pub fun string.last_index_of(this: string, segment: string) Option<u64> {
    var result: Option<u64>;
    result.is_some = false;

    if (this.data == nil || segment.data == nil || segment.len == 0 || segment.len > this.len) {
        ret result;
    }

    var i: u64 = this.len - segment.len;
    for (i >= 0) {
        var found: bool = true;

        var j: u64 = 0;
        for (j < segment.len) {
            if (@(this.data + i + j) != @(segment.data + j)) {
                found = false;
                brk;
            }
            j = j + 1;
        }

        if (found) {
            result.is_some = true;
            result.value   = i;
            ret result;
        }

        if (i == 0) {
            brk;
        }
        i = i - 1;
    }

    ret result;
}

pub fun string.contains(this: string, segment: string) bool {
    if (this.data == nil || segment.data == nil || segment.len == 0 || segment.len > this.len) {
        ret false;
    }

    var i: u64 = 0;
    for (i <= this.len - segment.len) {
        var found: bool = true;

        var j: u64 = 0;
        for (j < segment.len) {
            if (@(this.data + i + j) != @(segment.data + j)) {
                found = false;
                brk;
            }
            j = j + 1;
        }

        if (found) {
            ret true;
        }

        i = i + 1;
    }

    ret false;
}

pub fun string.equals(this: string, other: string) bool {
    if (this.len != other.len) {
        ret false;
    }

    var i: u64 = 0;
    for (i < this.len) {
        if (@(this.data + i) != @(other.data + i)) {
            ret false;
        }
        i = i + 1;
    }

    ret true;
}

pub fun string.starts_with(this: string, prefix: string) bool {
    if (this.len < prefix.len) {
        ret false;
    }

    var i: u64 = 0;
    for (i < prefix.len) {
        if (@(this.data + i) != @(prefix.data + i)) {
            ret false;
        }
        i = i + 1;
    }

    ret true;
}

pub fun string.ends_with(this: string, suffix: string) bool {
    if (this.len < suffix.len) {
        ret false;
    }

    var i: u64 = 0;
    for (i < suffix.len) {
        if (@(this.data + this.len - suffix.len + i) != @(suffix.data + i)) {
            ret false;
        }
        i = i + 1;
    }

    ret true;
}

fun append_escape(buf: *u8, len: *u64, cap: *u64, ch: u8) bool {
    var mapped: u8 = ch;
    if (ch == 'n')  { mapped = 10; }
    or (ch == 't')  { mapped = 9; }
    or (ch == 'r')  { mapped = 13; }
    or (ch == '\\') { mapped = '\\'; }
    or (ch == '"')  { mapped = '"'; }
    or (ch == '\'') { mapped = '\''; }

    ret append_byte(buf, len, cap, mapped);
}

fun append_byte(buf: *u8, len: *u64, cap: *u64, ch: u8) bool {
    if (buf == nil || len == nil || cap == nil) {
        ret false;
    }

    if ((@len + 1) > @cap) {
        var new_cap: u64;
        if (@cap == 0) {
            new_cap = 64;
        } or {
            new_cap = @cap * 2;
        }
        val new_buf: *u8 = mem.realloc<u8>(buf, @cap, new_cap);
        if (new_buf == nil) {
            ret false;
        }
        buf  = new_buf;
        @cap = new_cap;
    }

    @(buf + @len) = ch;
    @len  = @len + 1;

    ret true;
}

fun append_string(buf: *u8, len: *u64, cap: *u64, s: string) bool {
    var i: u64 = 0;
    for (i < s.len) {
        val ch: u8   = @(s.data + i);
        val ok: bool = append_byte(buf, len, cap, ch);
        if (ok == false) {
            ret false;
        }
        i = i + 1;
    }
    ret true;
}

fun append_unsigned(buf: *u8, len: *u64, cap: *u64, value: u64) bool {
    if (value == 0) {
        ret append_byte(buf, len, cap, '0');
    }

    var digits: [20]u8;
    var digit_count: u64 = 0;

    var i: u64 = value;
    for (i > 0) {
        val digit: u8 = (i % 10)::u8;
        digits[digit_count] = '0' + digit;
        digit_count         = digit_count + 1;
        i = i / 10;
    }

    i = 0;
    for (i < digit_count) {
        val ch: u8   = digits[digit_count - i - 1];
        val ok: bool = append_byte(buf, len, cap, ch);
        if (ok == false) {
            ret false;
        }
        i = i + 1;
    }

    ret true;
}

fun append_signed(buf: *u8, len: *u64, cap: *u64, value: i64) bool {
    if (value < 0) {
        val ok_minus: bool = append_byte(buf, len, cap, '-');
        if (ok_minus == false) {
            ret false;
        }
        val abs_value: u64 = (0 - value)::u64;
        ret append_unsigned(buf, len, cap, abs_value);
    }
    or {
        ret append_unsigned(buf, len, cap, value::u64);
    }
}

fun append_hex(buf: *u8, len: *u64, cap: *u64, value: u64, uppercase: bool) bool {
    if (value == 0) {
        ret append_byte(buf, len, cap, '0');
    }

    var digits: [16]u8;
    var digit_count: u64 = 0;

    var i: u64 = value;
    for (i > 0) {
        val digit: u8 = (i % 16)::u8;
        if (digit < 10) {
            digits[digit_count] = '0' + digit;
        }
        or {
            if (uppercase) {
                digits[digit_count] = 'A' + (digit - 10);
            }
            or {
                digits[digit_count] = 'a' + (digit - 10);
            }
        }
        digit_count = digit_count + 1;
        i = i / 16;
    }

    i = 0;
    for (i < digit_count) {
        val ch: u8   = digits[digit_count - i - 1];
        val ok: bool = append_byte(buf, len, cap, ch);
        if (ok == false) {
            ret false;
        }
        i = i + 1;
    }

    ret true;
}

fun append_float(buf: *u8, len: *u64, cap: *u64, value: f64, precision: u64) bool {
    # TODO: handle special snowflake float formatting

    # append a temporary "NA" string for now
    ret append_string(buf, len, cap, "NA");
}

fun append_bool(buf: *u8, len: *u64, cap: *u64, value: bool) bool {
    if (value) { ret append_string(buf, len, cap, "true"); }
    or         { ret append_string(buf, len, cap, "false"); }
}

fun append_pointer(buf: *u8, len: *u64, cap: *u64, value: ptr) bool {
    val ok_prefix: bool = append_string(buf, len, cap, "0x");
    if (ok_prefix == false) {
        ret false;
    }

    val addr: u64 = @(value::*u8)::*u64;
    ret append_hex(buf, len, cap, addr, false);
}

# TODO: clean up error reporting and pointer loss. be consistent with heap/stack.
fun finalize_buffer(buf: *u8, cap: u64, len: u64) Result<string, string> {
    if (len == 0) {
        if (buf != nil && cap > 0) {
            mem.dealloc<u8>(buf, cap);
        }
        ret ok<string, string>("");
    }

    if (buf == nil) {
        ret err<string, string>("memory allocation failed during formatting");
    }

    if (cap > len) {
        val shrunk: *u8 = mem.realloc<u8>(buf, cap, len);
        if (shrunk == nil) {
            mem.dealloc<u8>(buf, cap);
            ret err<string, string>("memory allocation failed during formatting");
        }
        buf = shrunk;
        cap = len;
    }

    var result_str: string;
    result_str.data = buf;
    result_str.len  = len;

    ret ok<string, string>(result_str);
}

pub fun string.format(pattern: string, ...) Result<string, string> {
    if (pattern.len == 0 || pattern.data == nil) {
        ret err<string, string>("invalid pattern string");
    }

    var buf: *u8;
    var len: u64;
    var cap: u64;

    var arg_index: u64 = 0;
    var arg_total: u64 = va_count();

    var i:  u64  = 0;
    var ok: bool = true;
    for (i < pattern.len) {
        if (ok == false) { brk; }

        val ch: u8 = @(pattern.data + i);

        if (ch == '\\') {
            if((i + 1) < pattern.len) {
                val next: u8 = @(pattern.data + i + 1);

                ok = append_escape(?buf, ?len, ?cap, next);
                i  = i + 2;
            }
            or {
                ok = append_byte(?buf, ?len, ?cap, ch);
                i  = i + 1;
            }
        }
        or (ch == '%') {
            if ((i + 1) >= pattern.len) {
                ok = append_byte(?buf, ?len, ?cap, ch);
                i  = i + 1;
            }
            or {
                val spec: u8 = @(pattern.data + i + 1);

                if (spec == '%') {
                    # literal '%'
                    ok = append_byte(?buf, ?len, ?cap, '%');
                    i  = i + 2;
                }
                or (arg_index >= arg_total) {
                    # not enough arguments
                    ok = append_byte(?buf, ?len, ?cap, '%');
                    if (ok == false) { ok = append_byte(?buf, ?len, ?cap, spec); }
                    i = i + 2;
                }
                or {
                    if (spec == 's') {
                        val arg_str: *string = va_arg(arg_index)::*string;
                        ok = append_string(?buf, ?len, ?cap, @arg_str);
                        arg_index = arg_index + 1;
                    }
                    or (spec == 'd') {
                        val arg_int: *i64 = va_arg(arg_index)::*i64;
                        ok = append_signed(?buf, ?len, ?cap, @arg_int);
                        arg_index = arg_index + 1;
                    }
                    or (spec == 'u') {
                        val arg_uint: *u64 = va_arg(arg_index)::*u64;
                        ok = append_unsigned(?buf, ?len, ?cap, @arg_uint);
                        arg_index = arg_index + 1;
                    }
                    or (spec == 'x') {
                        val arg_hex: *u64 = va_arg(arg_index)::*u64;
                        ok = append_hex(?buf, ?len, ?cap, @arg_hex, false);
                        arg_index = arg_index + 1;
                    }
                    or (spec == 'X') {
                        val arg_hex: *u64 = va_arg(arg_index)::*u64;
                        ok = append_hex(?buf, ?len, ?cap, @arg_hex, true);
                        arg_index = arg_index + 1;
                    }
                    or (spec == 'f') {
                        val arg_float: *f64 = va_arg(arg_index)::*f64;
                        ok = append_float(?buf, ?len, ?cap, @arg_float, 6);
                        arg_index = arg_index + 1;
                    }
                    or (spec == 'b') {
                        val arg_bool: *bool = va_arg(arg_index)::*bool;
                        ok = append_bool(?buf, ?len, ?cap, @arg_bool);
                        arg_index = arg_index + 1;
                    }
                    or (spec == 'p') {
                        val arg_ptr: *ptr = va_arg(arg_index)::*ptr;
                        ok = append_pointer(?buf, ?len, ?cap, @arg_ptr);
                        arg_index = arg_index + 1;
                    }
                    or {
                        # unknown specifier, treat as literal
                        ok = append_byte(?buf, ?len, ?cap, '%');
                        if (ok == false) { ok = append_byte(?buf, ?len, ?cap, spec); }
                        i = i + 2;
                    }
                }
            }
        }
        or {
            ok = append_byte(?buf, ?len, ?cap, ch);
            i  = i + 1;
        }

        if (ok == false) { brk; }
    }

    if (ok == false) {
        if (buf != nil) {
            mem.dealloc<u8>(buf, cap);
        }
        ret err<string, string>("memory allocation failed during formatting");
    }

    ret finalize_buffer(buf, cap, len);
}
