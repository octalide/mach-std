use      std.types.bool;
use      std.types.result;
use      std.types.option;
use mem: std.system.memory;

pub str List<T> {
    data: *T;
    len:  u64;
    cap:  u64;
}

pub fun list_new<T>(cap: u64) Result<List<T>, string> {
    if (cap == 0) {
        ret err<List<T>, string>("capacity must be greater than zero");
    }
    
    val data: *T = mem.alloc<T>(cap);
    if (data == nil) {
        ret err<List<T>, string>("failed to allocate memory for list");
    }

    var list: List<T>;
    list.data = data;
    list.len = 0;
    list.cap = cap;
    ret ok<List<T>, string>(list);
}

pub fun list_from_slice<T>(slice: []T) Result<List<T>, string> {
    if (slice.len == 0 || slice.data == nil) {
        ret err<List<T>, string>("slice is empty");
    }
    
    val data: *T = mem.alloc<T>(slice.len);
    if (data == nil) {
        ret err<List<T>, string>("failed to allocate memory for list");
    }
    
    mem.raw_copy((data :: ptr), (slice.data :: ptr), slice.len * size_of(T));
    var list: List<T> = List{ data: data, len: slice.len, cap: slice.len };
    ret ok<List<T>, string>(list);
}

pub fun List<T>.as_slice(this: List<T>) []T {
    ret []T{ this.data, this.len };
}

pub fun List<T>.is_empty(this: List<T>) bool {
    ret this.len == 0;
}

pub fun List<T>.reserve(this: *List<T>, additional: u64) Option<string> {
    val required: u64 = this.len + additional;
    if (required <= this.cap) {
        ret none<string>();
    }
    
    if (required < this.len) {
        ret none<string>();
    }
    
    var new_cap: u64 = this.cap;
    if (new_cap == 0) { new_cap = 8; }
    
    for (new_cap < required) {
        if (new_cap >= (0xffff_ffff_ffff_ffff / 2)) {
            new_cap = required;
            brk;
        }
        new_cap = new_cap * 2;
    }
    
    val new_data: *T = mem.realloc<T>(this.data, this.cap, new_cap);
    if (new_data == nil) {
        ret some<string>("failed to reserve additional capacity");
    }
    
    this.data = new_data;
    this.cap = new_cap;

    ret none<string>();
}

pub fun List<T>.ensure_capacity(this: *List<T>, min_capacity: u64) Option<string> {
    if (min_capacity <= this.cap) {
        ret none<string>();
    }
    
    ret this.reserve(min_capacity - this.cap);
}

pub fun List<T>.shrink_to_fit(this: *List<T>) Option<string> {
    if (this.cap == this.len) {
        ret none<string>();
    }
    
    if (this.len == 0) {
        if (this.data != nil && this.cap > 0) {
            mem.dealloc<T>(this.data, this.cap);
        }
        this.data = nil;
        this.len = 0;
        this.cap = 0;
        ret none<string>();
    }
    
    val new_data: *T = mem.realloc<T>(this.data, this.cap, this.len);
    if (new_data == nil) {
        ret some<string>("failed to shrink to fit");
    }
    
    this.data = new_data;
    this.cap = this.len;

    ret none<string>();
}

pub fun List<T>.push(this: *List<T>, item: T) Option<string> {
    if (this.len >= this.cap) {
        val res: Option<string> = this.reserve(1);
        if (res.is_some()) {
            ret res;
        }
    }
    
    @(this.data + this.len) = item;
    this.len = this.len + 1;

    ret none<string>();
}

pub fun List<T>.pop(this: *List<T>) Option<T> {
    if (this.len == 0) {
        ret none<T>();
    }
    
    this.len = this.len - 1;

    ret some<T>(@(this.data + this.len));
}

pub fun List<T>.append(this: *List<T>, slice: []T) Option<string> {
    if (slice.len == 0 || slice.data == nil) {
        ret none<string>();
    }

    val res: Option<string> = this.reserve(slice.len);
    if (res.is_some()) {
        ret res;
    }

    if (this.len + slice.len < this.len) {
        ret some<string>("length overflow");
    }
    
    if (this.len + slice.len > this.cap) {
        ret some<string>("capacity overflow");
    }
    
    val dst: ptr = ((this.data + this.len) :: ptr);
    val src: ptr = (slice.data :: ptr);
    mem.raw_copy(dst, src, slice.len * size_of(T));
    
    this.len = this.len + slice.len;

    ret none<string>();
}

pub fun List<T>.clear(this: *List<T>) {
    this.len = 0;
}

pub fun List<T>.free(this: *List<T>) {
    if (this.data != nil && this.cap > 0) {
        mem.dealloc<T>(this.data, this.cap);
    }
    this.data = nil;
    this.len = 0;
    this.cap = 0;
}

pub fun List<T>.get(this: List<T>, index: u64) Option<T> {
    if (index >= this.len) {
        ret none<T>();
    }

    ret some<T>(@(this.data + index));
}

pub fun List<T>.set(this: *List<T>, index: u64, item: T) Option<string> {
    if (index >= this.len) {
        ret some<string>("index out of bounds");
    }
    
    @(this.data + index) = item;

    ret none<string>();
}
