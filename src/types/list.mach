use      std.types.bool;
use      std.types.result;
use      std.types.option;
use      std.types.size;
use      std.types.string;
use mem: std.system.memory;

pub rec List[T] {
    data: *T;
    len:  usize;
    cap:  usize;
}

pub fun list_new[T](cap: usize) Result[List[T], str] {
    var list: List[T];
    val init_err: Option[str] = list.init(cap);
    if (init_err.is_some()) {
        ret err[List[T], str](init_err.unwrap());
    }

    ret ok[List[T], str](list);
}

pub fun list_from_slice[T](slice: []T) Result[List[T], str] {
    if (slice.len == 0 || slice.data == nil) {
        ret err[List[T], str]("slice is empty");
    }

    val alloc_res: Option[*T] = mem.allocate[T](slice.len);
    if (alloc_res.is_none()) {
        ret err[List[T], str]("allocation failed");
    }

    val data: *T = alloc_res.unwrap();

    mem.copy[T](data, slice.data, slice.len);
    var list: List[T] = List{ data: data, len: slice.len, cap: slice.len };
    ret ok[List[T], str](list);
}

pub fun (this: *List[T]) init(cap: usize) Option[str] {
    this.data = nil;
    this.len  = 0;
    this.cap  = 0;

    if (cap == 0) {
        ret some[str]("capacity must be greater than zero");
    }

    val alloc_res: Option[*T] = mem.allocate[T](cap);
    if (alloc_res.is_none()) {
        ret some[str]("allocation failed");
    }

    val data: *T = alloc_res.unwrap();

    this.data = data;
    this.cap  = cap;
    ret none[str]();
}

pub fun (this: *List[T]) dnit() {
    if (this.data != nil && this.cap > 0) {
        mem.deallocate[T](this.data, this.cap);
    }
    this.data = nil;
    this.len  = 0;
    this.cap  = 0;
}

pub fun (this: List[T]) as_slice() []T {
    ret []T{ this.data, this.len };
}

pub fun (this: List[T]) is_empty() bool {
    ret this.len == 0;
}

pub fun (this: *List[T]) reserve(additional: usize) Option[str] {
    val required: usize = this.len + additional;
    if (required <= this.cap) {
        ret none[str]();
    }

    if (required < this.len) {
        ret none[str]();
    }

    var new_cap: usize = this.cap;
    if (new_cap == 0) { new_cap = 8; }

    for (new_cap < required) {
        if (new_cap >= (0xffff_ffff_ffff_ffff / 2)) {
            new_cap = required;
            brk;
        }
        new_cap = new_cap * 2;
    }

    val realloc_res: Option[*T] = mem.reallocate[T](this.data, this.cap, new_cap);
    if (realloc_res.is_none()) {
        ret some[str]("reallocation failed");
    }

    val new_data: *T = realloc_res.unwrap();

    this.data = new_data;
    this.cap = new_cap;

    ret none[str]();
}

pub fun (this: *List[T]) ensure_capacity(min_capacity: usize) Option[str] {
    if (min_capacity <= this.cap) {
        ret none[str]();
    }

    ret this.reserve(min_capacity - this.cap);
}

pub fun (this: *List[T]) shrink_to_fit() Option[str] {
    if (this.cap == this.len) {
        ret none[str]();
    }

    if (this.len == 0) {
        if (this.data != nil && this.cap > 0) {
            mem.deallocate[T](this.data, this.cap);
        }
        this.data = nil;
        this.len = 0;
        this.cap = 0;
        ret none[str]();
    }

    val realloc_res: Option[*T] = mem.reallocate[T](this.data, this.cap, this.len);
    if (realloc_res.is_none()) {
        ret some[str]("reallocation failed");
    }

    val new_data: *T = realloc_res.unwrap();

    this.data = new_data;
    this.cap = this.len;

    ret none[str]();
}

pub fun (this: *List[T]) push(item: T) Option[str] {
    if (this.len >= this.cap) {
        val res: Option[str] = this.reserve(1);
        if (res.is_some()) {
            ret res;
        }
    }

    @(this.data + this.len) = item;
    this.len = this.len + 1;

    ret none[str]();
}

pub fun (this: *List[T]) pop() Option[T] {
    if (this.len == 0) {
        ret none[T]();
    }

    this.len = this.len - 1;

    ret some[T](@(this.data + this.len));
}

pub fun (this: *List[T]) append(slice: []T) Option[str] {
    if (slice.len == 0 || slice.data == nil) {
        ret none[str]();
    }

    val res: Option[str] = this.reserve(slice.len);
    if (res.is_some()) {
        ret res;
    }

    if (this.len + slice.len < this.len) {
        ret some[str]("length overflow");
    }

    if (this.len + slice.len > this.cap) {
        ret some[str]("capacity overflow");
    }

    mem.copy[T](this.data + this.len, slice.data, slice.len);

    this.len = this.len + slice.len;

    ret none[str]();
}

pub fun (this: *List[T]) clear() {
    this.len = 0;
}

pub fun (this: List[T]) get(index: usize) Option[T] {
    if (this.data == nil || index >= this.len) {
        ret none[T]();
    }

    ret some[T](@(this.data + index));
}

pub fun (this: *List[T]) set(index: usize, item: T) Option[str] {
    if (index >= this.len) {
        ret some[str]("index out of bounds");
    }

    @(this.data + index) = item;

    ret none[str]();
}
