use      std.types.bool;
use      std.types.list;
use      std.types.option;
use      std.types.result;
use      std.types.size;
use      std.types.string;
use      std.text.ascii;
use mem: std.system.memory;

# json value types
pub val JSON_NULL:   u32 = 0;
pub val JSON_BOOL:   u32 = 1;
pub val JSON_NUMBER: u32 = 2;
pub val JSON_STRING: u32 = 3;
pub val JSON_ARRAY:  u32 = 4;
pub val JSON_OBJECT: u32 = 5;

pub rec JsonValue {
    tag:  u32;
    data: uni {
        bool_val:   bool;
        number_val: f64;
        string_val: str;
        array_val:  List[JsonValue];
        object_val: List[JsonProperty];
    };
}

pub rec JsonProperty {
    key:   str;
    value: JsonValue;
}

rec JsonParser {
    input: String;
    pos:   usize;
}

# constructors
pub fun json_null() JsonValue {
    var v: JsonValue;
    v.tag = JSON_NULL;
    ret v;
}

pub fun json_bool(value: bool) JsonValue {
    var v: JsonValue;
    v.tag           = JSON_BOOL;
    v.data.bool_val = value;
    ret v;
}

pub fun json_number(value: f64) JsonValue {
    var v: JsonValue;
    v.tag             = JSON_NUMBER;
    v.data.number_val = value;
    ret v;
}

pub fun json_string(value: str) JsonValue {
    var v: JsonValue;
    v.tag             = JSON_STRING;
    v.data.string_val = value;
    ret v;
}

pub fun json_array(value: List[JsonValue]) JsonValue {
    var v: JsonValue;
    v.tag            = JSON_ARRAY;
    v.data.array_val = value;
    ret v;
}

pub fun json_object(value: List[JsonProperty]) JsonValue {
    var v: JsonValue;
    v.tag             = JSON_OBJECT;
    v.data.object_val = value;
    ret v;
}

pub fun (this: *JsonValue) init() {
    mem.zero[JsonValue](this, 1);

    this.tag = JSON_NULL;
}

pub fun (this: *JsonValue) dnit() {
    if (this.tag == JSON_ARRAY) {
        var i: usize = 0;
        for (i < this.data.array_val.len) {
            val item: *JsonValue = this.data.array_val.data + i;
            item.dnit();
            i = i + 1;
        }

        this.data.array_val.dnit();
    }
    or (this.tag == JSON_OBJECT) {
        var i: usize = 0;
        for (i < this.data.object_val.len) {
            val item: *JsonProperty = this.data.object_val.data + i;
            item.value.dnit();
            i = i + 1;
        }
        this.data.object_val.dnit();
    }

    mem.zero[JsonValue](this, 1);

    this.tag = JSON_NULL;
}

# type checks
pub fun (this: JsonValue) is_null() bool {
    ret this.tag == JSON_NULL;
}

pub fun (this: JsonValue) is_bool() bool {
    ret this.tag == JSON_BOOL;
}

pub fun (this: JsonValue) is_number() bool {
    ret this.tag == JSON_NUMBER;
}

pub fun (this: JsonValue) is_string() bool {
    ret this.tag == JSON_STRING;
}

pub fun (this: JsonValue) is_array() bool {
    ret this.tag == JSON_ARRAY;
}

pub fun (this: JsonValue) is_object() bool {
    ret this.tag == JSON_OBJECT;
}

# value getters
pub fun (this: JsonValue) as_bool() Option[bool] {
    if (this.tag == JSON_BOOL) {
        ret some[bool](this.data.bool_val);
    }
    ret none[bool]();
}

pub fun (this: JsonValue) as_number() Option[f64] {
    if (this.tag == JSON_NUMBER) {
        ret some[f64](this.data.number_val);
    }
    ret none[f64]();
}

pub fun (this: JsonValue) as_string() Option[string] {
    if (this.tag == JSON_STRING) {
        ret some[string](this.data.string_val);
    }
    ret none[string]();
}

pub fun (this: JsonValue) as_array() Option[*List[JsonValue]] {
    if (this.tag == JSON_ARRAY) {
        ret some[*List[JsonValue]](?this.data.array_val);
    }
    ret none[*List[JsonValue]]();
}

pub fun (this: JsonValue) as_object() Option[*List[JsonProperty]] {
    if (this.tag == JSON_OBJECT) {
        ret some[*List[JsonProperty]](?this.data.object_val);
    }
    ret none[*List[JsonProperty]]();
}

# parser helpers
fun (this: *JsonParser) current() char {
    if (this.pos >= this.input.len) {
        ret 0;
    }
    ret @(this.input.data + this.pos);
}

fun (this: *JsonParser) peek(offset: usize) char {
    val idx: usize = this.pos + offset;
    if (idx >= this.input.len) {
        ret 0;
    }
    ret @(this.input.data + idx);
}

fun (this: *JsonParser) advance() {
    if (this.pos < this.input.len) {
        this.pos = this.pos + 1;
    }
}

fun (this: *JsonParser) skip_whitespace() {
    for (this.pos < this.input.len) {
        val ch: char = this.current();
        if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r') {
            this.advance();
        } or {
            brk;
        }
    }
}

fun (this: *JsonParser) match_keyword(keyword: str) bool {
    var i: usize = 0;
    for (i < keyword.len) {
        if (this.peek(i) != @(keyword.data + i)) {
            ret false;
        }
        i = i + 1;
    }

    this.pos = this.pos + keyword.len;

    ret true;
}

fun (this: *JsonParser) parse_string_content() Result[str, str] {
    val start: usize = this.pos;
    var len:   usize = 0;

    for (this.pos < this.input.len) {
        val ch: char = this.current();

        if (ch == '"') {
            brk;
        }
        or (ch == '\\') {
            this.advance();
            if (this.pos >= this.input.len) {
                ret err[str, str]("unexpected end in escape sequence");
            }
            this.advance();
            len = len + 1;
        }
        or (ch < 32) {
            ret err[str, str]("invalid control character in string");
        }
        or {
            this.advance();
            len = len + 1;
        }
    }

    var buffer: *char = nil;
    if (len > 0) {
        val alloc_res: Option[*char] = mem.allocate[char](len);
        if (alloc_res.is_none()) {
            ret err[str, str]("allocation failed");
        }

        buffer = alloc_res.unwrap();
    }

    # copy and process escapes
    var write_pos: usize = 0;
    var read_pos:  usize = start;

    for (read_pos < this.pos) {
        val ch: char = @(this.input.data + read_pos);

        if (ch == '\\') {
            read_pos = read_pos + 1;
            if (read_pos >= this.pos) {
                brk;
            }

            val esc: char = @(this.input.data + read_pos);
            if (esc == 'n') {
                @(buffer + write_pos) = 10;
            }
            or (esc == 't') {
                @(buffer + write_pos) = 9;
            }
            or (esc == 'r') {
                @(buffer + write_pos) = 13;
            }
            or (esc == '\\') {
                @(buffer + write_pos) = '\\';
            }
            or (esc == '"') {
                @(buffer + write_pos) = '"';
            }
            or (esc == '/') {
                @(buffer + write_pos) = '/';
            }
            or (esc == 'b') {
                @(buffer + write_pos) = 8;
            }
            or (esc == 'f') {
                @(buffer + write_pos) = 12;
            }
            or {
                @(buffer + write_pos) = esc;
            }

            write_pos = write_pos + 1;
            read_pos  = read_pos + 1;
        }
        or {
            @(buffer + write_pos) = ch;
            write_pos = write_pos + 1;
            read_pos  = read_pos + 1;
        }
    }

    var result: str;
    result.data = buffer;
    result.len  = len;
    ret ok[str, str](result);
}

fun (this: *JsonParser) parse_string() Result[JsonValue, str] {
    if (this.current() != '"') {
        ret err[JsonValue, str]("expected '\"'");
    }

    this.advance();

    val str_result: Result[str, str] = this.parse_string_content();
    if (str_result.is_err()) {
        ret err[JsonValue, str](str_result.unwrap_err());
    }

    if (this.current() != '"') {
        str_result.unwrap_ok().dnit();
        ret err[JsonValue, str]("unterminated string");
    }

    this.advance();

    ret ok[JsonValue, str](json_string(str_result.unwrap_ok()));
}

fun (this: *JsonParser) parse_number() Result[JsonValue, str] {
    val start:       usize = this.pos;
    var is_negative: bool = false;

    # optional minus
    if (this.current() == '-') {
        is_negative = true;
        this.advance();
    }

    if (is_digit(this.current()) == 0) {
        ret err[JsonValue, str]("expected digit");
    }

    # integer part
    for (this.pos < this.input.len && is_digit(this.current())) {
        this.advance();
    }

    var is_float: bool = false;

    # optional fractional part
    if (this.current() == '.') {
        is_float = true;
        this.advance();

        if (is_digit(this.current()) == 0) {
            ret err[JsonValue, str]("expected digit after decimal point");
        }

        for (this.pos < this.input.len && is_digit(this.current())) {
            this.advance();
        }
    }

    # optional exponent
    val ch: char = this.current();
    if (ch == 'e' || ch == 'E') {
        is_float = true;
        this.advance();

        val exp_ch: char = this.current();
        if (exp_ch == '+' || exp_ch == '-') {
            this.advance();
        }

        if (is_digit(this.current()) == 0) {
            ret err[JsonValue, str]("expected digit in exponent");
        }

        for (this.pos < this.input.len && is_digit(this.current())) {
            this.advance();
        }
    }

    # simple integer parsing
    var value: f64 = 0.0;
    var i:     usize = start;

    if (is_negative) {
        i = i + 1;
    }

    # parse integer part
    for (i < this.pos) {
        val digit_ch: char = @(this.input.data + i);
        if (digit_ch == '.' || digit_ch == 'e' || digit_ch == 'E') {
            brk;
        }

        val d: i32 = digit_val(digit_ch);
        if (d < 0 || d > 9) {
            brk;
        }

        value = value * 10.0 + (d::f64);
        i = i + 1;
    }

    # parse fractional part if present
    if (i < this.pos && @(this.input.data + i) == '.') {
        i = i + 1;
        var divisor: f64 = 10.0;
        for (i < this.pos) {
            val digit_ch: char = @(this.input.data + i);
            if (digit_ch == 'e' || digit_ch == 'E') {
                brk;
            }
            val d: i32 = digit_val(digit_ch);
            if (d < 0 || d > 9) {
                brk;
            }
            value = value + ((d::f64) / divisor);
            divisor = divisor * 10.0;
            i = i + 1;
        }
    }

    if (is_negative) {
        value = 0.0 - value;
    }

    ret ok[JsonValue, str](json_number(value));
}

fun (this: *JsonParser) parse_array() Result[JsonValue, str] {
    if (this.current() != '[') {
        ret err[JsonValue, str]("expected '['");
    }

    this.advance();
    this.skip_whitespace();

    val ptr_alloc_res: Option[*List[JsonValue]] = mem.allocate[List[JsonValue]](1);
    if (ptr_alloc_res.is_none()) {
        ret err[JsonValue, str]("failed to allocate array list");
    }

    val list: List[JsonValue];
    val res_init: Option[str] = list.init(4);
    if (res_init.is_some()) {
        ret err[JsonValue, str](res_init.unwrap());
    }

    # empty array
    if (this.current() == ']') {
        this.advance();
        ret ok[JsonValue, str](json_array(list));
    }

    for {
        val elem_result: Result[JsonValue, str] = this.parse_value();
        if (elem_result.is_err()) {
            list.dnit();
            ret err[JsonValue, str](elem_result.unwrap_err());
        }

        val push_ok: bool = list.push(elem_result.unwrap_ok());
        if (push_ok == false) {
            list.dnit();
            ret err[JsonValue, str]("failed to push array element");
        }

        this.skip_whitespace();

        if (this.current() == ']') {
            this.advance();
            brk;
        }
        or (this.current() == ',') {
            this.advance();
            this.skip_whitespace();
        }
        or {
            list.dnit();
            ret err[JsonValue, str]("expected ',' or ']' in array");
        }
    }

    ret ok[JsonValue, str](json_array(list));
}

fun (this: *JsonParser) parse_object() Result[JsonValue, str] {
    if (this.current() != '{') {
        ret err[JsonValue, str]("expected '{'");
    }

    this.advance();
    this.skip_whitespace();

    val list: List[JsonProperty];
    val res_init: Option[str] = list.init(4);
    if (res_init.is_some()) {
        ret err[JsonValue, str](res_init.unwrap());
    }

    # empty object case
    if (this.current() == '}') {
        this.advance();
        ret ok[JsonValue, str](json_object(list));
    }

    # parse properties
    for {
        # expect opening quote for key
        if (this.current() != '"') {
            list.dnit();
            ret err[JsonValue, str]("expected string key");
        }

        this.advance();

        # parse key string content
        val key_result: Result[string, string] = this.parse_string_content();
        if (key_result.is_err()) {
            list.dnit();
            ret err[JsonValue, string](key_result.unwrap_err());
        }

        var key: string = key_result.unwrap_ok();

        # expect closing quote for key
        if (this.current() != '"') {
            key.dnit();
            list.dnit();
            ret err[JsonValue, string]("unterminated key string");
        }

        this.advance();
        this.skip_whitespace();

        # expect colon
        if (this.current() != ':') {
            key.dnit();
            list.dnit();
            ret err[JsonValue, string]("expected ':' after key");
        }

        this.advance();
        this.skip_whitespace();

        # parse value
        val val_result: Result[JsonValue, string] = this.parse_value();
        if (val_result.is_err()) {
            key.dnit();
            list.dnit();
            ret err[JsonValue, string](val_result.unwrap_err());
        }

        var value: JsonValue = val_result.unwrap_ok();

        # create property and transfer ownership
        var prop: JsonProperty;
        prop.key   = key;
        prop.value = value;

        # push property to list
        val push_ok: bool = list.push(prop);
        if (push_ok == false) {
            prop.key.dnit();
            prop.value.dnit();
            list.dnit();
            ret err[JsonValue, string]("failed to push property");
        }

        # property ownership transferred to list
        this.skip_whitespace();

        # check for end or continuation
        if (this.current() == '}') {
            this.advance();
            brk;
        }
        or (this.current() == ',') {
            this.advance();
            this.skip_whitespace();
        }
        or {
            list.dnit();
            ret err[JsonValue, string]("expected ',' or '}' in object");
        }
    }

    ret ok[JsonValue, string](json_object(list));
}

fun (this: *JsonParser) parse_value() Result[JsonValue, str] {
    this.skip_whitespace();

    val ch: char = this.current();

    if (ch == 'n') {
        if (this.match_keyword("null")) {
            ret ok[JsonValue, str](json_null());
        }
        ret err[JsonValue, str]("invalid keyword");
    }
    or (ch == 't') {
        if (this.match_keyword("true")) {
            ret ok[JsonValue, str](json_bool(true));
        }
        ret err[JsonValue, str]("invalid keyword");
    }
    or (ch == 'f') {
        if (this.match_keyword("false")) {
            ret ok[JsonValue, str](json_bool(false));
        }
        ret err[JsonValue, str]("invalid keyword");
    }
    or (ch == '"') {
        ret this.parse_string();
    }
    or (ch == '[') {
        ret this.parse_array();
    }
    or (ch == '{') {
        ret this.parse_object();
    }
    or (ch == '-' || is_digit(ch)) {
        ret this.parse_number();
    }
    or {
        ret err[JsonValue, str]("unexpected character");
    }
}

# main parse function
pub fun parse_json(input: str) Result[JsonValue, str] {
    if (input.data == nil) {
        ret err[JsonValue, str]("input is null");
    }

    val cloned: Option[String] = input.clone();
    if (cloned.is_none()) {
        ret err[JsonValue, str]("failed to clone input string");
    }

    var parser: JsonParser;
    parser.input = cloned.unwrap_ok();
    parser.pos   = 0;

    val result: Result[JsonValue, str] = parser.parse_value();

    if (result.is_err()) {
        ret result;
    }

    parser.skip_whitespace();

    if (parser.pos < input.len) {
        result.unwrap_ok().dnit();
        ret err[JsonValue, str]("unexpected data after json value");
    }

    ret result;
}

# object lookup helper
pub fun (this: JsonValue) get_property(key: str) Option[JsonValue] {
    if (this.tag != JSON_OBJECT || this.data.object_val == nil) {
        ret none[JsonValue]();
    }

    var i: usize = 0;
    for (i < this.data.object_val.len) {
        val prop: *JsonProperty = this.data.object_val.data + i;
        if (prop.key.equals(key)) {
            ret some[JsonValue](prop.value);
        }
        i = i + 1;
    }

    ret none[JsonValue]();
}

# array index helper
pub fun (this: JsonValue) get_index(index: usize) Option[JsonValue] {
    if (this.tag != JSON_ARRAY || this.data.array_val == nil) {
        ret none[JsonValue]();
    }

    if (index >= this.data.array_val.len) {
        ret none[JsonValue]();
    }

    ret some[JsonValue](@(this.data.array_val.data + index));
}
