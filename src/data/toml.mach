use        std.types.bool;
use        std.types.list;
use        std.types.option;
use        std.types.result;
use        std.types.size;
use        std.types.string;
use ascii: std.text.ascii;
use mem:   std.system.memory;

# toml value types
pub val TOML_INVALID: u32 = $max(u32);
pub val TOML_STRING:  u32 = 0;
pub val TOML_INTEGER: u32 = 1;
pub val TOML_FLOAT:   u32 = 2;
pub val TOML_BOOL:    u32 = 3;
pub val TOML_ARRAY:   u32 = 4;
pub val TOML_TABLE:   u32 = 5;

pub rec TomlValue {
    tag:  u32;
    data: uni {
        bool_val:    bool;
        integer_val: i64;
        float_val:   f64;
        string_val:  str;
        array_val:   List[TomlValue];
        table_val:   List[TomlProperty];
    };
}

pub rec TomlProperty {
    key:   str;
    value: TomlValue;
}

rec TomlParser {
    input: String;
    pos:   usize;
    line:  usize;
}

pub fun toml_string(value: str) TomlValue {
    var v: TomlValue;
    v.tag             = TOML_STRING;
    v.data.string_val = value;
    ret v;
}

pub fun toml_integer(value: i64) TomlValue {
    var v: TomlValue;
    v.tag              = TOML_INTEGER;
    v.data.integer_val = value;
    ret v;
}

pub fun toml_float(value: f64) TomlValue {
    var v: TomlValue;
    v.tag            = TOML_FLOAT;
    v.data.float_val = value;
    ret v;
}

pub fun toml_bool(value: bool) TomlValue {
    var v: TomlValue;
    v.tag           = TOML_BOOL;
    v.data.bool_val = value;
    ret v;
}

pub fun toml_array(value: List[TomlValue]) TomlValue {
    var v: TomlValue;
    v.tag            = TOML_ARRAY;
    v.data.array_val = value;
    ret v;
}

pub fun toml_table(value: List[TomlProperty]) TomlValue {
    var v: TomlValue;
    v.tag            = TOML_TABLE;
    v.data.table_val = value;
    ret v;
}

pub fun (this: *TomlValue) init() {
    mem.zero[TomlValue](this, 1);
    this.tag = TOML_INVALID;
}

pub fun (this: *TomlValue) dnit() {
    if (this.is_array()) {
        var i: usize = 0;
        for (i < this.data.array_val.len) {
            val elem: *TomlValue = this.data.array_val.data + i;
            elem.dnit();
            i = i + 1;
        }
    }
    or (this.is_table()) {
        var i: usize = 0;
        for (i < this.data.table_val.len) {
            val prop: *TomlProperty = this.data.table_val.data + i;
            prop.value.dnit();
            i = i + 1;
        }
    }

    mem.zero[TomlValue](this, 1);
    this.tag = TOML_INVALID;
}

# type checks
pub fun (this: TomlValue) is_string() bool {
    ret this.tag == TOML_STRING;
}

pub fun (this: TomlValue) is_integer() bool {
    ret this.tag == TOML_INTEGER;
}

pub fun (this: TomlValue) is_float() bool {
    ret this.tag == TOML_FLOAT;
}

pub fun (this: TomlValue) is_bool() bool {
    ret this.tag == TOML_BOOL;
}

pub fun (this: TomlValue) is_array() bool {
    ret this.tag == TOML_ARRAY;
}

pub fun (this: TomlValue) is_table() bool {
    ret this.tag == TOML_TABLE;
}

# value getters
pub fun (this: TomlValue) as_string() Option[str] {
    if (this.is_string()) {
        ret some[str](this.data.string_val);
    }
    ret none[str]();
}

pub fun (this: TomlValue) as_integer() Option[i64] {
    if (this.is_integer()) {
        ret some[i64](this.data.integer_val);
    }
    ret none[i64]();
}

pub fun (this: TomlValue) as_float() Option[f64] {
    if (this.is_float()) {
        ret some[f64](this.data.float_val);
    }
    ret none[f64]();
}

pub fun (this: TomlValue) as_bool() Option[bool] {
    if (this.is_bool()) {
        ret some[bool](this.data.bool_val);
    }
    ret none[bool]();
}

pub fun (this: *TomlValue) as_array() Option[*List[TomlValue]] {
    if (this == nil) {
        ret none[*List[TomlValue]]();
    }

    if (this.is_array()) {
        ret some[*List[TomlValue]](?this.data.array_val);
    }

    ret none[*List[TomlValue]]();
}

pub fun (this: *TomlValue) as_table() Option[*List[TomlProperty]] {
    if (this == nil) {
        ret none[*List[TomlProperty]]();
    }

    if (this.is_table()) {
        ret some[*List[TomlProperty]](?this.data.table_val);
    }

    ret none[*List[TomlProperty]]();
}

pub fun (this: *TomlParser) init() {
    mem.zero[TomlParser](this, 1);
}

pub fun (this: *TomlParser) dnit() {
    mem.zero[TomlParser](this, 1);
}

fun (this: *TomlParser) current() char {
    if (this.pos >= this.input.len) {
        ret 0;
    }
    ret @(this.input.data + this.pos);
}

fun (this: *TomlParser) peek(offset: usize) char {
    val idx: usize = this.pos + offset;
    if (idx >= this.input.len) {
        ret 0;
    }
    ret @(this.input.data + idx);
}

fun (this: *TomlParser) advance() {
    val ch: char = this.current();
    if (this.pos < this.input.len) {
        this.pos = this.pos + 1;
    }
    if (ch == '\n') {
        this.line = this.line + 1;
    }
}

fun (this: *TomlParser) skip_whitespace() {
    for (this.pos < this.input.len) {
        val ch: char = this.current();
        if (ch == ' ' || ch == '\t') {
            this.advance();
        } or {
            brk;
        }
    }
}

fun (this: *TomlParser) skip_whitespace_and_newlines() {
    for (this.pos < this.input.len) {
        val ch: char = this.current();
        if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r') {
            this.advance();
        } or {
            brk;
        }
    }
}

fun (this: *TomlParser) skip_comment() {
    if (this.current() == '#') {
        for (this.pos < this.input.len) {
            val ch: char = this.current();
            this.advance();
            if (ch == '\n') {
                brk;
            }
        }
    }
}

fun (this: *TomlParser) match_keyword(keyword: str) bool {
    var i: usize = 0;
    for (i < keyword.len) {
        if (this.peek(i) != @(keyword.data + i)) {
            ret false;
        }
        i = i + 1;
    }

    # check next char is not alphanumeric
    val next_ch: char = this.peek(keyword.len);
    if (ascii.is_alnum(next_ch) || next_ch == '_') {
        ret false;
    }

    this.pos = this.pos + keyword.len;

    ret true;
}

fun is_bare_key_char(ch: char) bool {
    ret ascii.is_alnum(ch) || ch == '_' || ch == '-';
}

fun (this: *TomlParser) parse_bare_key() Result[str, str] {
    val start: usize = this.pos;
    
    for (this.pos < this.input.len) {
        val ch: char = this.current();
        if (is_bare_key_char(ch)) {
            this.advance();
        } or {
            brk;
        }
    }
    
    val len: usize = this.pos - start;
    if (len == 0) {
        ret err[str, str]("expected key");
    }

    # return borrowed slice from input
    ret ok[str, str](str{ this.input.data + start, len });
}

fun (this: *TomlParser) parse_basic_string() Result[str, str] {
    if (this.current() != '"') {
        ret err[str, str]("expected '\"'");
    }
    this.advance();
    
    val start:       usize = this.pos;
    var len:         usize = 0;
    var has_escapes: bool = false;
    
    for (this.pos < this.input.len) {
        val ch: char = this.current();
        
        if (ch == '"') {
            brk;
        }
        or (ch == '\\') {
            has_escapes = true;
            this.advance();
            if (this.pos >= this.input.len) {
                ret err[str, str]("unexpected end in escape");
            }
            this.advance();
            len = len + 1;
        }
        or (ch == '\n') {
            ret err[str, str]("unexpected newline in string");
        }
        or {
            this.advance();
            len = len + 1;
        }
    }
    
    if (this.current() != '"') {
        ret err[str, str]("unterminated string");
    }
    this.advance();
    
    var buffer: *char = nil;
    if (len > 0) {
        val alloc_res: Option[*char] = mem.allocate[char](len);
        if (alloc_res.is_none()) {
            ret err[str, str]("allocation failed");
        }

        buffer = alloc_res.unwrap();
    }
    
    # copy and process escapes
    var write_pos: usize = 0;
    var read_pos: usize = start;
    
    for (read_pos < (start + len + (has_escapes::usize))) {
        if (read_pos >= this.input.len) {
            brk;
        }
        
        val ch: char = @(this.input.data + read_pos);
        
        if (ch == '"') {
            brk;
        }
        or (ch == '\\') {
            read_pos = read_pos + 1;
            if (read_pos >= this.input.len) {
                brk;
            }
            
            val esc: char = @(this.input.data + read_pos);
            if (esc == 'n') {
                @(buffer + write_pos) = '\n';
            }
            or (esc == 't') {
                @(buffer + write_pos) = '\t';
            }
            or (esc == 'r') {
                @(buffer + write_pos) = '\r';
            }
            or (esc == '\\') {
                @(buffer + write_pos) = '\\';
            }
            or (esc == '"') {
                @(buffer + write_pos) = '"';
            }
            or {
                @(buffer + write_pos) = esc;
            }
            write_pos = write_pos + 1;
        }
        or {
            @(buffer + write_pos) = ch;
            write_pos = write_pos + 1;
        }
        
        read_pos = read_pos + 1;
    }
    
    ret ok[str, str](str{ buffer, write_pos });
}

fun (this: *TomlParser) parse_literal_string() Result[str, str] {
    if (this.current() != '\'') {
        ret err[str, str]("expected '\''");
    }
    this.advance();
    
    val start: usize = this.pos;
    
    for (this.pos < this.input.len) {
        val ch: char = this.current();
        if (ch == '\'') {
            brk;
        }
        or (ch == '\n') {
            ret err[str, str]("unexpected newline in literal string");
        }
        this.advance();
    }
    
    if (this.current() != '\'') {
        ret err[str, str]("unterminated literal string");
    }
    
    val len: usize = this.pos - start;
    this.advance();
    
    var buffer: *char = nil;
    if (len > 0) {
        val alloc_res: Option[*char] = mem.allocate[char](len);
        if (alloc_res.is_none()) {
            ret err[str, str]("allocation failed");
        }

        buffer = alloc_res.unwrap();
        mem.copy[char](buffer, this.input.data + start, len);
    }
    
    ret ok[str, str](str{ buffer, len });
}

fun (this: *TomlParser) parse_string_value() Result[str, str] {
    val ch: char = this.current();
    if (ch == '"') {
        ret this.parse_basic_string();
    }
    or (ch == '\'') {
        ret this.parse_literal_string();
    }
    ret err[str, str]("expected string");
}

fun (this: *TomlParser) parse_integer() Result[i64, str] {
    val start: usize = this.pos;
    var negative: bool = false;
    
    if (this.current() == '-') {
        negative = true;
        this.advance();
    }
    or (this.current() == '+') {
        this.advance();
    }
    
    if (ascii.is_digit(this.current()) == false) {
        ret err[i64, str]("expected digit");
    }
    
    var result: i64 = 0;
    for (this.pos < this.input.len) {
        val ch: char = this.current();
        
        if (ascii.is_digit(ch)) {
            val digit: i64 = (ch - '0')::i64;
            result = result * 10 + digit;
            this.advance();
        }
        or (ch == '_') {
            this.advance();
        }
        or {
            brk;
        }
    }
    
    if (negative) {
        result = 0 - result;
    }
    
    ret ok[i64, str](result);
}

fun (this: *TomlParser) parse_float() Result[f64, str] {
    val start: usize = this.pos;
    
    # parse sign
    if (this.current() == '-' || this.current() == '+') {
        this.advance();
    }
    
    # parse integer part
    for (this.pos < this.input.len) {
        val ch: char = this.current();
        if (ascii.is_digit(ch) || ch == '_') {
            this.advance();
        } or {
            brk;
        }
    }
    
    # parse fractional part
    if (this.current() == '.') {
        this.advance();
        for (this.pos < this.input.len) {
            val ch: char = this.current();
            if (ascii.is_digit(ch) || ch == '_') {
                this.advance();
            } or {
                brk;
            }
        }
    }
    
    # parse exponent
    if (this.current() == 'e' || this.current() == 'E') {
        this.advance();
        if (this.current() == '+' || this.current() == '-') {
            this.advance();
        }
        for (this.pos < this.input.len) {
            val ch: char = this.current();
            if (ascii.is_digit(ch) || ch == '_') {
                this.advance();
            } or {
                brk;
            }
        }
    }
    
    # simplified float parsing - just return 0.0 for now
    # proper implementation would convert string to f64
    ret ok[f64, str](0.0);
}

fun (this: *TomlParser) parse_number() Result[TomlValue, str] {
    val saved_pos: usize = this.pos;
    
    # check if it's a float (has . or e/E)
    var is_float: bool = false;
    var i: usize = 0;
    for ((saved_pos + i) < this.input.len) {
        val ch: char = this.peek(i);
        if (ch == '.' || ch == 'e' || ch == 'E') {
            is_float = true;
            brk;
        }
        or (ascii.is_digit(ch) == false && ch != '_' && ch != '-' && ch != '+') {
            brk;
        }
        i = i + 1;
    }
    
    if (is_float) {
        val float_res: Result[f64, str] = this.parse_float();
        if (float_res.is_err()) {
            ret err[TomlValue, str](float_res.unwrap_err());
        }
        ret ok[TomlValue, str](toml_float(float_res.unwrap_ok()));
    } or {
        val int_res: Result[i64, str] = this.parse_integer();
        if (int_res.is_err()) {
            ret err[TomlValue, str](int_res.unwrap_err());
        }
        ret ok[TomlValue, str](toml_integer(int_res.unwrap_ok()));
    }
}

fun (this: *TomlParser) parse_bool() Result[bool, str] {
    if (this.match_keyword("true")) {
        ret ok[bool, str](true);
    }
    or (this.match_keyword("false")) {
        ret ok[bool, str](false);
    }
    ret err[bool, str]("expected boolean");
}

fun (this: *TomlParser) parse_array() Result[TomlValue, str] {
    if (this.current() != '[') {
        ret err[TomlValue, str]("expected '['");
    }
    this.advance();

    var res_list: Result[List[TomlValue], str] = list_new[TomlValue](4);
    if (res_list.is_err()) {
        ret err[TomlValue, str](res_list.unwrap_err());
    }
    var list: List[TomlValue] = res_list.unwrap_ok();
    
    this.skip_whitespace_and_newlines();
    this.skip_comment();
    this.skip_whitespace_and_newlines();
    
    if (this.current() == ']') {
        this.advance();
        ret ok[TomlValue, str](toml_array(list));
    }
    
    for {
        this.skip_whitespace_and_newlines();
        this.skip_comment();
        this.skip_whitespace_and_newlines();
        
        if (this.current() == ']') {
            brk;
        }
        
        val value_res: Result[TomlValue, str] = this.parse_value();
        if (value_res.is_err()) {
            list.dnit();
            ret err[TomlValue, str](value_res.unwrap_err());
        }

        val push_err: Option[str] = list.push(value_res.unwrap_ok());
        if (push_err.is_some()) {
            list.dnit();
            ret err[TomlValue, str](push_err.unwrap());
        }
        
        this.skip_whitespace_and_newlines();
        this.skip_comment();
        this.skip_whitespace_and_newlines();
        
        if (this.current() == ',') {
            this.advance();
            this.skip_whitespace_and_newlines();
            this.skip_comment();
            this.skip_whitespace_and_newlines();
        }
        or (this.current() == ']') {
            brk;
        }
    }
    
    if (this.current() != ']') {
        list.dnit();
        ret err[TomlValue, str]("expected ']'");
    }
    this.advance();
    
    ret ok[TomlValue, str](toml_array(list));
}

fun (this: *TomlParser) parse_value() Result[TomlValue, str] {
    this.skip_whitespace();
    
    val ch: char = this.current();
    
    # boolean
    if (ch == 't' || ch == 'f') {
        val bool_res: Result[bool, str] = this.parse_bool();
        if (bool_res.is_err()) {
            ret err[TomlValue, str](bool_res.unwrap_err());
        }
        ret ok[TomlValue, str](toml_bool(bool_res.unwrap_ok()));
    }
    # string
    or (ch == '"' || ch == '\'') {
        val str_res: Result[str, str] = this.parse_string_value();
        if (str_res.is_err()) {
            ret err[TomlValue, str](str_res.unwrap_err());
        }
        ret ok[TomlValue, str](toml_string(str_res.unwrap_ok()));
    }
    # array
    or (ch == '[') {
        ret this.parse_array();
    }
    # number (int or float)
    or (ascii.is_digit(ch) || ch == '-' || ch == '+') {
        ret this.parse_number();
    }
    
    ret err[TomlValue, str]("unexpected character in value");
}

fun (this: *TomlParser) parse_key_value() Result[TomlProperty, str] {
    this.skip_whitespace();
    
    # parse key
    var key_res: Result[str, str];
    val ch: char = this.current();
    
    if (ch == '"') {
        key_res = this.parse_basic_string();
    }
    or (ch == '\'') {
        key_res = this.parse_literal_string();
    }
    or {
        key_res = this.parse_bare_key();
    }
    
    if (key_res.is_err()) {
        ret err[TomlProperty, str](key_res.unwrap_err());
    }
    
    val key: str = key_res.unwrap_ok();
    
    this.skip_whitespace();
    
    if (this.current() != '=') {
        ret err[TomlProperty, str]("expected '='");
    }
    this.advance();
    
    this.skip_whitespace();
    
    val value_res: Result[TomlValue, str] = this.parse_value();
    if (value_res.is_err()) {
        ret err[TomlProperty, str](value_res.unwrap_err());
    }
    
    var prop: TomlProperty;
    prop.key   = key;
    prop.value = value_res.unwrap_ok();
    
    ret ok[TomlProperty, str](prop);
}

fun (this: *TomlParser) parse_table_header() Result[str, str] {
    if (this.current() != '[') {
        ret err[str, str]("expected '[' to start table header");
    }
    this.advance();

    val start: usize = this.pos;

    for (this.pos < this.input.len) {
        val ch: char = this.current();
        if (ch == ']') {
            brk;
        }
        if (ascii.is_alnum(ch) || ch == '_' || ch == '-' || ch == '.') {
            this.advance();
            cnt;
        }
        ret err[str, str]("invalid character in table header");
    }

    if (this.current() != ']') {
        ret err[str, str]("unterminated table header");
    }

    val len: usize = this.pos - start;
    if (len == 0) {
        ret err[str, str]("empty table header");
    }

    var header: str;
    header.data = this.input.data + start;
    header.len  = len;

    this.advance();

    this.skip_whitespace();
    if (this.current() == '#') {
        this.skip_comment();
    }
    this.skip_whitespace_and_newlines();

    ret ok[str, str](header);
}

fun (this: *TomlParser) parse_table(allow_headers: bool) Result[TomlValue, str] {
    var res_list: Result[List[TomlProperty], str] = list_new[TomlProperty](8);
    if (res_list.is_err()) {
        ret err[TomlValue, str](res_list.unwrap_err());
    }
    var list: List[TomlProperty] = res_list.unwrap_ok();
    
    for (this.pos < this.input.len) {
        this.skip_whitespace_and_newlines();
        
        if (this.pos >= this.input.len) {
            brk;
        }
        
        # skip comments
        if (this.current() == '#') {
            this.skip_comment();
            cnt;
        }
        
        # skip empty lines
        if (this.current() == '\n' || this.current() == '\r') {
            this.advance();
            cnt;
        }
        
        if (this.current() == '[') {
            if (allow_headers == false) {
                brk;
            }

            val header_res: Result[str, str] = this.parse_table_header();
            if (header_res.is_err()) {
                list.dnit();
                ret err[TomlValue, str](header_res.unwrap_err());
            }

            var header: str = header_res.unwrap_ok();

            val table_res: Result[TomlValue, str] = this.parse_table(false);
            if (table_res.is_err()) {
                list.dnit();
                ret err[TomlValue, str](table_res.unwrap_err());
            }

            var prop: TomlProperty;
            prop.key   = header;
            prop.value = table_res.unwrap_ok();

            val push_err: Option[str] = list.push(prop);
            if (push_err.is_some()) {
                val err_msg: str = push_err.unwrap();
                list.dnit();
                ret err[TomlValue, str](err_msg);
            }

            cnt;
        }
        
        val kv_res: Result[TomlProperty, str] = this.parse_key_value();
        if (kv_res.is_err()) {
            list.dnit();
            ret err[TomlValue, str](kv_res.unwrap_err());
        }

        val push_err: Option[str] = list.push(kv_res.unwrap_ok());
        if (push_err.is_some()) {
            list.dnit();
            ret err[TomlValue, str](push_err.unwrap());
        }
        
        this.skip_whitespace();
        
        # expect newline or comment after key-value
        if (this.current() == '#') {
            this.skip_comment();
        }
        
        if (this.current() != '\n' && this.current() != '\r' && this.pos < this.input.len) {
            list.dnit();
            ret err[TomlValue, str]("expected newline after key-value");
        }
    }
    
    ret ok[TomlValue, str](toml_table(list));
}

# main parse function
pub fun parse_toml(input: str) Result[TomlValue, str] {
    var parser: TomlParser;
    parser.input = input;
    parser.pos   = 0;
    parser.line  = 1;
    
    ret parser.parse_table(true);
}
