use          std.types.bool;
use          std.types.list;
use          std.types.option;
use          std.types.result;
use          std.types.size;
use          std.types.string;
use console: std.io.console;
use fs:      std.io.filesystem;
use std.io.path;
use mem:     std.system.memory;

use std.lang.config;
use std.lang.module;
use std.lang.diagnostics;
use std.lang.driver.session;
use std.lang.driver.pipeline;
use std.lang.frontend.lexical.lexer;
use std.lang.frontend.lexical.tokens;
use std.lang.frontend.syntax.parser;
use std.lang.frontend.syntax.ast;

pub rec Driver {
    session: *Session;
    modules: List[Module];
    options: PipelineOptions;
}

fun find_target(config: *Config, name: str) Option[*ConfigTarget] {
    if (config.targets.data == nil || config.targets.len == 0) {
        ret none[*ConfigTarget]();
    }

    if (name.data == nil || name.len == 0) {
        ret some[*ConfigTarget](config.targets.data);
    }

    var i: usize = 0;
    for (i < config.targets.len) {
        val candidate: *ConfigTarget = config.targets.data + i;
        if (candidate.name.equals(name)) {
            ret some[*ConfigTarget](candidate);
        }
        i = i + 1;
    }

    ret none[*ConfigTarget]();
}

fun resolve_entrypoint_path(session: *Session, entry_rel: str) Result[Path, str] {
    val entry_res: Result[Path, str] = path_from_string(entry_rel);
    if (entry_res.is_err()) {
        ret err[Path, str](entry_res.unwrap_err());
    }

    var entry_path: Path = entry_res.unwrap_ok();

    if (path_is_absolute_str(entry_rel)) {
        ret ok[Path, str](entry_path);
    }

    val root_clone_res: Result[Path, str] = session.source_root.clone();
    if (root_clone_res.is_err()) {
        entry_path.dnit();
        ret err[Path, str](root_clone_res.unwrap_err());
    }

    var root_clone: Path = root_clone_res.unwrap_ok();
    val joined_res: Result[Path, str] = path_join(root_clone, entry_path);
    root_clone.dnit();
    entry_path.dnit();

    if (joined_res.is_err()) {
        ret err[Path, str](joined_res.unwrap_err());
    }

    ret ok[Path, str](joined_res.unwrap_ok());
}

fun bytes_to_str(bytes: []u8) str {
    var view: str;
    view.data = bytes.data::*char;
    view.len  = bytes.len;
    ret view;
}

fun make_module_id(project_id: str, entry_rel: str) Result[String, str] {
    if (project_id.data == nil || project_id.len == 0) {
        ret err[String, str]("project id is empty");
    }

    if (entry_rel.data == nil || entry_rel.len == 0) {
        val clone_res: Result[String, str] = project_id.clone();
        if (clone_res.is_err()) {
            ret err[String, str](clone_res.unwrap_err());
        }
        ret ok[String, str](clone_res.unwrap_ok());
    }

    # leverage the Path module to get consistent separator behavior
    val rel_path_res: Result[Path, str] = path_from_string(entry_rel);
    if (rel_path_res.is_err()) {
        ret err[String, str](rel_path_res.unwrap_err());
    }
    var rel_path: Path = rel_path_res.unwrap_ok();
    val rel_str: str   = rel_path.as_str();

    var effective_len: usize = rel_str.len;

    if (effective_len >= 5 && rel_str.ends_with(".mach")) {
        effective_len = effective_len - 5;
    }

    # drop leading separators that path normalization kept
    var start: usize = 0;
    for (start < effective_len) {
        val ch: char = @(rel_str.data + start);
        if (ch == '/' || ch == '\\') {
            start = start + 1;
        }
        or {
            brk;
        }
    }

    if (effective_len > start) {
        effective_len = effective_len - start;
    }
    or {
        effective_len = 0;
    }

    if (effective_len == 0) {
        rel_path.dnit();
        val clone_res: Result[String, str] = project_id.clone();
        if (clone_res.is_err()) {
            ret err[String, str](clone_res.unwrap_err());
        }
        ret ok[String, str](clone_res.unwrap_ok());
    }

    val total_len: usize = project_id.len + 1 + effective_len;

    var module_id: String;
    val init_err: Option[str] = module_id.init(total_len);
    if (init_err.is_some()) {
        rel_path.dnit();
        ret err[String, str](init_err.unwrap());
    }

    mem.copy[char](module_id.data, project_id.data, project_id.len);

    var offset: usize = project_id.len;
    @(module_id.data + offset) = '.';
    offset = offset + 1;

    var i: usize = 0;
    for (i < effective_len) {
        var ch: char = @(rel_str.data + start + i);
        if (ch == '/' || ch == '\\') {
            ch = '.';
        }
        @(module_id.data + offset) = ch;
        offset = offset + 1;
        i = i + 1;
    }

    rel_path.dnit();
    ret ok[String, str](module_id);
}

pub rec ModulePathRef {
    prefix:   str;
    segments: List[str];
}

fun module_path_ref_dnit(ref: *ModulePathRef) {
    if (ref == nil) {
        ret;
    }

    ref.segments.dnit();
    mem.zero[ModulePathRef](ref, 1);
}

fun module_path_ref_parse(path: str) Result[ModulePathRef, str] {
    if (path.data == nil || path.len == 0) {
        ret err[ModulePathRef, str]("module path is empty");
    }

    var reference: ModulePathRef;
    mem.zero[ModulePathRef](?reference, 1);

    val dot_opt: Option[usize] = path.index_of_char('.');
    if (dot_opt.is_none()) {
        reference.prefix = path;
        val init_err: Option[str] = reference.segments.init(1);
        if (init_err.is_some()) {
            ret err[ModulePathRef, str](init_err.unwrap());
        }
        ret ok[ModulePathRef, str](reference);
    }

    val first_dot: usize = dot_opt.unwrap();
    if (first_dot == 0) {
        ret err[ModulePathRef, str]("module path missing prefix");
    }
    if (first_dot >= path.len - 1) {
        ret err[ModulePathRef, str]("module path missing body");
    }

    val prefix_opt: Option[str] = path.substring(0, first_dot);
    if (prefix_opt.is_none()) {
        ret err[ModulePathRef, str]("invalid module prefix");
    }
    reference.prefix = prefix_opt.unwrap();

    var segment_count: usize = 1;
    var idx: usize = first_dot + 1;
    var last_was_dot: bool = false;
    for (idx < path.len) {
        val ch: char = @(path.data + idx);
        if (ch == '.') {
            if (last_was_dot) {
                ret err[ModulePathRef, str]("empty module segment");
            }
            segment_count = segment_count + 1;
            last_was_dot = true;
        }
        or {
            last_was_dot = false;
        }
        idx = idx + 1;
    }

    if (last_was_dot) {
        ret err[ModulePathRef, str]("module path cannot end with '.'");
    }

    val init_err: Option[str] = reference.segments.init(segment_count);
    if (init_err.is_some()) {
        ret err[ModulePathRef, str](init_err.unwrap());
    }

    var seg_start: usize = first_dot + 1;
    var pos: usize = first_dot + 1;
    for (pos <= path.len) {
        if (pos == path.len || @(path.data + pos) == '.') {
            if (pos == seg_start) {
                module_path_ref_dnit(?reference);
                ret err[ModulePathRef, str]("empty module segment");
            }

            val seg_opt: Option[str] = path.substring(seg_start, pos);
            if (seg_opt.is_none()) {
                module_path_ref_dnit(?reference);
                ret err[ModulePathRef, str]("invalid module segment");
            }

            val push_err: Option[str] = reference.segments.push(seg_opt.unwrap());
            if (push_err.is_some()) {
                module_path_ref_dnit(?reference);
                ret err[ModulePathRef, str](push_err.unwrap());
            }

            seg_start = pos + 1;
        }
        pos = pos + 1;
    }

    ret ok[ModulePathRef, str](reference);
}

fun driver_make_module(module_id: str, file_path: str) Result[Module, str] {
    val read_res: Result[[]u8, str] = fs.read_all(file_path);
    if (read_res.is_err()) {
        ret err[Module, str](read_res.unwrap_err());
    }

    var contents: []u8 = read_res.unwrap_ok();
    var source_view: str = bytes_to_str(contents);

    var module: Module;
    val module_err: Option[str] = module.init(module_id, file_path, source_view);
    if (module_err.is_some()) {
        mem.deallocate[u8](contents.data, contents.len);
        ret err[Module, str](module_err.unwrap());
    }

    mem.deallocate[u8](contents.data, contents.len);

    val module_source: str = module.source;
    val module_id_str: str = module.id;

    var lexer_instance: Lexer = lexer_make(module_source, module_id_str);
    var tokens: List[Token] = lexer_instance.collect();
    if (tokens.data == nil) {
        module.dnit();
        ret err[Module, str]("lexer failed to collect tokens for module");
    }

    var ast_res: Result[AST, str] = ast_make();
    if (ast_res.is_err()) {
        tokens.dnit();
        module.dnit();
        ret err[Module, str](ast_res.unwrap_err());
    }

    var parser_ast: AST = ast_res.unwrap_ok();

    var parser_instance: Parser;
    val parser_err: Option[str] = parser_instance.init(?tokens, ?parser_ast);
    if (parser_err.is_some()) {
        tokens.dnit();
        parser_ast.dnit();
        module.dnit();
        ret err[Module, str](parser_err.unwrap());
    }

    val parse_res: Result[AST, str] = parser_instance.parse_module();
    parser_instance.dnit();

    if (parse_res.is_err()) {
        tokens.dnit();
        parser_ast.dnit();
        module.dnit();
        ret err[Module, str](parse_res.unwrap_err());
    }

    var parsed_ast: AST = parse_res.unwrap_ok();

    module.ast    = some[AST](parsed_ast);
    module.tokens = some[List[Token]](tokens);

    ret ok[Module, str](module);
}

pub fun (this: *Driver) init(session: *Session) Option[str] {
    mem.zero[Driver](this, 1);

    if (session == nil) {
        ret some[str]("invalid driver session");
    }

    this.session = session;

    val opt_modules_init: Option[str] = this.modules.init(4);
    if (opt_modules_init.is_some()) {
        ret opt_modules_init;
    }

    ret none[str]();
}

pub fun (this: *Driver) dnit() {
    var i: usize = 0;
    for (i < this.modules.len) {
        val module: *Module = this.modules.data + i;
        module.dnit();
        i = i + 1;
    }

    this.modules.dnit();

    this.session = nil;
    mem.zero[Driver](this, 1);
}

# setup stage lexes and parses only the entrypoint module to "bootstrap" the
# process (or for library mode without entrypoint, discovers all source files)
pub fun (this: *Driver) stage_setup() Option[str] {
    if (this.session == nil) {
        ret some[str]("driver session is not initialized");
    }

    # TODO: leverage this.options.target_mode/debug/optimize to drive backend configuration
    # once code generation stages are implemented.

    val target_opt: Option[ConfigTarget] = this.session.options.config.target_get(this.session.options.config.target);
    if (target_opt.is_none()) {
        ret some[str]("selected target not found in configuration");
    }

    val target: ConfigTarget = target_opt.unwrap();

    # check if this is library mode without entrypoint
    val is_library: bool = target.mode.equals("library") || target.mode.equals("shared");
    val has_entrypoint: bool = target.entrypoint.data != nil && target.entrypoint.len > 0;

    if (is_library && has_entrypoint == false) {
        # library mode without entrypoint - multi-file compilation not yet implemented
        ret some[str]("library builds without entrypoint require multi-file compilation (not yet implemented)");
    }

    val module_id_res: Result[String, str] = make_module_id(this.session.options.config.project_id, target.entrypoint);
    if (module_id_res.is_err()) {
        ret some[str](module_id_res.unwrap_err());
    }

    var module_id_buf: String = module_id_res.unwrap_ok();
    val module_id_view: str = module_id_buf;

    val session: *Session = this.session;
    val entry_path_res: Result[Path, str] = resolve_entrypoint_path(session, target.entrypoint);
    if (entry_path_res.is_err()) {
        module_id_buf.dnit();
        ret some[str](entry_path_res.unwrap_err());
    }

    var entry_path: Path = entry_path_res.unwrap_ok();
    val module_res: Result[Module, str] = driver_make_module(module_id_view, entry_path.as_str());
    entry_path.dnit();
    module_id_buf.dnit();

    if (module_res.is_err()) {
        ret some[str](module_res.unwrap_err());
    }

    var module: Module = module_res.unwrap_ok();

    val add_err: Option[str] = this.add_module(?module);
    if (add_err.is_some()) {
        module.dnit();
        ret add_err;
    }

    val imports_err: Option[str] = this.resolve_imports();
    if (imports_err.is_some()) {
        ret imports_err;
    }

    ret none[str]();
}

fun (this: *Driver) resolve_imports() Option[str] {
    if (this.session == nil) {
        ret some[str]("driver session is not initialized");
    }

    var index: usize = 0;
    for (index < this.modules.len) {
        val module_ptr: *Module = this.modules.data + index;
        val process_err: Option[str] = this.process_module_imports(module_ptr);
        if (process_err.is_some()) {
            ret process_err;
        }
        index = index + 1;
    }

    ret none[str]();
}

fun (this: *Driver) process_module_imports(module: *Module) Option[str] {
    if (module == nil) {
        ret some[str]("invalid module reference");
    }

    val imports_res: Result[List[ModuleImport], str] = module.extract_imports();
    if (imports_res.is_err()) {
        ret some[str](imports_res.unwrap_err());
    }

    var imports: List[ModuleImport] = imports_res.unwrap_ok();

    var i: usize = 0;
    for (i < imports.len) {
        val import_opt: Option[ModuleImport] = imports.get(i);
        if (import_opt.is_none()) {
            imports.dnit();
            ret some[str]("failed to access module import entry");
        }

        val import: ModuleImport = import_opt.unwrap();

        val load_err: Option[str] = this.load_import(import);
        if (load_err.is_some()) {
            imports.dnit();
            ret load_err;
        }

        i = i + 1;
    }

    imports.dnit();

    ret none[str]();
}

fun (this: *Driver) load_import(import: ModuleImport) Option[str] {
    if (import.path.data == nil || import.path.len == 0) {
        ret some[str]("module path is empty");
    }

    if (import.path.equals("target")) {
        ret none[str]();
    }

    if (this.get_module(import.path).is_some()) {
        ret none[str]();
    }

    val ref_res: Result[ModulePathRef, str] = module_path_ref_parse(import.path);
    if (ref_res.is_err()) {
        this.session.emit_diagnostic(DIAGNOSTIC_ERROR, import.token, ref_res.unwrap_err());
        ret some[str](ref_res.unwrap_err());
    }

    var reference: ModulePathRef = ref_res.unwrap_ok();

    val segment_slice: []str = reference.segments.as_slice();
    val path_res: Result[Path, str] = session_resolve_module_path(this.session, reference.prefix, segment_slice);
    if (path_res.is_err()) {
        val err_message: str = path_res.unwrap_err();
        driver_emit_module_resolution_error(this, import.token, err_message, import.path, reference.prefix);
        module_path_ref_dnit(?reference);
        ret some[str](err_message);
    }

    var module_path: Path = path_res.unwrap_ok();
    val module_res: Result[Module, str] = driver_make_module(import.path, module_path.as_str());
    module_path.dnit();
    module_path_ref_dnit(?reference);

    if (module_res.is_err()) {
        val err_message: str = module_res.unwrap_err();
        this.session.emit_diagnostic(DIAGNOSTIC_ERROR, import.token, err_message);
        ret some[str](err_message);
    }

    var module_instance: Module = module_res.unwrap_ok();
    val add_err: Option[str] = this.add_module(?module_instance);
    if (add_err.is_some()) {
        module_instance.dnit();
        ret add_err;
    }

    ret none[str]();
}

fun driver_emit_module_resolution_error(driver: *Driver, token: Token, code: str, module_path: str, prefix: str) {
    if (driver == nil || driver.session == nil) {
        ret;
    }

    var message_owned: Option[String] = none[String]();

    if (code.equals("unknown_module_prefix")) {
        message_owned = format("unknown module prefix '%s' in import '%s'", prefix, module_path);
    }
    or (code.equals("dependency_not_vendored")) {
        message_owned = format("dependency '%s' is not vendored (expected dep/%s)", prefix, prefix);
    }
    or (code.equals("dependency_mach_toml_missing")) {
        message_owned = format("dependency '%s' is missing mach.toml under dep/%s", prefix, prefix);
    }

    if (message_owned.is_some()) {
        var owned: String = message_owned.unwrap();
        driver.session.emit_diagnostic(DIAGNOSTIC_ERROR, token, owned.as_str());
        owned.dnit();
        ret;
    }

    driver.session.emit_diagnostic(DIAGNOSTIC_ERROR, token, code);
}

pub fun (this: *Driver) stage_parse() Option[str] {
    ret some[str]("parsing not yet implemented");
}

pub fun (this: *Driver) stage_semantic() Option[str] {
    ret some[str]("semantic analysis not yet implemented");
}

pub fun (this: *Driver) stage_lower() Option[str] {
    ret some[str]("lowering not yet implemented");
}

pub fun (this: *Driver) stage_codegen() Option[str] {
    ret some[str]("code generation not yet implemented");
}

pub fun (this: *Driver) run_pipeline(options: PipelineOptions) Option[str] {
    this.options = options;

    if (this.options.run_setup) {
        val setup_err: Option[str] = this.stage_setup();
        if (setup_err.is_some()) {
            ret setup_err;
        }
    }

    if (this.options.run_parse) {
        val parse_err: Option[str] = this.stage_parse();
        if (parse_err.is_some()) {
            ret parse_err;
        }
    }

    if (this.options.run_semantic) {
        val sema_err: Option[str] = this.stage_semantic();
        if (sema_err.is_some()) {
            ret sema_err;
        }
    }

    if (this.options.run_lower) {
        val lower_err: Option[str] = this.stage_lower();
        if (lower_err.is_some()) {
            ret lower_err;
        }
    }

    if (this.options.run_codegen) {
        val codegen_err: Option[str] = this.stage_codegen();
        if (codegen_err.is_some()) {
            ret codegen_err;
        }
    }

    ret none[str]();
}

pub fun (this: *Driver) get_module(id: str) Option[*Module] {
    var i: usize = 0;
    for (i < this.modules.len) {
        val module: *Module = this.modules.data + i;
        if (module.id.as_str().equals(id)) {
            ret some[*Module](module);
        }
        i = i + 1;
    }

    ret none[*Module]();
}

pub fun (this: *Driver) add_module(module: *Module) Option[str] {
    val res_push: Option[str] = this.modules.push(@module);
    if (res_push.is_some()) {
        ret some[str]("failed to add module to build context");
    }

    ret none[str]();
}

pub fun (this: *Driver) load_module(module_id: str) Option[str] {
    var import: ModuleImport;
    import.path = module_id;
    mem.zero[Token](?import.token, 1);

    ret this.load_import(import);
}

pub fun (this: *Driver) has_errors() bool {
    if (this.session == nil) {
        ret false;
    }

    ret this.session.has_errors();
}

# print all diagnostics
pub fun (this: *Driver) print_diagnostics() {
    val session: *Session = this.session;
    if (session == nil) {
        ret;
    }

    val count: usize = session.diagnostics_len();
    
    var i: usize = 0;
    for (i < count) {
        val diag_opt: Option[Diagnostic] = session.diagnostics.get(i);
        if (diag_opt.is_some()) {
            val diag: Diagnostic = diag_opt.unwrap();
            
            # get module ID from token
            var path:   str = "<unknown>";
            var source: str = str{ nil, 0 };

            val module: Option[*Module] = this.get_module(diag.token.module_id);
            if (module.is_some()) {
                val mod_ref: *Module = module.unwrap();
                path   = mod_ref.path;
                source = mod_ref.source;
            }

            diag.print(source, path);
        }
        i = i + 1;
    }
    
    # print summary
    if (count > 0) {
        console.print("\n");
        if (this.has_errors()) {
            console.print("compilation failed with %d errors(s)\n", count);
        }
        or {
            console.print("compilation succeeded with %d warning(s)\n", count);
        }
    }
}
