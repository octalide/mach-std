use      std.types.bool;
use      std.types.string;
use      std.types.list;
use      std.types.size;
use      std.types.result;
use      std.types.option;
use      std.data.toml;
use mem: std.system.memory;

use fs:      std.io.filesystem;
use console: std.io.console;

pub rec ConfigTarget {
    name:          str;  # target name
    triple:        str;  # target triple
    entrypoint:    str;  # entrypoint file
    artifacts:     str;  # output artifacts directory
    output:        str;  # output binary path
    mode:          str;  # build mode (executable|library|shared)
    debug:         bool; # enable debug info for this target
    optimize:      bool; # enable optimizations for this target
    emit_ast:      bool; # emit AST files
    emit_ir:       bool; # emit intermediate representation files
    emit_asm:      bool; # emit assembly files
    emit_obj:      bool; # emit object files
    no_pie:        bool; # disable position-independent executable generation
}

fun target_mode_is_valid(value: str) bool {
    if (value.equals("executable")) { ret true; }
    if (value.equals("library"))    { ret true; }
    if (value.equals("shared"))     { ret true; }
    ret false;
}

pub fun (this: *ConfigTarget) init() {
    mem.zero[ConfigTarget](this, 1);
}

pub fun (this: *ConfigTarget) dnit() {
    mem.zero[ConfigTarget](this, 1);
}

pub rec ConfigDependency {
    name:    str; # dependency key (alias)
    type:    str; # dependency type: remote|local
    path:    str; # source path or URL (used by dep tooling)
    version: str; # optional semantic version/selector (required for remote)
}

pub fun (this: *ConfigDependency) init() {
    mem.zero[ConfigDependency](this, 1);
}

pub fun (this: *ConfigDependency) dnit() {
    mem.zero[ConfigDependency](this, 1);
}

pub rec Config {
    source:       String; # source file
    project_id:   str;    # unique project identifier
    project_name: str;    # cannonical project name
    version:      str;    # project version
    dir_source:   str;    # source directory
    dir_dep:      str;    # dependency directory
    target:       str;    # selected build target

    dependencies: List[ConfigDependency]; # project dependencies ([deps] tables)
    targets:      List[ConfigTarget];     # build targets
}

pub fun (this: *Config) init() {
    mem.zero[Config](this, 1);

    val deps_err: Option[str] = this.dependencies.init(8);
    if (deps_err.is_some()) {
        console.print("error: failed to allocate dependencies list\n");
        ret;
    }

    val targets_err: Option[str] = this.targets.init(4);
    if (targets_err.is_some()) {
        console.print("error: failed to allocate targets list\n");
        this.dependencies.dnit();
        ret;
    }
}

pub fun (this: *Config) dnit() {
    this.source.dnit();

    if (this.dependencies.data != nil) {
        var i: usize = 0;
        for (i < this.dependencies.len) {
            val dep_ptr: *ConfigDependency = this.dependencies.data + i;
            dep_ptr.dnit();
            i = i + 1;
        }
    }
    this.dependencies.dnit();

    if (this.targets.data != nil) {
        var i: usize = 0;
        for (i < this.targets.len) {
            val target_ptr: *ConfigTarget = this.targets.data + i;
            target_ptr.dnit();
            i = i + 1;
        }
    }
    this.targets.dnit();

    mem.zero[Config](this, 1);
}

pub fun (this: *Config) target_add(target: ConfigTarget) Option[str] {
    ret this.targets.push(target);
}

pub fun (this: *Config) target_get(name: str) Option[ConfigTarget] {
    var i: usize = 0;
    for (i < this.targets.len) {
        val target_opt: Option[ConfigTarget] = this.targets.get(i);
        if (target_opt.is_some()) {
            val target: ConfigTarget = target_opt.unwrap();
            if (target.name.equals(name)) {
                ret some[ConfigTarget](target);
            }
        }
        i = i + 1;
    }
    ret none[ConfigTarget]();
}

pub fun (this: *Config) dependency_add(dep: ConfigDependency) Option[str] {
    ret this.dependencies.push(dep);
}

fun get_string_from_table(table: *List[TomlProperty], key: str) Option[str] {
    var i: usize = 0;
    for (i < table.len) {
        val prop_opt: Option[TomlProperty] = table.get(i);
        if (prop_opt.is_some()) {
            val prop: TomlProperty = prop_opt.unwrap();
            if (prop.key.equals(key)) {
                ret prop.value.as_string();
            }
        }
        i = i + 1;
    }
    ret none[str]();
}

fun get_integer_from_table(table: *List[TomlProperty], key: str) Option[i64] {
    var i: usize = 0;
    for (i < table.len) {
        val prop_opt: Option[TomlProperty] = table.get(i);
        if (prop_opt.is_some()) {
            val prop: TomlProperty = prop_opt.unwrap();
            if (prop.key.equals(key)) {
                ret prop.value.as_integer();
            }
        }
        i = i + 1;
    }
    ret none[i64]();
}

fun get_bool_from_table(table: *List[TomlProperty], key: str) Option[bool] {
    var i: usize = 0;
    for (i < table.len) {
        val prop_opt: Option[TomlProperty] = table.get(i);
        if (prop_opt.is_some()) {
            val prop: TomlProperty = prop_opt.unwrap();
            if (prop.key.equals(key)) {
                ret prop.value.as_bool();
            }
        }
        i = i + 1;
    }
    ret none[bool]();
}

fun get_table_from_table(table: *List[TomlProperty], key: str) Option[*List[TomlProperty]] {
    var i: usize = 0;
    for (i < table.len) {
        val prop_opt: Option[TomlProperty] = table.get(i);
        if (prop_opt.is_some()) {
            val prop: TomlProperty = prop_opt.unwrap();
            if (prop.key.equals(key)) {
                ret prop.value.as_table();
            }
        }
        i = i + 1;
    }
    ret none[*List[TomlProperty]]();
}

fun get_array_from_table(table: *List[TomlProperty], key: str) Option[*List[TomlValue]] {
    var i: usize = 0;
    for (i < table.len) {
        val prop_opt: Option[TomlProperty] = table.get(i);
        if (prop_opt.is_some()) {
            val prop: TomlProperty = prop_opt.unwrap();
            if (prop.key.equals(key)) {
                ret prop.value.as_array();
            }
        }
        i = i + 1;
    }
    ret none[*List[TomlValue]]();
}

fun parse_dependency(dep_name: str, dep_table: *List[TomlProperty]) Result[ConfigDependency, str] {
    var dep: ConfigDependency;
    dep.init();

    dep.name = dep_name;

    val type_opt: Option[str] = get_string_from_table(dep_table, "type");
    if (type_opt.is_none()) {
        ret err[ConfigDependency, str]("dependency missing 'type' field");
    }
    val type_value: str = type_opt.unwrap();
    if (type_value.equals("remote") == false && type_value.equals("local") == false) {
        ret err[ConfigDependency, str]("dependency 'type' must be 'remote' or 'local'");
    }
    dep.type = type_value;

    val path_opt: Option[str] = get_string_from_table(dep_table, "path");
    if (path_opt.is_none()) {
        ret err[ConfigDependency, str]("dependency missing 'path' field");
    }
    dep.path = path_opt.unwrap();

    val version_opt: Option[str] = get_string_from_table(dep_table, "version");
    if (dep.type.equals("remote")) {
        if (version_opt.is_none()) {
            ret err[ConfigDependency, str]("remote dependency missing 'version'");
        }
        dep.version = version_opt.unwrap();
    } or {
        if (version_opt.is_some()) {
            dep.version = version_opt.unwrap();
        }
    }

    ret ok[ConfigDependency, str](dep);
}

fun parse_target(target_name: str, target_table: *List[TomlProperty]) Result[ConfigTarget, str] {
    var name_copy: str = target_name;

    var target: ConfigTarget;
    target.init();

    val triple_opt: Option[str] = get_string_from_table(target_table, "triple");
    if (triple_opt.is_none()) {
        ret err[ConfigTarget, str]("target missing 'triple' field");
    }
    target.triple = triple_opt.unwrap();

    val entrypoint_opt: Option[str] = get_string_from_table(target_table, "entrypoint");
    # entrypoint is optional - will be validated after mode is known
    if (entrypoint_opt.is_some()) {
        target.entrypoint = entrypoint_opt.unwrap();
    }

    val artifacts_opt: Option[str] = get_string_from_table(target_table, "artifacts");
    if (artifacts_opt.is_none()) {
        ret err[ConfigTarget, str]("target missing 'artifacts' field");
    }
    target.artifacts = artifacts_opt.unwrap();

    val output_opt: Option[str] = get_string_from_table(target_table, "output");
    if (output_opt.is_none()) {
        ret err[ConfigTarget, str]("target missing 'output' field");
    }
    target.output = output_opt.unwrap();

    val mode_opt: Option[str] = get_string_from_table(target_table, "mode");
    if (mode_opt.is_none()) {
        ret err[ConfigTarget, str]("target missing 'mode' field");
    }

    val mode_value: str = mode_opt.unwrap();
    if (target_mode_is_valid(mode_value) == false) {
        ret err[ConfigTarget, str]("target 'mode' must be executable, library, or shared");
    }
    target.mode = mode_value;

    # validate entrypoint requirement based on mode
    val is_library: bool = mode_value.equals("library") || mode_value.equals("shared");
    if (is_library == false && entrypoint_opt.is_none()) {
        ret err[ConfigTarget, str]("target entrypoint is required for executable mode");
    }

    val debug_opt: Option[bool] = get_bool_from_table(target_table, "debug");
    if (debug_opt.is_none()) {
        ret err[ConfigTarget, str]("target missing 'debug' field");
    }
    target.debug = debug_opt.unwrap();

    val optimize_opt: Option[bool] = get_bool_from_table(target_table, "optimize");
    if (optimize_opt.is_none()) {
        ret err[ConfigTarget, str]("target missing 'optimize' field");
    }
    target.optimize = optimize_opt.unwrap();

    val emit_ast_opt: Option[bool] = get_bool_from_table(target_table, "emit-ast");
    if (emit_ast_opt.is_none()) {
        ret err[ConfigTarget, str]("target missing 'emit-ast' field");
    }
    target.emit_ast = emit_ast_opt.unwrap();

    val emit_ir_opt: Option[bool] = get_bool_from_table(target_table, "emit-ir");
    if (emit_ir_opt.is_none()) {
        ret err[ConfigTarget, str]("target missing 'emit-ir' field");
    }
    target.emit_ir = emit_ir_opt.unwrap();

    val emit_asm_opt: Option[bool] = get_bool_from_table(target_table, "emit-asm");
    if (emit_asm_opt.is_none()) {
        ret err[ConfigTarget, str]("target missing 'emit-asm' field");
    }
    target.emit_asm = emit_asm_opt.unwrap();

    val emit_obj_opt: Option[bool] = get_bool_from_table(target_table, "emit-object");
    if (emit_obj_opt.is_none()) {
        ret err[ConfigTarget, str]("target missing 'emit-object' field");
    }
    target.emit_obj = emit_obj_opt.unwrap();

    val no_pie_opt: Option[bool] = get_bool_from_table(target_table, "no-pie");
    if (no_pie_opt.is_none()) {
        ret err[ConfigTarget, str]("target missing 'no-pie' field");
    }
    target.no_pie = no_pie_opt.unwrap();

    target.name = name_copy;

    ret ok[ConfigTarget, str](target);
}

fun parse_project_section(cfg: *Config, project_table: *List[TomlProperty]) Result[bool, str] {
    val id_opt: Option[str] = get_string_from_table(project_table, "id");
    if (id_opt.is_none()) {
        ret err[bool, str]("project section missing 'id'");
    }
    cfg.project_id = id_opt.unwrap();

    val name_opt: Option[str] = get_string_from_table(project_table, "name");
    if (name_opt.is_none()) {
        ret err[bool, str]("project section missing 'name'");
    }
    cfg.project_name = name_opt.unwrap();

    val version_opt: Option[str] = get_string_from_table(project_table, "version");
    if (version_opt.is_none()) {
        ret err[bool, str]("project section missing 'version'");
    }
    cfg.version = version_opt.unwrap();

    val src_opt: Option[str] = get_string_from_table(project_table, "src");
    if (src_opt.is_none()) {
        ret err[bool, str]("project section missing 'src'");
    }
    cfg.dir_source = src_opt.unwrap();

    val dep_opt: Option[str] = get_string_from_table(project_table, "dep");
    if (dep_opt.is_none()) {
        ret err[bool, str]("project section missing 'dep'");
    }
    cfg.dir_dep = dep_opt.unwrap();

    val target_opt: Option[str] = get_string_from_table(project_table, "target");
    if (target_opt.is_none()) {
        ret err[bool, str]("project section missing 'target'");
    }
    cfg.target = target_opt.unwrap();

    ret ok[bool, str](true);
}

fun parse_dependencies_section(cfg: *Config, deps_table: *List[TomlProperty]) Result[bool, str] {
    var i: usize = 0;
    for (i < deps_table.len) {
        val dep_prop_opt: Option[TomlProperty] = deps_table.get(i);
        if (dep_prop_opt.is_none()) {
            i = i + 1;
            cnt;
        }

        val dep_prop: TomlProperty = dep_prop_opt.unwrap();
        val dep_table_opt: Option[*List[TomlProperty]] = dep_prop.value.as_table();
        if (dep_table_opt.is_none()) {
            ret err[bool, str]("dependency entry must be a table");
        }

        val dep_result: Result[ConfigDependency, str] = parse_dependency(dep_prop.key, dep_table_opt.unwrap());
        if (dep_result.is_err()) {
            ret err[bool, str](dep_result.unwrap_err());
        }

        val push_err: Option[str] = cfg.dependency_add(dep_result.unwrap_ok());
        if (push_err.is_some()) {
            ret err[bool, str](push_err.unwrap());
        }

        i = i + 1;
    }

    ret ok[bool, str](true);
}

fun config_error(config: *Config, message: str) Result[Config, str] {
    config.dnit();
    ret err[Config, str](message);
}

pub fun config_read(path: str) Result[Config, str] {
    var config: Config;
    config.init();

    # read file contents
    val file_result: Result[[]u8, str] = fs.read_all(path);
    if (file_result.is_err()) {
        ret err[Config, str](file_result.unwrap_err());
    }

    val contents: []u8 = file_result.unwrap_ok();
    config.source.data = contents.data;
    config.source.len  = contents.len;
    
    # parse toml
    val toml_result: Result[TomlValue, str] = parse_toml(config.source.as_str());
    if (toml_result.is_err()) {
        ret err[Config, str](toml_result.unwrap_err());
    }

    val root:           TomlValue                   = toml_result.unwrap_ok();
    val root_table_opt: Option[*List[TomlProperty]] = root.as_table();
    if (root_table_opt.is_none()) {
        root.dnit();
        ret err[Config, str]("invalid config: expected table at root");
    }
    
    val root_table: *List[TomlProperty] = root_table_opt.unwrap();
    
    var project_section_seen: bool = false;

    val deps_prefix:    str   = "deps.";
    val deps_prefix_len:usize = deps_prefix.len;
    val targets_prefix: str   = "targets.";
    val prefix_len:     usize = targets_prefix.len;

    var i: usize = 0;
    for (i < root_table.len) {
        val prop_opt: Option[TomlProperty] = root_table.get(i);
        if (prop_opt.is_none()) {
            i = i + 1;
            cnt;
        }

        val prop: TomlProperty = prop_opt.unwrap();

        if (prop.key.equals("project")) {
            if (project_section_seen) {
                ret config_error(?config, "duplicate [project] section");
            }

            val project_table_opt: Option[*List[TomlProperty]] = prop.value.as_table();
            if (project_table_opt.is_none()) {
                ret config_error(?config, "[project] must be a table");
            }

            val project_res: Result[bool, str] = parse_project_section(?config, project_table_opt.unwrap());
            if (project_res.is_err()) {
                ret config_error(?config, project_res.unwrap_err());
            }

            project_section_seen = true;
            i = i + 1;
            cnt;
        }

        if (prop.key.equals("deps")) {
            val deps_table_opt: Option[*List[TomlProperty]] = prop.value.as_table();
            if (deps_table_opt.is_none()) {
                ret config_error(?config, "[deps] must be a table");
            }

            val deps_res: Result[bool, str] = parse_dependencies_section(?config, deps_table_opt.unwrap());
            if (deps_res.is_err()) {
                ret config_error(?config, deps_res.unwrap_err());
            }

            i = i + 1;
            cnt;
        }

        if (prop.key.starts_with(deps_prefix)) {
            val deps_table_opt: Option[*List[TomlProperty]] = prop.value.as_table();
            if (deps_table_opt.is_none()) {
                ret config_error(?config, "dependency entry must be a table");
            }

            val dep_name_opt: Option[str] = prop.key.substring(deps_prefix_len, prop.key.len);
            if (dep_name_opt.is_none()) {
                ret config_error(?config, "invalid dependency name");
            }

            val dep_name: str = dep_name_opt.unwrap();
            if (dep_name.len == 0) {
                ret config_error(?config, "dependency name cannot be empty");
            }

            val dep_res: Result[ConfigDependency, str] = parse_dependency(dep_name, deps_table_opt.unwrap());
            if (dep_res.is_err()) {
                ret config_error(?config, dep_res.unwrap_err());
            }

            val push_err: Option[str] = config.dependency_add(dep_res.unwrap_ok());
            if (push_err.is_some()) {
                ret config_error(?config, push_err.unwrap());
            }

            i = i + 1;
            cnt;
        }

        if (prop.key.starts_with(targets_prefix)) {
            val target_table_opt: Option[*List[TomlProperty]] = prop.value.as_table();
            if (target_table_opt.is_none()) {
                ret config_error(?config, "target entry must be a table");
            }

            val name_opt: Option[str] = prop.key.substring(prefix_len, prop.key.len);
            if (name_opt.is_none()) {
                ret config_error(?config, "invalid target name");
            }

            var target_name: str = name_opt.unwrap();

            val target_res: Result[ConfigTarget, str] = parse_target(target_name, target_table_opt.unwrap());
            if (target_res.is_err()) {
                ret config_error(?config, target_res.unwrap_err());
            }

            val push_err: Option[str] = config.target_add(target_res.unwrap_ok());
            if (push_err.is_some()) {
                ret config_error(?config, push_err.unwrap());
            }

            i = i + 1;
            cnt;
        }

        i = i + 1;
    }

    if (project_section_seen == false) {
        ret config_error(?config, "missing [project] section");
    }

    if (config.targets.len == 0) {
        ret config_error(?config, "project configuration missing targets");
    }

    ret ok[Config, str](config);
}
