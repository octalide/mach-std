use std.types.list;
use std.types.size;
use std.types.option;
use std.types.result;
use std.types.string;

use std.lang.frontend.lexical.tokens;
use std.lang.frontend.syntax.ast;

use mem: std.system.memory;

pub rec Module {
    id:     String;        # fully qualified module ID (e.g "std.types.bool")
    path:   String;        # filesystem path to module root
    source: String;        # source code of the module

    tokens: Option[List[Token]]; # token list after lexical analysis
    ast:    Option[AST];        # AST after syntax analysis
}

pub rec ModuleImport {
    path:  str;
    token: Token;
}

pub fun (this: *Module) init(id: str, path: str, source: str) Option[str] {
    mem.zero[Module](this, 1);

    val res_clone_id: Result[String, str] = id.clone();
    if (res_clone_id.is_err()) {
        ret some[str]("failed to clone module ID");
    }
    this.id = res_clone_id.unwrap_ok();

    val res_clone_path: Result[String, str] = path.clone();
    if (res_clone_path.is_err()) {
        this.id.dnit();
        ret some[str]("failed to clone module path");
    }
    this.path = res_clone_path.unwrap_ok();

    val res_clone_source: Result[String, str] = source.clone();
    if (res_clone_source.is_err()) {
        this.path.dnit();
        this.id.dnit();
        ret some[str]("failed to clone module source");
    }
    this.source = res_clone_source.unwrap_ok();

    this.tokens = none[List[Token]]();
    this.ast    = none[AST]();

    ret none[str]();
}

pub fun (this: *Module) dnit() {
    this.id.dnit();
    this.path.dnit();
    this.source.dnit();

    if (this.tokens.is_some()) {
        var tokens: List[Token] = this.tokens.unwrap();
        tokens.dnit();
        this.tokens = none[List[Token]]();
    }

    if (this.ast.is_some()) {
        var ast: AST = this.ast.unwrap();
        ast.dnit();
        this.ast = none[AST]();
    }

    mem.zero[Module](this, 1);
}

pub fun (this: *Module) extract_imports() Result[List[ModuleImport], str] {
    var imports:  List[ModuleImport];
    val opt_init: Option[str] = imports.init(4);
    if (opt_init.is_some()) {
        ret err[List[ModuleImport], str]("failed to initialize imports list");
    }

    if (this.ast.is_none()) {
        imports.dnit();
        ret err[List[ModuleImport], str]("AST is not available");
    }

    val ast: AST = this.ast.unwrap();
    var opt_find: Option[List[*Node]] = ast.find(NODE_USE);
    if (opt_find.is_none()) {
        imports.dnit();
        ret err[List[ModuleImport], str]("failed to find use nodes in AST");
    }

    var use_nodes: List[*Node] = opt_find.unwrap();

    var i: usize = 0;
    for (i < use_nodes.len) {
        val opt_node: Option[*Node] = use_nodes.get(i);
        if (opt_node.is_none()) {
            imports.dnit();
            use_nodes.dnit();
            ret err[List[ModuleImport], str]("failed to get use node from list");
        }
        
        val use_node: *Node = opt_node.unwrap();

        var import: ModuleImport;
        import.path  = use_node.data.decl_use.path;
        import.token = use_node.token;

        val opt_push: Option[str] = imports.push(import);
        if (opt_push.is_some()) {
            imports.dnit();
            use_nodes.dnit();
            ret err[List[ModuleImport], str]("failed to push module import to list");
        }
        i = i + 1;
    }

    use_nodes.dnit();

    ret ok[List[ModuleImport], str](imports);
}
