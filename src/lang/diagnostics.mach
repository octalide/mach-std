use          std.types.bool;
use          std.types.option;
use 		 std.types.result;
use          std.types.size;
use          std.types.string;
use console: std.io.console;
use mem:     std.system.memory;

use std.lang.frontend.lexical.tokens;

pub def DiagnosticLevel:    char;
pub val DIAGNOSTIC_INFO:    DiagnosticLevel = 0;
pub val DIAGNOSTIC_WARNING: DiagnosticLevel = 1;
pub val DIAGNOSTIC_ERROR:   DiagnosticLevel = 2;

pub fun (this: DiagnosticLevel) name() str {
	if (this == DIAGNOSTIC_INFO)    { ret "info"; }
    if (this == DIAGNOSTIC_WARNING) { ret "warning"; }
    if (this == DIAGNOSTIC_ERROR)   { ret "error"; }
	ret "unknown";
}

pub rec Diagnostic {
    level:   DiagnosticLevel;
    token:   Token;
    message: String;
}

pub fun diag_make(level: DiagnosticLevel, token: Token, message: str) Diagnostic {
	var diag: Diagnostic;
	diag.level = level;
	diag.token = token;

	val res_clone_msg: Result[String, str] = message.clone();
	if (res_clone_msg.is_err()) {
		diag.message = String{ nil, 0 };
	}
	or {
		diag.message = res_clone_msg.unwrap_ok();
	}

	ret diag;
}

pub fun (this: *Diagnostic) dnit() {
	this.message.dnit();
	mem.zero[Diagnostic](this, 1);
}

# format and print a single diagnostic
pub fun (this: Diagnostic) print(source: str, file_path: str) {
	# determine severity prefix
	val prefix:      str = this.level.name();
	
	# print main diagnostic line
	console.print("%s:%d:%d: %s: %s\n", 
		file_path, 
		this.token.row, 
		this.token.col, 
		prefix,
		this.message);
	
	# extract and print the source line if possible
	val line_opt: Option[str] = none[str]();
	if (source.data != nil && source.len > 0) {
		line_opt = extract_source_line(source, this.token.row);
	}

	# handles both empty source from caller and missing line
	if (line_opt.is_some()) {
		val line: str = line_opt.unwrap();
		console.print("  %s\n", line);
		print_caret_line(this.token.col, this.token.len);
	}
	or {
		console.print("  <source unavailable>\n");
	}
}

# extract a specific line from source code
fun extract_source_line(source: str, line_num: usize) Option[str] {
	if (source.data == nil || line_num == 0) {
		ret none[str]();
	}
	
	var current_line: usize = 1;
	var line_start:   usize = 0;
	var i:            usize = 0;
	
	# find the line
	for (i < source.len) {
		val ch: char = @(source.data + i);
		
		if (current_line == line_num && ch == '\n') {
			# found the end of our target line
			val line_len: usize = i - line_start;
			ret some[str](str{ (source.data + line_start), line_len });
		}
		
		if (ch == '\n') {
			current_line = current_line + 1;
			line_start = i + 1;
		}
		
		i = i + 1;
	}
	
	# handle last line without newline
	if (current_line == line_num) {
		val line_len: usize = source.len - line_start;
		ret some[str](str{ (source.data + line_start), line_len });
	}
	
	ret none[str]();
}

# print caret indicator line
fun print_caret_line(column: usize, length: usize) {
	console.print("  ");
	
	# print spaces up to the column
	var i: usize = 1;
	for (i < column) {
		console.print(" ");
		i = i + 1;
	}
	
	# print carets
	var caret_len: usize = length;
	if (caret_len == 0) {
		caret_len = 1;
	}
	
	i = 0;
	for (i < caret_len) {
		console.print("^");
		i = i + 1;
	}
	
	console.print("\n");
}
