use          std.types.option;
use          std.types.result;
use          std.types.size;
use          std.types.string;
use std.io.path;
use mem:     std.system.memory;

use std.lang.config;
use std.lang.driver.pipeline;

pub rec Options {
    config:       Config;
    config_path:  Path;
    project_root: Path;
    pipeline:     PipelineOptions;
}

pub fun (this: *Options) init() {
    mem.zero[Options](this, 1);
}

pub fun (this: *Options) dnit() {
    this.config.dnit();
    this.config_path.dnit();
    this.project_root.dnit();
    mem.zero[Options](this, 1);
}

fun options_find_target(config: *Config) Option[*ConfigTarget] {
    if (config == nil || config.targets.data == nil || config.targets.len == 0) {
        ret none[*ConfigTarget]();
    }

    var selection: str = config.target;
    if (selection.data == nil || selection.len == 0) {
        ret some[*ConfigTarget](config.targets.data);
    }

    var i: usize = 0;
    for (i < config.targets.len) {
        val candidate: *ConfigTarget = config.targets.data + i;
        if (candidate.name.equals(selection)) {
            ret some[*ConfigTarget](candidate);
        }
        i = i + 1;
    }

    ret none[*ConfigTarget]();
}

pub fun options_selected_target(options: *Options) Option[*ConfigTarget] {
    if (options == nil) {
        ret none[*ConfigTarget]();
    }

    ret options_find_target(?options.config);
}

pub fun options_refresh_pipeline(options: *Options) Option[str] {
    if (options == nil) {
        ret some[str]("invalid build options");
    }

    val target_opt: Option[*ConfigTarget] = options_selected_target(options);
    if (target_opt.is_none()) {
        ret some[str]("selected target not found in configuration");
    }

    val selected: *ConfigTarget = target_opt.unwrap();
    var pipeline: PipelineOptions = pipeline_options_default();
    pipeline.target_mode     = selected.mode;
    pipeline.target_debug    = selected.debug;
    pipeline.target_optimize = selected.optimize;

    options.pipeline = pipeline;

    ret none[str]();
}

pub fun options_from_config(config_path: *Path, project_root: *Path, config: *Config) Result[Options, str] {
    if (config == nil) {
        ret err[Options, str]("invalid project config");
    }

    if (config_path == nil || config_path.data == nil || config_path.len == 0) {
        ret err[Options, str]("invalid config path");
    }

    if (project_root == nil || project_root.data == nil || project_root.len == 0) {
        ret err[Options, str]("invalid project root");
    }

    val target_opt: Option[*ConfigTarget] = options_find_target(config);
    if (target_opt.is_none()) {
        ret err[Options, str]("selected target not found in configuration");
    }

    val selected: *ConfigTarget = target_opt.unwrap();
    var pipeline: PipelineOptions = pipeline_options_default();
    pipeline.target_mode     = selected.mode;
    pipeline.target_debug    = selected.debug;
    pipeline.target_optimize = selected.optimize;

    var options: Options;
    mem.zero[Options](?options, 1);

    options.pipeline = pipeline;

    options.config = @config;
    mem.zero[Config](config, 1);

    options.config_path = @config_path;
    mem.zero[Path](config_path, 1);

    options.project_root = @project_root;
    mem.zero[Path](project_root, 1);

    ret ok[Options, str](options);
}
