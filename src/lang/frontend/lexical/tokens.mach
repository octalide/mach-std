use std.types.bool;
use std.types.option;
use std.types.size;
use std.types.string;

pub def TokenKind: u16;

pub val TOKEN_EOF:     TokenKind = $iota();
pub val TOKEN_COMMENT: TokenKind = $iota();

pub val TOKEN_LIT_INT:    TokenKind = $iota();
pub val TOKEN_LIT_FLOAT:  TokenKind = $iota();
pub val TOKEN_LIT_CHAR:   TokenKind = $iota();
pub val TOKEN_LIT_STRING: TokenKind = $iota();

pub val TOKEN_IDENTIFIER: TokenKind = $iota();

pub val TOKEN_KW_USE: TokenKind = $iota();
pub val TOKEN_KW_EXT: TokenKind = $iota();
pub val TOKEN_KW_DEF: TokenKind = $iota();
pub val TOKEN_KW_PUB: TokenKind = $iota();
pub val TOKEN_KW_REC: TokenKind = $iota();
pub val TOKEN_KW_UNI: TokenKind = $iota();
pub val TOKEN_KW_VAL: TokenKind = $iota();
pub val TOKEN_KW_VAR: TokenKind = $iota();
pub val TOKEN_KW_FUN: TokenKind = $iota();
pub val TOKEN_KW_RET: TokenKind = $iota();
pub val TOKEN_KW_IF:  TokenKind = $iota();
pub val TOKEN_KW_OR:  TokenKind = $iota();
pub val TOKEN_KW_FOR: TokenKind = $iota();
pub val TOKEN_KW_CNT: TokenKind = $iota();
pub val TOKEN_KW_BRK: TokenKind = $iota();
pub val TOKEN_KW_ASM: TokenKind = $iota();
pub val TOKEN_KW_NIL: TokenKind = $iota();

pub val TOKEN_L_PAREN:    TokenKind = $iota();
pub val TOKEN_R_PAREN:    TokenKind = $iota();
pub val TOKEN_L_BRACKET:  TokenKind = $iota();
pub val TOKEN_R_BRACKET:  TokenKind = $iota();
pub val TOKEN_L_BRACE:    TokenKind = $iota();
pub val TOKEN_R_BRACE:    TokenKind = $iota();
pub val TOKEN_COLON:      TokenKind = $iota();
pub val TOKEN_SEMICOLON:  TokenKind = $iota();
pub val TOKEN_QUESTION:   TokenKind = $iota();
pub val TOKEN_AT:         TokenKind = $iota();
pub val TOKEN_DOLLAR:     TokenKind = $iota();
pub val TOKEN_DOT:        TokenKind = $iota();
pub val TOKEN_COMMA:      TokenKind = $iota();
pub val TOKEN_UNDERSCORE: TokenKind = $iota();
pub val TOKEN_ELLIPSIS:   TokenKind = $iota();

pub val TOKEN_PLUS:      TokenKind = $iota();
pub val TOKEN_MINUS:     TokenKind = $iota();
pub val TOKEN_STAR:      TokenKind = $iota();
pub val TOKEN_PERCENT:   TokenKind = $iota();
pub val TOKEN_CARET:     TokenKind = $iota();
pub val TOKEN_AMPERSAND: TokenKind = $iota();
pub val TOKEN_PIPE:      TokenKind = $iota();
pub val TOKEN_TILDE:     TokenKind = $iota();
pub val TOKEN_LESS:      TokenKind = $iota();
pub val TOKEN_GREATER:   TokenKind = $iota();
pub val TOKEN_EQUAL:     TokenKind = $iota();
pub val TOKEN_BANG:      TokenKind = $iota();
pub val TOKEN_SLASH:     TokenKind = $iota();

pub val TOKEN_EQUAL_EQUAL:         TokenKind = $iota();
pub val TOKEN_BANG_EQUAL:          TokenKind = $iota();
pub val TOKEN_LESS_EQUAL:          TokenKind = $iota();
pub val TOKEN_GREATER_EQUAL:       TokenKind = $iota();
pub val TOKEN_LESS_LESS:           TokenKind = $iota();
pub val TOKEN_GREATER_GREATER:     TokenKind = $iota();
pub val TOKEN_AMPERSAND_AMPERSAND: TokenKind = $iota();
pub val TOKEN_PIPE_PIPE:           TokenKind = $iota();
pub val TOKEN_COLON_COLON:         TokenKind = $iota();

pub val TOKEN_ERROR: TokenKind = $max(TokenKind);

pub rec Token {
    kind:   TokenKind;
    module_id: str;

    pos: usize;
    len: usize;
    row: usize;
    col: usize;
}

pub fun (this: Token) is(kind: TokenKind) bool {
    ret this.kind == kind;
}

pub fun (this: Token) is_any(kind_a: TokenKind, kind_b: TokenKind) bool {
    ret (this.kind == kind_a) || (this.kind == kind_b);
}

pub fun (this: Token) is_empty() bool {
    ret this.len == 0;
}

pub fun (this: Token) end() usize {
    ret this.pos + this.len;
}

pub fun (this: Token) overlaps(other: Token) bool {
    if (this.is_empty() || other.is_empty()) {
        ret false;
    }

    ret (this.pos < other.pos + other.len)
        && (other.pos < this.pos + this.len);
}

pub fun (this: TokenKind) to_string() str {
    if (this == TOKEN_ERROR)   { ret "error"; }
    if (this == TOKEN_EOF)     { ret "eof"; }
    if (this == TOKEN_COMMENT) { ret "comment"; }

    if (this == TOKEN_LIT_INT)    { ret "lit_int"; }
    if (this == TOKEN_LIT_FLOAT)  { ret "lit_float"; }
    if (this == TOKEN_LIT_CHAR)   { ret "lit_char"; }
    if (this == TOKEN_LIT_STRING) { ret "lit_string"; }

    if (this == TOKEN_IDENTIFIER) { ret "identifier"; }

    if (this == TOKEN_KW_USE) { ret "use"; }
    if (this == TOKEN_KW_EXT) { ret "ext"; }
    if (this == TOKEN_KW_DEF) { ret "def"; }
    if (this == TOKEN_KW_PUB) { ret "pub"; }
    if (this == TOKEN_KW_REC) { ret "rec"; }
    if (this == TOKEN_KW_UNI) { ret "uni"; }
    if (this == TOKEN_KW_VAL) { ret "val"; }
    if (this == TOKEN_KW_VAR) { ret "var"; }
    if (this == TOKEN_KW_FUN) { ret "fun"; }
    if (this == TOKEN_KW_RET) { ret "ret"; }
    if (this == TOKEN_KW_IF)  { ret "if"; }
    if (this == TOKEN_KW_OR)  { ret "or"; }
    if (this == TOKEN_KW_FOR) { ret "for"; }
    if (this == TOKEN_KW_CNT) { ret "cnt"; }
    if (this == TOKEN_KW_BRK) { ret "brk"; }
    if (this == TOKEN_KW_ASM) { ret "asm"; }
    if (this == TOKEN_KW_NIL) { ret "nil"; }

    if (this == TOKEN_L_PAREN)    { ret "("; }
    if (this == TOKEN_R_PAREN)    { ret ")"; }
    if (this == TOKEN_L_BRACKET)  { ret "["; }
    if (this == TOKEN_R_BRACKET)  { ret "]"; }
    if (this == TOKEN_L_BRACE)    { ret "{"; }
    if (this == TOKEN_R_BRACE)    { ret "}"; }
    if (this == TOKEN_COLON)      { ret ":"; }
    if (this == TOKEN_SEMICOLON)  { ret ";"; }
    if (this == TOKEN_QUESTION)   { ret "?"; }
    if (this == TOKEN_AT)         { ret "@"; }
    if (this == TOKEN_DOLLAR)     { ret "$"; }
    if (this == TOKEN_DOT)        { ret "."; }
    if (this == TOKEN_COMMA)      { ret ","; }
    if (this == TOKEN_UNDERSCORE) { ret "_"; }
    if (this == TOKEN_ELLIPSIS)   { ret "..."; }

    if (this == TOKEN_PLUS)      { ret "+"; }
    if (this == TOKEN_MINUS)     { ret "-"; }
    if (this == TOKEN_STAR)      { ret "*"; }
    if (this == TOKEN_PERCENT)   { ret "%"; }
    if (this == TOKEN_CARET)     { ret "^"; }
    if (this == TOKEN_AMPERSAND) { ret "&"; }
    if (this == TOKEN_PIPE)      { ret "|"; }
    if (this == TOKEN_TILDE)     { ret "~"; }
    if (this == TOKEN_LESS)      { ret "<"; }
    if (this == TOKEN_GREATER)   { ret ">"; }
    if (this == TOKEN_EQUAL)     { ret "="; }
    if (this == TOKEN_BANG)      { ret "!"; }
    if (this == TOKEN_SLASH)     { ret "/"; }

    if (this == TOKEN_EQUAL_EQUAL)         { ret "=="; }
    if (this == TOKEN_BANG_EQUAL)          { ret "!="; }
    if (this == TOKEN_LESS_EQUAL)          { ret "<="; }
    if (this == TOKEN_GREATER_EQUAL)       { ret ">="; }
    if (this == TOKEN_LESS_LESS)           { ret "<<"; }
    if (this == TOKEN_GREATER_GREATER)     { ret ">>"; }
    if (this == TOKEN_AMPERSAND_AMPERSAND) { ret "&&"; }
    if (this == TOKEN_PIPE_PIPE)           { ret "||"; }
    if (this == TOKEN_COLON_COLON)         { ret "::"; }

    ret "unknown";
}
