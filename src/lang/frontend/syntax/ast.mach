use std.types.bool;
use std.types.size;
use std.types.list;
use std.types.string;
use std.types.result;
use std.types.option;

use std.lang.frontend.lexical.tokens;

pub val AST_CAP_BASE: usize = 16;

pub def NodeID:          usize;
pub val NODE_ID_INVALID: NodeID = $max(usize);

pub fun (this: NodeID) is_valid() bool {
    ret this != NODE_ID_INVALID;
}

pub def ListID:          usize;
pub val LIST_ID_INVALID: ListID = $max(usize);

pub fun (this: ListID) is_valid() bool {
    ret this != LIST_ID_INVALID;
}

pub def NodeKind: u8;

# top-level declarations
pub val NODE_UNKNOWN: NodeKind = 0;
pub val NODE_MODULE:  NodeKind = 1;
pub val NODE_USE:     NodeKind = 2;
pub val NODE_EXT:     NodeKind = 3;
pub val NODE_DEF:     NodeKind = 4;
pub val NODE_VAL:     NodeKind = 5;
pub val NODE_VAR:     NodeKind = 6;
pub val NODE_FUN:     NodeKind = 7;
pub val NODE_REC:     NodeKind = 8;
pub val NODE_UNI:     NodeKind = 9;

# statements
pub val NODE_BLOCK: NodeKind = 10;
pub val NODE_IF:    NodeKind = 11;
pub val NODE_OR:    NodeKind = 12;
pub val NODE_FOR:   NodeKind = 13;
pub val NODE_RET:   NodeKind = 14;
pub val NODE_BRK:   NodeKind = 15;
pub val NODE_CNT:   NodeKind = 16;
pub val NODE_ASM:   NodeKind = 17;
pub val NODE_EXPR:  NodeKind = 18;

# declarations and components
pub val NODE_FIELD:      NodeKind = 19;
pub val NODE_PARAM:      NodeKind = 20;
pub val NODE_RECEIVER:   NodeKind = 21;
pub val NODE_TYPE_PARAM: NodeKind = 22;

# expressions
pub val NODE_IDENT:         NodeKind = 23;
pub val NODE_LITERAL:       NodeKind = 24;
pub val NODE_BINARY:        NodeKind = 25;
pub val NODE_UNARY:         NodeKind = 26;
pub val NODE_CALL:          NodeKind = 27;
pub val NODE_INDEX:         NodeKind = 28;
pub val NODE_MEMBER:        NodeKind = 29;
pub val NODE_CAST:          NodeKind = 30;
pub val NODE_LIT_ARRAY:     NodeKind = 31;
pub val NODE_LIT_REC:       NodeKind = 32;
pub val NODE_LIT_REC_FIELD: NodeKind = 33;
pub val NODE_LIT_UNI:       NodeKind = 34;
pub val NODE_LIT_UNI_FIELD: NodeKind = 35;

# types
pub val NODE_TYPE_NAME:  NodeKind = 36;
pub val NODE_TYPE_PTR:   NodeKind = 37;
pub val NODE_TYPE_ARRAY: NodeKind = 38;
pub val NODE_TYPE_FUN:   NodeKind = 39;
pub val NODE_TYPE_REC:   NodeKind = 40;
pub val NODE_TYPE_UNI:   NodeKind = 41;

# compile-time
pub val NODE_COMPTIME:    NodeKind = 42;
pub val NODE_COMPTIME_IF: NodeKind = 43;
pub val NODE_COMPTIME_OR: NodeKind = 44;

# special nodes
pub val NODE_COMMENT: NodeKind = $max(u8) - 1;
pub val NODE_ERROR:   NodeKind = $max(u8);

pub def NodeLiteralKind: u8;
pub val LIT_KIND_SINT:   NodeLiteralKind = 0;
pub val LIT_KIND_UINT:   NodeLiteralKind = 1;
pub val LIT_KIND_FLOAT:  NodeLiteralKind = 2;
pub val LIT_KIND_CHAR:   NodeLiteralKind = 3;
pub val LIT_KIND_STRING: NodeLiteralKind = 4;

pub rec NodeModule {
    items: ListID;
}

pub rec NodeUse {
    is_public: bool;
    alias:     Option[str];
    path:      str;
}

pub rec NodeExt {
    is_public:  bool;
    convention: Option[str]; # e.g "C"
    symbol:     Option[str]; # optional external symbol name if it differs from the declared name
    name:       str;
    type:       NodeID;
}

pub rec NodeDef {
    is_public: bool;
    name:      str;
    type:      NodeID;
}

pub rec NodeVal {
    is_public: bool;
    name:      str;
    type:      NodeID;
    init:      NodeID;
}

pub rec NodeVar {
    is_public: bool;
    name:      str;
    type:      NodeID;
    init:      Option[NodeID];
}

pub rec NodeFun {
    is_public:   bool;
    name:        str;
    receiver:    Option[NodeID];
    type_params: ListID;
    params:      ListID;
    return_type: Option[NodeID];
    body:        Option[NodeID];
}

pub rec NodeRec {
    is_public:   bool;
    name:        str;
    type_params: ListID;
    fields:      ListID;
}

pub rec NodeUni {
    is_public:   bool;
    name:        str;
    type_params: ListID;
    fields:      ListID;
}

pub rec NodeBlock {
    statements: ListID;
}

pub rec NodeIf {
    condition: NodeID;
    body:      NodeID;
    else:      Option[NodeID];
}

pub rec NodeOr {
    condition: Option[NodeID];
    body:      NodeID;
    else:      Option[NodeID];
}

pub rec NodeFor {
    condition: Option[NodeID];
    body:      NodeID;
}

pub rec NodeRet {
    value: Option[NodeID];
}

pub rec NodeBrk {
}

pub rec NodeCnt {
}

pub rec NodeAsm {
    body: str;
}

pub rec NodeExpr {
    expr: NodeID;
}

pub rec NodeField {
    name: str;
    type: NodeID;
}

pub rec NodeParam {
    name: str;
    type: NodeID;
}

pub rec NodeReceiver {
    name: str;
    type: NodeID;
}

pub rec NodeTypeParam {
    name: str;
}

pub rec NodeIdent {
    name: str;
}

pub rec NodeLiteral {
    kind:  NodeLiteralKind;
    value: uni {
        val_i: i64;
        val_u: u64;
        val_f: f64;
        val_c: u8;
        val_s: str;
    }
}

pub rec NodeBinary {
    op:  TokenKind;
    lhs: NodeID;
    rhs: NodeID;
}

pub rec NodeUnary {
    is_prefix: bool;
    op:        TokenKind;
    expr:      NodeID;
}

pub rec NodeCall {
    callee:    NodeID;
    type_args: ListID;
    args:      ListID;
}

pub rec NodeIndex {
    target: NodeID;
    index:  NodeID;
}

pub rec NodeMember {
    object: NodeID;
    member: str;
}

pub rec NodeCast {
    expr: NodeID;
    type: NodeID;
}

pub rec NodeLitArray {
    type:     NodeID;
    elements: ListID;
}

pub rec NodeLitRec {
    type:   NodeID;
    fields: ListID;
}

pub rec NodeLitRecField {
    name:  str;
    value: NodeID;
}

pub rec NodeLitUni {
    type:  NodeID;
    field: NodeID;
}

pub rec NodeLitUniField {
    name:  str;
    value: NodeID;
}

pub rec NodeTypeName {
    module:    Option[str];
    name:      str;
    type_args: ListID;
}

pub rec NodeTypePtr {
    base: NodeID;
}

pub rec NodeTypeArray {
    base:     NodeID;
    size:     Option[NodeID];  # compile-time expression for size, or None for slice
    is_slice: bool;
}

pub rec NodeTypeFun {
    type_params: ListID;
    params:      ListID;
    return_type: Option[NodeID];
}

pub rec NodeTypeRec {
    fields: ListID;
}

pub rec NodeTypeUni {
    fields: ListID;
}

pub rec NodeComptime {
    expr: NodeID;
}

pub rec NodeComptimeIf {
    condition: NodeID;
    body:      NodeID;
    else:      Option[NodeID];
}

pub rec NodeComptimeOr {
    condition: Option[NodeID];
    body:      NodeID;
    else:      Option[NodeID];
}

pub uni NodeData {
    module:        NodeModule;
    decl_use:      NodeUse;
    decl_ext:      NodeExt;
    decl_def:      NodeDef;
    decl_val:      NodeVal;
    decl_var:      NodeVar;
    decl_fun:      NodeFun;
    decl_rec:      NodeRec;
    decl_uni:      NodeUni;
    stmt_block:    NodeBlock;
    stmt_if:       NodeIf;
    stmt_or:       NodeOr;
    stmt_for:      NodeFor;
    stmt_ret:      NodeRet;
    stmt_brk:      NodeBrk;
    stmt_cnt:      NodeCnt;
    stmt_asm:      NodeAsm;
    stmt_expr:     NodeExpr;
    decl_field:    NodeField;
    decl_param:    NodeParam;
    decl_receiver: NodeReceiver;
    decl_type_param: NodeTypeParam;
    expr_ident:    NodeIdent;
    expr_literal:  NodeLiteral;
    expr_binary:   NodeBinary;
    expr_unary:    NodeUnary;
    expr_call:     NodeCall;
    expr_index:    NodeIndex;
    expr_member:   NodeMember;
    expr_cast:     NodeCast;
    expr_lit_array: NodeLitArray;
    expr_lit_rec:  NodeLitRec;
    expr_lit_rec_field: NodeLitRecField;
    expr_lit_uni:  NodeLitUni;
    expr_lit_uni_field: NodeLitUniField;
    type_name:     NodeTypeName;
    type_ptr:      NodeTypePtr;
    type_array:    NodeTypeArray;
    type_fun:      NodeTypeFun;
    type_rec:      NodeTypeRec;
    type_uni:      NodeTypeUni;
    comptime:      NodeComptime;
    comptime_if:   NodeComptimeIf;
    comptime_or:   NodeComptimeOr;
}

pub rec Node {
    id:    NodeID;
    kind:  NodeKind;
    token: Token;
    data:  NodeData;
}

pub rec AST {
    root:  NodeID;
    nodes: List[Node];
    lists: List[List[NodeID]];  # arena for all node lists
}

pub fun (this: *AST) init() Option[str] {
    this.root = NODE_ID_INVALID;

    val nodes_err: Option[str] = this.nodes.init(AST_CAP_BASE);
    if (nodes_err.is_some()) {
        ret nodes_err;
    }

    val lists_err: Option[str] = this.lists.init(AST_CAP_BASE);
    if (lists_err.is_some()) {
        this.nodes.dnit();
        ret lists_err;
    }

    ret none[str]();
}

pub fun (this: *AST) dnit() {
    this.root = NODE_ID_INVALID;
    this.nodes.dnit();
    
    # free all allocated lists
    var i: usize = 0;
    for (i < this.lists.len) {
        val list_opt: Option[List[NodeID]] = this.lists.get(i);
        if (list_opt.is_some()) {
            var list: List[NodeID] = list_opt.unwrap();
            list.dnit();
        }
        i = i + 1;
    }

    this.lists.dnit();
}

pub fun ast_make() Result[AST, str] {
    var ast: AST;
    val init_err: Option[str] = ast.init();
    if (init_err.is_some()) {
        ret err[AST, str](init_err.unwrap());
    }

    ret ok[AST, str](ast);
}

pub fun (this: *AST) node_add(node: Node) Result[NodeID, str] {
    val push_err: Option[str] = this.nodes.push(node);
    if (push_err.is_some()) {
        ret err[NodeID, str](push_err.unwrap());
    }

    ret ok[NodeID, str](this.nodes.len - 1);
}

pub fun (this: AST) node_get(id: NodeID) Option[*Node] {
    if (id >= this.nodes.len) {
        ret none[*Node]();
    }
    ret some[*Node](this.nodes.data + id);
}

pub fun (this: *AST) list_add() Result[ListID, str] {
    var new_list_res: Result[List[NodeID], str] = list_new[NodeID](4);
    if (new_list_res.is_err()) {
        ret err[ListID, str](new_list_res.unwrap_err());
    }

    val push_err: Option[str] = this.lists.push(new_list_res.unwrap_ok());
    if (push_err.is_some()) {
        ret err[ListID, str](push_err.unwrap());
    }

    ret ok[ListID, str](this.lists.len - 1);
}

pub fun (this: AST) list_get(id: ListID) Option[*List[NodeID]] {
    if (id >= this.lists.len) {
        ret none[*List[NodeID]]();
    }
    ret some[*List[NodeID]](this.lists.data + id);
}

pub fun (this: *AST) find(kind: NodeKind) Option[List[*Node]] {
    var result_list: List[*Node];
    val init_err: Option[str] = result_list.init(4);
    if (init_err.is_some()) {
        ret none[List[*Node]]();
    }

    var i: usize = 0;
    for (i < this.nodes.len) {
        val node: *Node = this.nodes.data + i;
        if (node.kind == kind) {
            val push_err: Option[str] = result_list.push(node);
            if (push_err.is_some()) {
                result_list.dnit();
                ret none[List[*Node]]();
            }
        }
        i = i + 1;
    }

    ret some[List[*Node]](result_list);
}
