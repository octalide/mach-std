use std.lang.frontend.syntax.ast;
use std.lang.frontend.lexical.tokens;
use std.types.list;
use std.types.option;
use std.types.result;
use std.types.size;
use std.types.bool;
use std.types.string;

use mem: std.system.memory;

pub rec Parser {
    tokens: *List[Token];
    index:  usize;
    ast:    *AST;
}

fun make_sentinel_token() Token {
    var token: Token;

    mem.zero[Token](?token, 1);

    token.kind = TOKEN_EOF;

    ret token;
}

pub fun (this: *Parser) init(tokens: *List[Token], ast: *AST) Option[str] {
    if (tokens == nil || tokens.data == nil) {
        ret some[str]("invalid token list");
    }
    
    if (ast == nil) {
        ret some[str]("invalid ast pointer");
    }

    mem.zero[Parser](this, 1);

    this.tokens = tokens;
    this.index  = 0;
    this.ast    = ast;

    ret none[str]();
}

pub fun (this: *Parser) dnit() {
    this.tokens = nil;
    this.index  = 0;
    this.ast    = nil;
}

# token access
fun (this: *Parser) at_end() bool {
    ret this.index >= this.tokens.len;
}

pub fun (this: *Parser) current() Token {
    if (this.at_end()) {
		ret make_sentinel_token();
    }
    
    val tok_opt: Option[Token] = this.tokens.get(this.index);
    if (tok_opt.is_some()) {
        ret tok_opt.unwrap();
    }
    
	ret make_sentinel_token();
}

fun (this: *Parser) peek(offset: usize) Token {
    val idx: usize = this.index + offset;
    if (idx >= this.tokens.len) {
		ret make_sentinel_token();
    }
    
    val tok_opt: Option[Token] = this.tokens.get(idx);
    if (tok_opt.is_some()) {
        ret tok_opt.unwrap();
    }
    
	ret make_sentinel_token();
}

fun (this: *Parser) advance() Token {
    val tok: Token = this.current();
    if (this.at_end() == false) {
        this.index = this.index + 1;
    }
    ret tok;
}

pub fun (this: *Parser) skip_comments() {
    for (this.at_end() == false) {
        val tok: Token = this.current();
        if (tok.kind != TOKEN_COMMENT) {
            brk;
        }
        this.advance();
    }
}

fun (this: *Parser) expect(kind: TokenKind) Result[Token, str] {
    this.skip_comments();
    val tok: Token = this.current();
    
    if (tok.kind != kind) {
        ret err[Token, str]("unexpected token");
    }
    
    this.advance();
    ret ok[Token, str](tok);
}

fun (this: *Parser) match_token(kind: TokenKind) bool {
    this.skip_comments();
    val tok: Token = this.current();
    ret tok.kind == kind;
}

fun (this: *Parser) consume(kind: TokenKind) bool {
    if (this.match_token(kind)) {
        this.advance();
        ret true;
    }
    ret false;
}

# ast helpers
fun (this: *Parser) make_error_node(message: str) NodeID {
    var node: Node;
    node.id    = NODE_ID_INVALID;
    node.kind  = NODE_ERROR;
    node.token = this.current();
    
    val node_res: Result[NodeID, str] = this.ast.node_add(node);
    if (node_res.is_ok()) {
        ret node_res.unwrap_ok();
    }
    
    ret NODE_ID_INVALID;
}

# parsing entry point
pub fun (this: *Parser) parse_module() Result[AST, str] {
    val items_res: Result[ListID, str] = this.ast.list_add();
    if (items_res.is_err()) {
        ret err[AST, str](items_res.unwrap_err());
    }

    val items_id: ListID = items_res.unwrap_ok();

    # parse top-level declarations
    for (this.at_end() == false) {
        this.skip_comments();
        
        if (this.at_end()) {
            brk;
        }
        
        val tok: Token = this.current();
        if (tok.kind == TOKEN_EOF) {
            brk;
        }
        
        val decl_res: Result[NodeID, str] = this.parse_top_level_decl();
        if (decl_res.is_err()) {
            ret err[AST, str](decl_res.unwrap_err());
        }
        
        val decl_id: NodeID = decl_res.unwrap_ok();
        if (decl_id.is_valid()) {
            val items_opt: Option[*List[NodeID]] = this.ast.list_get(items_id);
            if (items_opt.is_some()) {
                val items_ptr: *List[NodeID] = items_opt.unwrap();
                items_ptr.push(decl_id);
            }
        }
    }

    # create module root node
    this.skip_comments();
    var module_node: Node;
    module_node.id    = NODE_ID_INVALID;
    module_node.kind  = NODE_MODULE;
    module_node.token = this.current();
    module_node.data.module.items = items_id;

    val node_res: Result[NodeID, str] = this.ast.node_add(module_node);
    if (node_res.is_err()) {
        ret err[AST, str](node_res.unwrap_err());
    }

    val module_id: NodeID = node_res.unwrap_ok();
    this.ast.root = module_id;

    ret ok[AST, str](@this.ast);
}

# top-level declarations
fun (this: *Parser) parse_top_level_decl() Result[NodeID, str] {
    this.skip_comments();
    
    val is_public: bool = this.consume(TOKEN_KW_PUB);
    
    val tok: Token = this.current();
    
    if (tok.kind == TOKEN_KW_USE) {
        ret this.parse_use_decl(is_public);
    }
    or (tok.kind == TOKEN_KW_EXT) {
        ret this.parse_ext_decl(is_public);
    }
    or (tok.kind == TOKEN_KW_DEF) {
        ret this.parse_def_decl(is_public);
    }
    or (tok.kind == TOKEN_KW_VAL) {
        ret this.parse_val_decl(is_public);
    }
    or (tok.kind == TOKEN_KW_VAR) {
        ret this.parse_var_decl(is_public);
    }
    or (tok.kind == TOKEN_KW_FUN) {
        ret this.parse_fun_decl(is_public);
    }
    or (tok.kind == TOKEN_KW_REC) {
        ret this.parse_rec_decl(is_public);
    }
    or (tok.kind == TOKEN_KW_UNI) {
        ret this.parse_uni_decl(is_public);
    }
    
    ret err[NodeID, str]("expected declaration");
}

fun (this: *Parser) parse_use_decl(is_public: bool) Result[NodeID, str] {
    ret err[NodeID, str]("use declaration not implemented");
}

fun (this: *Parser) parse_ext_decl(is_public: bool) Result[NodeID, str] {
    ret err[NodeID, str]("ext declaration not implemented");
}

fun (this: *Parser) parse_def_decl(is_public: bool) Result[NodeID, str] {
    ret err[NodeID, str]("def declaration not implemented");
}

fun (this: *Parser) parse_val_decl(is_public: bool) Result[NodeID, str] {
    ret err[NodeID, str]("val declaration not implemented");
}

fun (this: *Parser) parse_var_decl(is_public: bool) Result[NodeID, str] {
    ret err[NodeID, str]("var declaration not implemented");
}

fun (this: *Parser) parse_fun_decl(is_public: bool) Result[NodeID, str] {
    ret err[NodeID, str]("fun declaration not implemented");
}

fun (this: *Parser) parse_rec_decl(is_public: bool) Result[NodeID, str] {
    ret err[NodeID, str]("rec declaration not implemented");
}

fun (this: *Parser) parse_uni_decl(is_public: bool) Result[NodeID, str] {
    ret err[NodeID, str]("uni declaration not implemented");
}
