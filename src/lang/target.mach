use std.types.bool;
use std.types.size;
use std.types.string;

pub rec TargetTriple {
	arch:   str;
	vendor: str;
	system: str;
	abi:    str;
}

pub fun target_native_triple() str {
	ret $target.triple;
}

pub fun target_native_info() TargetTriple {
	ret target_normalize_triple(target_parse_triple($target.triple));
}

pub fun target_parse_triple(value: str) TargetTriple {
	var triple: TargetTriple;

	if (value.data == nil || value.len == 0) {
		ret triple;
	}

	var part_index: usize = 0;
	var start:      usize = 0;
	var i:          usize = 0;

	for (i <= value.len) {
		var is_delimiter: bool = false;
		if (i == value.len) {
			is_delimiter = true;
		}
		or {
			is_delimiter = @(value.data + i) == '-';
		}

		if (is_delimiter) {
			var segment: str;
			segment.data = nil;
			segment.len  = 0;

			if (i > start) {
				segment.data = value.data + start;
				segment.len  = i - start;
			}

			if (part_index == 0) {
				triple.arch = segment;
			}
			or (part_index == 1) {
				triple.vendor = segment;
			}
			or (part_index == 2) {
				triple.system = segment;
			}
			or {
				triple.abi = segment;
			}

			part_index = part_index + 1;
			start      = i + 1;
		}

		i = i + 1;
	}

	ret triple;
}

fun str_is_empty(value: str) bool {
	if (value.data == nil || value.len == 0) {
		ret true;
	}

	ret false;
}

fun is_known_os(value: str) bool {
	if (value.data == nil || value.len == 0) {
		ret false;
	}

	if (value.equals("linux"))  { ret true; }
	if (value.equals("windows")) { ret true; }
	if (value.equals("darwin"))  { ret true; }
	if (value.equals("freebsd")) { ret true; }
	if (value.equals("netbsd"))  { ret true; }
	if (value.equals("openbsd")) { ret true; }
	if (value.equals("android")) { ret true; }
	if (value.equals("ios"))     { ret true; }
	if (value.equals("haiku"))   { ret true; }

	ret false;
}

fun is_known_abi(value: str) bool {
	if (value.data == nil || value.len == 0) {
		ret false;
	}

	if (value.equals("gnu"))        { ret true; }
	if (value.equals("gnueabi"))    { ret true; }
	if (value.equals("gnueabihf"))  { ret true; }
	if (value.equals("musl"))       { ret true; }
	if (value.equals("msvc"))       { ret true; }
	if (value.equals("android"))    { ret true; }
	if (value.equals("androideabi")){ ret true; }
	if (value.equals("eabi"))       { ret true; }
	if (value.equals("elf"))        { ret true; }

	ret false;
}

fun target_normalize_triple(value: TargetTriple) TargetTriple {
	var triple: TargetTriple = value;

	if (str_is_empty(triple.vendor) == false && str_is_empty(triple.system) == false) {
		if (is_known_os(triple.vendor) && is_known_abi(triple.system)) {
			triple.abi    = triple.system;
			triple.system = triple.vendor;
			triple.vendor = str{ nil, 0 };
		}
	}

	if (str_is_empty(triple.system) && is_known_os(triple.vendor)) {
		triple.system = triple.vendor;
		triple.vendor = str{ nil, 0 };
	}

	ret triple;
}

fun is_vendor_generic(value: str) bool {
	if (value.data == nil || value.len == 0) {
		ret true;
	}

	if (value.equals("unknown")) { ret true; }
	if (value.equals("pc"))      { ret true; }
	if (value.equals("generic")) { ret true; }

	ret false;
}

fun segments_match(host: str, want: str) bool {
	if (want.data == nil || want.len == 0) {
		ret true;
	}

	if (host.data == nil || host.len == 0) {
		ret false;
	}

	ret host.equals(want);
}

fun vendor_match(host: str, want: str) bool {
	if (want.data == nil || want.len == 0) {
		ret true;
	}

	if (host.data == nil || host.len == 0) {
		ret false;
	}

	if (host.equals(want)) {
		ret true;
	}

	if (is_vendor_generic(host) && is_vendor_generic(want)) {
		ret true;
	}

	ret false;
}

pub fun target_triple_is_native(candidate: str) bool {
	val host: TargetTriple = target_native_info();
	val want: TargetTriple = target_normalize_triple(target_parse_triple(candidate));

	if (segments_match(host.arch, want.arch) == false) {
		ret false;
	}

	if (segments_match(host.system, want.system) == false) {
		ret false;
	}

	if (vendor_match(host.vendor, want.vendor) == false) {
		ret false;
	}

	if (str_is_empty(want.abi) == false && str_is_empty(host.abi) == false) {
		if (segments_match(host.abi, want.abi) == false) {
			ret false;
		}
	}

	ret true;
}
