use std.types.size;

# register sizes
pub val WORD_SIZE: usize = 8;
pub val PAGE_SIZE: usize = 4096;

# atomic operations are supported with 'a' extension
pub val HAS_ATOMICS: bool = true;

# syscall using ecall instruction
pub fun syscall0(number: u64) u64 {
    var result: u64;
    asm {
        mv a7, %[number]
        ecall
        mv %[result], a0
    }
    ret result;
}

pub fun syscall1(number: u64, arg1: u64) u64 {
    var result: u64;
    asm {
        mv a7, %[number]
        mv a0, %[arg1]
        ecall
        mv %[result], a0
    }
    ret result;
}

pub fun syscall2(number: u64, arg1: u64, arg2: u64) u64 {
    var result: u64;
    asm {
        mv a7, %[number]
        mv a0, %[arg1]
        mv a1, %[arg2]
        ecall
        mv %[result], a0
    }
    ret result;
}

pub fun syscall3(number: u64, arg1: u64, arg2: u64, arg3: u64) u64 {
    var result: u64;
    asm {
        mv a7, %[number]
        mv a0, %[arg1]
        mv a1, %[arg2]
        mv a2, %[arg3]
        ecall
        mv %[result], a0
    }
    ret result;
}

pub fun syscall6(number: u64, arg1: u64, arg2: u64, arg3: u64, arg4: u64, arg5: u64, arg6: u64) u64 {
    var result: u64;
    asm {
        mv a7, %[number]
        mv a0, %[arg1]
        mv a1, %[arg2]
        mv a2, %[arg3]
        mv a3, %[arg4]
        mv a4, %[arg5]
        mv a5, %[arg6]
        ecall
        mv %[result], a0
    }
    ret result;
}

# cpu control
pub fun halt() {
    asm {
        wfi
    }
}

pub fun breakpoint() {
    asm {
        ebreak
    }
}

# memory barriers
pub fun memory_barrier() {
    asm {
        fence rw, rw
    }
}

pub fun load_barrier() {
    asm {
        fence r, rw
    }
}

pub fun store_barrier() {
    asm {
        fence rw, w
    }
}

# atomic operations (requires 'a' extension)
pub fun atomic_cmpxchg_u64(ptr: *u64, expected: u64, desired: u64) u64 {
    var result: u64;
    asm {
        mv t0, %[expected]
        mv t1, %[desired]
    .Lretry:
        lr.d.aq t2, (%[ptr])
        bne t2, t0, .Lfail
        sc.d.rl t3, t1, (%[ptr])
        bnez t3, .Lretry
        mv %[result], t2
        j .Ldone
    .Lfail:
        mv %[result], t2
    .Ldone:
    }
    ret result;
}

pub fun atomic_add_u64(ptr: *u64, value: u64) {
    asm {
        amoadd.d.aqrl zero, %[value], (%[ptr])
    }
}
