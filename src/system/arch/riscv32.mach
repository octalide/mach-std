use std.types.size;

# register sizes
pub val WORD_SIZE: usize = 4;
pub val PAGE_SIZE: usize = 4096;

# atomic operations are supported with 'a' extension
pub val HAS_ATOMICS: bool = true;

# syscall using ecall instruction
pub fun syscall0(number: u32) u32 {
    var result: u32;
    asm {
        mv a7, %[number]
        ecall
        mv %[result], a0
    }
    ret result;
}

pub fun syscall1(number: u32, arg1: u32) u32 {
    var result: u32;
    asm {
        mv a7, %[number]
        mv a0, %[arg1]
        ecall
        mv %[result], a0
    }
    ret result;
}

pub fun syscall2(number: u32, arg1: u32, arg2: u32) u32 {
    var result: u32;
    asm {
        mv a7, %[number]
        mv a0, %[arg1]
        mv a1, %[arg2]
        ecall
        mv %[result], a0
    }
    ret result;
}

pub fun syscall3(number: u32, arg1: u32, arg2: u32, arg3: u32) u32 {
    var result: u32;
    asm {
        mv a7, %[number]
        mv a0, %[arg1]
        mv a1, %[arg2]
        mv a2, %[arg3]
        ecall
        mv %[result], a0
    }
    ret result;
}

# cpu control
pub fun halt() {
    asm {
        wfi
    }
}

pub fun breakpoint() {
    asm {
        ebreak
    }
}

# memory barriers
pub fun memory_barrier() {
    asm {
        fence rw, rw
    }
}

pub fun load_barrier() {
    asm {
        fence r, rw
    }
}

pub fun store_barrier() {
    asm {
        fence rw, w
    }
}

# atomic operations (requires 'a' extension)
pub fun atomic_cmpxchg_u32(ptr: *u32, expected: u32, desired: u32) u32 {
    var result: u32;
    asm {
        mv t0, %[expected]
        mv t1, %[desired]
    .Lretry:
        lr.w.aq t2, (%[ptr])
        bne t2, t0, .Lfail
        sc.w.rl t3, t1, (%[ptr])
        bnez t3, .Lretry
        mv %[result], t2
        j .Ldone
    .Lfail:
        mv %[result], t2
    .Ldone:
    }
    ret result;
}

pub fun atomic_add_u32(ptr: *u32, value: u32) {
    asm {
        amoadd.w.aqrl zero, %[value], (%[ptr])
    }
}
