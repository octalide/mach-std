use std.types.size;

# register sizes
pub val WORD_SIZE: usize = 8;
pub val PAGE_SIZE: usize = 4096;

# atomic operations are supported
pub val HAS_ATOMICS: bool = true;

# syscall instruction for linux/bsd
pub fun syscall0(number: u64) u64 {
    var result: u64;
    asm {
        mov %[number], %rax
        syscall
        mov %rax, %[result]
    }
    ret result;
}

pub fun syscall1(number: u64, arg1: u64) u64 {
    var result: u64;
    asm {
        mov %[number], %rax
        mov %[arg1], %rdi
        syscall
        mov %rax, %[result]
    }
    ret result;
}

pub fun syscall2(number: u64, arg1: u64, arg2: u64) u64 {
    var result: u64;
    asm {
        mov %[number], %rax
        mov %[arg1], %rdi
        mov %[arg2], %rsi
        syscall
        mov %rax, %[result]
    }
    ret result;
}

pub fun syscall3(number: u64, arg1: u64, arg2: u64, arg3: u64) u64 {
    var result: u64;
    asm {
        mov %[number], %rax
        mov %[arg1], %rdi
        mov %[arg2], %rsi
        mov %[arg3], %rdx
        syscall
        mov %rax, %[result]
    }
    ret result;
}

pub fun syscall6(number: u64, arg1: u64, arg2: u64, arg3: u64, arg4: u64, arg5: u64, arg6: u64) u64 {
    var result: u64;
    asm {
        mov %[number], %rax
        mov %[arg1], %rdi
        mov %[arg2], %rsi
        mov %[arg3], %rdx
        mov %[arg4], %r10
        mov %[arg5], %r8
        mov %[arg6], %r9
        syscall
        mov %rax, %[result]
    }
    ret result;
}

# cpu control
pub fun halt() {
    asm {
        hlt
    }
}

pub fun pause() {
    asm {
        pause
    }
}

pub fun breakpoint() {
    asm {
        int3
    }
}

# memory barriers
pub fun memory_barrier() {
    asm {
        mfence
    }
}

pub fun load_barrier() {
    asm {
        lfence
    }
}

pub fun store_barrier() {
    asm {
        sfence
    }
}

# atomic compare and swap
pub fun atomic_cmpxchg_u64(ptr: *u64, expected: u64, desired: u64) u64 {
    var result: u64 = expected;
    asm {
        lock cmpxchg %[desired], (%[ptr])
        mov %rax, %[result]
    }
    ret result;
}

pub fun atomic_add_u64(ptr: *u64, value: u64) {
    asm {
        lock add %[value], (%[ptr])
    }
}
