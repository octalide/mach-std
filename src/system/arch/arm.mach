use std.types.size;

# register sizes
pub val WORD_SIZE: usize = 4;
pub val PAGE_SIZE: usize = 4096;

# atomic operations may require kernel helpers on older ARM
pub val HAS_ATOMICS: bool = false;

# syscall instruction for linux (eabi)
pub fun syscall0(number: u32) u32 {
    var result: u32;
    asm {
        mov r7, %[number]
        svc #0
        mov %[result], r0
    }
    ret result;
}

pub fun syscall1(number: u32, arg1: u32) u32 {
    var result: u32;
    asm {
        mov r7, %[number]
        mov r0, %[arg1]
        svc #0
        mov %[result], r0
    }
    ret result;
}

pub fun syscall2(number: u32, arg1: u32, arg2: u32) u32 {
    var result: u32;
    asm {
        mov r7, %[number]
        mov r0, %[arg1]
        mov r1, %[arg2]
        svc #0
        mov %[result], r0
    }
    ret result;
}

pub fun syscall3(number: u32, arg1: u32, arg2: u32, arg3: u32) u32 {
    var result: u32;
    asm {
        mov r7, %[number]
        mov r0, %[arg1]
        mov r1, %[arg2]
        mov r2, %[arg3]
        svc #0
        mov %[result], r0
    }
    ret result;
}

# cpu control
pub fun halt() {
    asm {
        wfi
    }
}

pub fun yield_cpu() {
    asm {
        yield
    }
}

pub fun breakpoint() {
    asm {
        bkpt #0
    }
}

# memory barriers
pub fun memory_barrier() {
    asm {
        dmb
    }
}

pub fun data_sync_barrier() {
    asm {
        dsb
    }
}

pub fun instruction_sync_barrier() {
    asm {
        isb
    }
}
