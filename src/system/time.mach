use std.types.bool;
use std.types.size;
use std.types.option;
use std.types.result;
use std.types.string;
use std.text.ascii;

$if ($mach.build.target.os.id == $mach.os.linux.id) {
    use ptime: std.system.platform.linux.time;
}

$if ($mach.build.target.os.id == $mach.os.darwin.id) {
    use ptime: std.system.platform.darwin.time;
}

$if ($mach.build.target.os.id == $mach.os.windows.id) {
    use ptime: std.system.platform.windows.time;
}

# duration constants (in nanoseconds)
pub val NANOSECOND:  u64 = 1;
pub val MICROSECOND: u64 = 1000;
pub val MILLISECOND: u64 = 1000000;
pub val SECOND:      u64 = 1000000000;
pub val MINUTE:      u64 = 60000000000;
pub val HOUR:        u64 = 3600000000000;

# duration type (in nanoseconds)
pub def Duration: u64;

# time of day
pub rec Time {
    hour:   u8;  # [0-23]
    minute: u8;  # [0-59]
    second: u8;  # [0-59]
    nano:   u32; # [0-999999999]
}

# calendar date
pub rec Date {
    year:  i32; # full year (e.g., 2025)
    month: u8;  # [1-12]
    day:   u8;  # [1-31]
}

# date and time combined
pub rec DateTime {
    year:   i32;
    month:  u8;
    day:    u8;
    hour:   u8;
    minute: u8;
    second: u8;
    nano:   u32;
}

# month names
pub val MONTH_JANUARY:   u8 = 1;
pub val MONTH_FEBRUARY:  u8 = 2;
pub val MONTH_MARCH:     u8 = 3;
pub val MONTH_APRIL:     u8 = 4;
pub val MONTH_MAY:       u8 = 5;
pub val MONTH_JUNE:      u8 = 6;
pub val MONTH_JULY:      u8 = 7;
pub val MONTH_AUGUST:    u8 = 8;
pub val MONTH_SEPTEMBER: u8 = 9;
pub val MONTH_OCTOBER:   u8 = 10;
pub val MONTH_NOVEMBER:  u8 = 11;
pub val MONTH_DECEMBER:  u8 = 12;

# get monotonic time
pub fun now() Duration {
    ret ptime.monotonic_now();
}

# get wall clock time as nanoseconds since Unix epoch
pub fun unix_nano() i64 {
    ret ptime.realtime_now();
}

# get wall clock time as seconds since Unix epoch
pub fun unix_seconds() i64 {
    ret ptime.realtime_now() / SECOND;
}

# check if a year is a leap year
pub fun is_leap_year(year: i32) bool {
    if (year % 4 != 0) {
        ret false;
    }
    if (year % 100 != 0) {
        ret true;
    }
    if (year % 400 != 0) {
        ret false;
    }
    ret true;
}

# get days in a given month
pub fun days_in_month(year: i32, month: u8) u8 {
    if (month == 2) {
        if (is_leap_year(year)) {
            ret 29;
        }
        ret 28;
    }
    if (month == 4 || month == 6 || month == 9 || month == 11) {
        ret 30;
    }
    ret 31;
}

# convert Unix timestamp (seconds) to DateTime
pub fun from_unix(unix_sec: i64) DateTime {
    var dt: DateTime;
    
    # calculate days since epoch
    var days: i64 = unix_sec / 86400;
    var rem:  i64 = unix_sec % 86400;
    
    # handle negative time
    if (rem < 0) {
        rem  = rem + 86400;
        days = days - 1;
    }
    
    # extract time of day
    dt.hour   = (rem / 3600) :: u8;
    rem       = rem % 3600;
    dt.minute = (rem / 60) :: u8;
    dt.second = (rem % 60) :: u8;
    dt.nano = 0;
    
    # calculate year (simplified algorithm)
    var year:      i32 = 1970;
    var day_count: i64 = days;
    
    # handle negative days (pre-epoch dates)
    if (day_count < 0) {
        # count backwards from 1970
        for (day_count < 0) {
            year = year - 1;
            if (is_leap_year(year)) {
                day_count = day_count + 366;
            }
            or (is_leap_year(year) == false) {
                day_count = day_count + 365;
            }
        }
    }
    or {
        # count forwards from 1970
        # rough year calculation
        var years_approx: i32 = (day_count / 365) :: i32;
        year      = year + years_approx;
        day_count = day_count - (years_approx :: i64) * 365;
        
        # count leap years from 1970 to year
        # leap years: divisible by 4, except centuries unless divisible by 400
        var leap_adjust: i32 = (years_approx + 1) / 4;  # +1 to include 1972 as first leap year
        day_count = day_count - (leap_adjust :: i64);
    }
    
    # fine-tune year
    for (day_count < 0 || day_count >= 365) {
        if (day_count < 0) {
            year = year - 1;
            if (is_leap_year(year)) {
                day_count = day_count + 366;
            }
            or (is_leap_year(year) == false) {
                day_count = day_count + 365;
            }
        }
        or {
            var year_len: i64 = 365;
            if (is_leap_year(year)) {
                year_len = 366;
            }
            if (day_count >= year_len) {
                day_count = day_count - year_len;
                year = year + 1;
            }
            or {
                brk;
            }
        }
    }
    
    dt.year = year;
    
    # calculate month and day
    var month: u8 = 1;
    for (month <= 12) {
        val days_in_this_month: i64 = (days_in_month(year, month)) :: i64;
        if (day_count < days_in_this_month) {
            brk;
        }
        day_count = day_count - days_in_this_month;
        month     = month + 1;
    }
    
    dt.month = month;
    dt.day   = (day_count + 1) :: u8;
    
    ret dt;
}

# get current DateTime
pub fun now_datetime() DateTime {
    val unix_ns:  u64      = ptime.realtime_now();
    val unix_sec: i64      = (unix_ns / SECOND) :: i64;
    var dt:       DateTime = from_unix(unix_sec);
    dt.nano = (unix_ns % SECOND) :: u32;
    ret dt;
}

# create Time from components
pub fun time(hour: u8, minute: u8, second: u8, nano: u32) Time {
    var t: Time;
    t.hour   = hour;
    t.minute = minute;
    t.second = second;
    t.nano   = nano;
    ret t;
}

# create Date from components
pub fun date(year: i32, month: u8, day: u8) Date {
    var d: Date;
    d.year  = year;
    d.month = month;
    d.day   = day;
    ret d;
}

# create DateTime from components
pub fun datetime(year: i32, month: u8, day: u8, hour: u8, minute: u8, second: u8, nano: u32) DateTime {
    var dt: DateTime;
    dt.year   = year;
    dt.month  = month;
    dt.day    = day;
    dt.hour   = hour;
    dt.minute = minute;
    dt.second = second;
    dt.nano   = nano;
    ret dt;
}

# helper: append two-digit number with leading zero
fun append_two_digits(s: *String, value: u8) bool {
    val tens: u8 = value / 10;
    val ones: u8 = value % 10;
    
    if (s.push('0' + tens) == false) { ret false; }
    if (s.push('0' + ones) == false) { ret false; }
    
    ret true;
}

# helper: append four-digit year
fun append_year(s: *String, year: i32) bool {
    if (year < 0) {
        if (s.push('-') == false) {
            ret false;
        }
        year = 0 - year;
    }
    
    val thousands: u8 = ((year / 1000) % 10) :: u8;
    val hundreds:  u8 = ((year / 100) % 10) :: u8;
    val tens:      u8 = ((year / 10) % 10) :: u8;
    val ones:      u8 = (year % 10) :: u8;
    
    if (s.push('0' + thousands) == false) { ret false; }
    if (s.push('0' + hundreds) == false)  { ret false; }
    if (s.push('0' + tens) == false)      { ret false; }
    if (s.push('0' + ones) == false)      { ret false; }
    
    ret true;
}

# format DateTime as ISO 8601 string (YYYY-MM-DDTHH:MM:SS)
pub fun (this: *DateTime) to_iso8601() Result[String, str] {
    var s: String;
    val init_err: Option[str] = s.init(64);
    if (init_err.is_some()) {
        ret err[String, str](init_err.unwrap());
    }
    
    if (append_year(?s, this.year) == false) {
        ret err[String, str]("failed to format year");
    }
    if (s.push('-') == false) {
        ret err[String, str]("failed to format");
    }
    if (append_two_digits(?s, this.month) == false) {
        ret err[String, str]("failed to format month");
    }
    if (s.push('-') == false) {
        ret err[String, str]("failed to format");
    }
    if (append_two_digits(?s, this.day) == false) {
        ret err[String, str]("failed to format day");
    }
    if (s.push('T') == false) {
        ret err[String, str]("failed to format");
    }
    if (append_two_digits(?s, this.hour) == false) {
        ret err[String, str]("failed to format hour");
    }
    if (s.push(':') == false) {
        ret err[String, str]("failed to format");
    }
    if (append_two_digits(?s, this.minute) == false) {
        ret err[String, str]("failed to format minute");
    }
    if (s.push(':') == false) {
        ret err[String, str]("failed to format");
    }
    if (append_two_digits(?s, this.second) == false) {
        ret err[String, str]("failed to format second");
    }
    
    ret ok[String, str](s);
}

# format DateTime as RFC 3339 string with Z suffix (YYYY-MM-DDTHH:MM:SSZ)
pub fun (this: DateTime) to_rfc3339() Result[String, str] {
    val res: Result[String, str] = this.to_iso8601();
    if (res.is_err()) {
        ret res;
    }
    
    var s: String = res.unwrap_ok();
    if (s.push('Z') == false) {
        ret err[String, str]("failed to append Z");
    }
    
    ret ok[String, str](s);
}

# format Time as HH:MM:SS
pub fun (this: Time) to_string() Result[String, str] {
    var s:        String;
    val init_err: Option[str] = s.init(16);
    if (init_err.is_some()) {
        ret err[String, str](init_err.unwrap());
    }
    
    if (append_two_digits(?s, this.hour) == false) {
        ret err[String, str]("failed to format hour");
    }
    if (s.push(':') == false) {
        ret err[String, str]("failed to format");
    }
    if (append_two_digits(?s, this.minute) == false) {
        ret err[String, str]("failed to format minute");
    }
    if (s.push(':') == false) {
        ret err[String, str]("failed to format");
    }
    if (append_two_digits(?s, this.second) == false) {
        ret err[String, str]("failed to format second");
    }
    
    ret ok[String, str](s);
}

# format Date as YYYY-MM-DD
pub fun (this: Date) to_string() Result[String, str] {
    var s:        String;
    val init_err: Option[str] = s.init(16);
    if (init_err.is_some()) {
        ret err[String, str](init_err.unwrap());
    }
    
    if (append_year(?s, this.year) == false) {
        ret err[String, str]("failed to format year");
    }
    if (s.push('-') == false) {
        ret err[String, str]("failed to format");
    }
    if (append_two_digits(?s, this.month) == false) {
        ret err[String, str]("failed to format month");
    }
    if (s.push('-') == false) {
        ret err[String, str]("failed to format");
    }
    if (append_two_digits(?s, this.day) == false) {
        ret err[String, str]("failed to format day");
    }
    
    ret ok[String, str](s);
}

# helper: parse two-digit number
fun parse_two_digits(s: str, pos: usize) Result[u8, str] {
    if (pos + 2 > s.len) {
        ret err[u8, str]("not enough characters");
    }

    val d1: i32 = digit_val(s[pos]);
    val d2: i32 = digit_val(s[pos + 1]);

    if (d1 < 0 || d1 > 9 || d2 < 0 || d2 > 9) {
        ret err[u8, str]("not a digit");
    }

    val value: i32 = (d1 * 10) + d2;
    ret ok[u8, str](value :: u8);
}

# helper: parse four-digit year
fun parse_year(s: str, pos: usize) Result[i32, str] {
    if (pos + 4 > s.len) {
        ret err[i32, str]("not enough characters for year");
    }

    val d1: i32 = digit_val(s[pos]);
    val d2: i32 = digit_val(s[pos + 1]);
    val d3: i32 = digit_val(s[pos + 2]);
    val d4: i32 = digit_val(s[pos + 3]);

    if (d1 < 0 || d1 > 9 || d2 < 0 || d2 > 9 ||
        d3 < 0 || d3 > 9 || d4 < 0 || d4 > 9) {
        ret err[i32, str]("invalid year format");
    }

    val value: i32 = (d1 * 1000) +
                     (d2 * 100) +
                     (d3 * 10) +
                     d4;
    ret ok[i32, str](value);
}

# parse ISO 8601 date string (YYYY-MM-DD)
pub fun parse_date(s: str) Result[Date, str] {
    if (s.len < 10) {
        ret err[Date, str]("date string too short");
    }
    
    val year_res: Result[i32, str] = parse_year(s, 0);
    if (year_res.is_err()) {
        ret err[Date, str](year_res.unwrap_err());
    }
    
    if (s[4] != '-') {
        ret err[Date, str]("expected '-' after year");
    }
    
    val month_res: Result[u8, str] = parse_two_digits(s, 5);
    if (month_res.is_err()) {
        ret err[Date, str](month_res.unwrap_err());
    }
    
    if (s[7] != '-') {
        ret err[Date, str]("expected '-' after month");
    }
    
    val day_res: Result[u8, str] = parse_two_digits(s, 8);
    if (day_res.is_err()) {
        ret err[Date, str](day_res.unwrap_err());
    }
    
    var d: Date;
    d.year  = year_res.unwrap_ok();
    d.month = month_res.unwrap_ok();
    d.day   = day_res.unwrap_ok();
    
    # validate ranges
    if (d.month < 1 || d.month > 12) {
        ret err[Date, str]("month out of range");
    }
    if (d.day < 1 || d.day > days_in_month(d.year, d.month)) {
        ret err[Date, str]("day out of range");
    }
    
    ret ok[Date, str](d);
}

# parse time string (HH:MM:SS)
pub fun parse_time(s: str) Result[Time, str] {
    if (s.len < 8) {
        ret err[Time, str]("time string too short");
    }
    
    val hour_res: Result[u8, str] = parse_two_digits(s, 0);
    if (hour_res.is_err()) {
        ret err[Time, str](hour_res.unwrap_err());
    }
    
    if (s[2] != ':') {
        ret err[Time, str]("expected ':' after hour");
    }
    
    val minute_res: Result[u8, str] = parse_two_digits(s, 3);
    if (minute_res.is_err()) {
        ret err[Time, str](minute_res.unwrap_err());
    }
    
    if (s[5] != ':') {
        ret err[Time, str]("expected ':' after minute");
    }
    
    val second_res: Result[u8, str] = parse_two_digits(s, 6);
    if (second_res.is_err()) {
        ret err[Time, str](second_res.unwrap_err());
    }
    
    var t: Time;
    t.hour   = hour_res.unwrap_ok();
    t.minute = minute_res.unwrap_ok();
    t.second = second_res.unwrap_ok();
    t.nano   = 0;
    
    # validate ranges
    if (t.hour > 23) {
        ret err[Time, str]("hour out of range");
    }
    if (t.minute > 59) {
        ret err[Time, str]("minute out of range");
    }
    if (t.second > 59) {
        ret err[Time, str]("second out of range");
    }
    
    ret ok[Time, str](t);
}

# parse ISO 8601 datetime string (YYYY-MM-DDTHH:MM:SS or YYYY-MM-DDTHH:MM:SSZ)
pub fun parse_datetime(s: str) Result[DateTime, str] {
    if (s.len < 19) {
        ret err[DateTime, str]("datetime string too short");
    }
    
    val year_res: Result[i32, str] = parse_year(s, 0);
    if (year_res.is_err()) {
        ret err[DateTime, str](year_res.unwrap_err());
    }
    
    if (s[4] != '-') {
        ret err[DateTime, str]("expected '-' after year");
    }
    
    val month_res: Result[u8, str] = parse_two_digits(s, 5);
    if (month_res.is_err()) {
        ret err[DateTime, str](month_res.unwrap_err());
    }
    
    if (s[7] != '-') {
        ret err[DateTime, str]("expected '-' after month");
    }
    
    val day_res: Result[u8, str] = parse_two_digits(s, 8);
    if (day_res.is_err()) {
        ret err[DateTime, str](day_res.unwrap_err());
    }
    
    if (s[10] != 'T') {
        ret err[DateTime, str]("expected 'T' separator");
    }
    
    val hour_res: Result[u8, str] = parse_two_digits(s, 11);
    if (hour_res.is_err()) {
        ret err[DateTime, str](hour_res.unwrap_err());
    }
    
    if (s[13] != ':') {
        ret err[DateTime, str]("expected ':' after hour");
    }
    
    val minute_res: Result[u8, str] = parse_two_digits(s, 14);
    if (minute_res.is_err()) {
        ret err[DateTime, str](minute_res.unwrap_err());
    }
    
    if (s[16] != ':') {
        ret err[DateTime, str]("expected ':' after minute");
    }
    
    val second_res: Result[u8, str] = parse_two_digits(s, 17);
    if (second_res.is_err()) {
        ret err[DateTime, str](second_res.unwrap_err());
    }
    
    var dt: DateTime;
    dt.year   = year_res.unwrap_ok();
    dt.month  = month_res.unwrap_ok();
    dt.day    = day_res.unwrap_ok();
    dt.hour   = hour_res.unwrap_ok();
    dt.minute = minute_res.unwrap_ok();
    dt.second = second_res.unwrap_ok();
    dt.nano = 0;
    
    # validate ranges
    if (dt.month < 1 || dt.month > 12) {
        ret err[DateTime, str]("month out of range");
    }
    if (dt.day < 1 || dt.day > days_in_month(dt.year, dt.month)) {
        ret err[DateTime, str]("day out of range");
    }
    if (dt.hour > 23) {
        ret err[DateTime, str]("hour out of range");
    }
    if (dt.minute > 59) {
        ret err[DateTime, str]("minute out of range");
    }
    if (dt.second > 59) {
        ret err[DateTime, str]("second out of range");
    }
    
    ret ok[DateTime, str](dt);
}

# duration methods
pub fun (this: Duration) seconds() u64 {
    ret this / SECOND;
}

pub fun (this: Duration) milliseconds() u64 {
    ret this / MILLISECOND;
}

pub fun (this: Duration) microseconds() u64 {
    ret this / MICROSECOND;
}

pub fun (this: Duration) nanoseconds() u64 {
    ret this;
}

# create duration from various units
pub fun seconds(s: u64) Duration {
    ret s * SECOND;
}

pub fun milliseconds(ms: u64) Duration {
    ret ms * MILLISECOND;
}

pub fun microseconds(us: u64) Duration {
    ret us * MICROSECOND;
}

pub fun nanoseconds(ns: u64) Duration {
    ret ns;
}

# convert DateTime to Unix timestamp (seconds since epoch)
pub fun (this: *DateTime) to_unix() i64 {
    var days: i64 = 0;
    
    # handle years before or after 1970
    if (this.year < 1970) {
        # count backwards from 1970 to this year (days will be negative)
        var y: i32 = 1969;
        for (y >= this.year) {
            if (is_leap_year(y)) {
                days = days - 366;
            }
            or (is_leap_year(y) == false) {
                days = days - 365;
            }
            y = y - 1;
        }
    }
    or (this.year >= 1970) {
        # count forwards from 1970 to this year
        var y: i32 = 1970;
        for (y < this.year) {
            if (is_leap_year(y)) {
                days = days + 366;
            }
            or (is_leap_year(y) == false) {
                days = days + 365;
            }
            y = y + 1;
        }
    }
    
    # add days for months in this year
    var m: u8 = 1;
    for (m < this.month) {
        days = days + (days_in_month(this.year, m) :: i64);
        m = m + 1;
    }
    
    # add days in this month
    days = days + ((this.day - 1) :: i64);
    
    # convert to seconds and add time of day
    val seconds: i64 = days * 86400 + 
                       (this.hour :: i64) * 3600 + 
                       (this.minute :: i64) * 60 + 
                       (this.second :: i64);
    
    ret seconds;
}

# compare two DateTimes
pub fun (this: DateTime) equals(other: DateTime) bool {
    ret this.year == other.year && 
        this.month == other.month && 
        this.day == other.day && 
        this.hour == other.hour && 
        this.minute == other.minute && 
        this.second == other.second && 
        this.nano == other.nano;
}

pub fun (this: DateTime) before(other: DateTime) bool {
    if (this.year != other.year) {
        ret this.year < other.year;
    }
    if (this.month != other.month) {
        ret this.month < other.month;
    }
    if (this.day != other.day) {
        ret this.day < other.day;
    }
    if (this.hour != other.hour) {
        ret this.hour < other.hour;
    }
    if (this.minute != other.minute) {
        ret this.minute < other.minute;
    }
    if (this.second != other.second) {
        ret this.second < other.second;
    }
    ret this.nano < other.nano;
}

pub fun (this: DateTime) after(other: DateTime) bool {
    ret other.before(this);
}

# compare two Dates
pub fun (this: Date) equals(other: Date) bool {
    ret this.year == other.year && 
        this.month == other.month && 
        this.day == other.day;
}

pub fun (this: Date) before(other: Date) bool {
    if (this.year != other.year) {
        ret this.year < other.year;
    }
    if (this.month != other.month) {
        ret this.month < other.month;
    }
    ret this.day < other.day;
}

pub fun (this: Date) after(other: Date) bool {
    ret other.before(this);
}

# compare two Times
pub fun (this: Time) equals(other: Time) bool {
    ret this.hour == other.hour && 
        this.minute == other.minute && 
        this.second == other.second && 
        this.nano == other.nano;
}

pub fun (this: Time) before(other: Time) bool {
    if (this.hour != other.hour) {
        ret this.hour < other.hour;
    }
    if (this.minute != other.minute) {
        ret this.minute < other.minute;
    }
    if (this.second != other.second) {
        ret this.second < other.second;
    }
    ret this.nano < other.nano;
}

pub fun (this: Time) after(other: Time) bool {
    ret other.before(this);
}

# add seconds to DateTime
pub fun (this: DateTime) add_seconds(secs: i64) DateTime {
    val unix: i64 = this.to_unix() + secs;
    var result: DateTime = from_unix(unix);
    result.nano = this.nano;
    ret result;
}

# add days to DateTime
pub fun (this: DateTime) add_days(days: i32) DateTime {
    ret this.add_seconds(days :: i64 * 86400);
}

# add days to Date
pub fun (this: Date) add_days(days: i32) Date {
    var dt: DateTime;
    dt.year   = this.year;
    dt.month  = this.month;
    dt.day    = this.day;
    dt.hour   = 0;
    dt.minute = 0;
    dt.second = 0;
    dt.nano   = 0;
    
    val result_dt: DateTime = dt.add_days(days);
    
    var result: Date;
    result.year  = result_dt.year;
    result.month = result_dt.month;
    result.day   = result_dt.day;
    
    ret result;
}

# calculate difference between two DateTimes in seconds
pub fun (this: DateTime) diff_seconds(other: DateTime) i64 {
    ret this.to_unix() - other.to_unix();
}

# measure elapsed duration
pub fun since(start: Duration) Duration {
    val current: Duration = now();
    if (current >= start) {
        ret current - start;
    }
    ret 0;
}
