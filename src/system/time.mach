#! if (OS == OS_LINUX)
use std.system.platform.linux.sys;
#! or (OS == OS_DARWIN)
use std.system.platform.darwin.sys;
#! or (OS == OS_WINDOWS)
use std.system.platform.windows.sys;
#! end

#! if (OS != OS_WINDOWS)
str Timespec {
    tv_sec:  i64;
    tv_nsec: i64;
}
#! end

pub val SECONDS: u64 = 1000000000;
pub val MILLISECONDS: u64 = 1000000;
pub val MICROSECONDS: u64 = 1000;
pub val NANOSECONDS: u64 = 1;

#! if (OS == OS_LINUX)
pub val SYSTEM_CLOCK_MONOTONIC: i32 = 1;

pub fun now() u64 {
    var ts: Timespec;
    ts.tv_sec = 0;
    ts.tv_nsec = 0;

    val r: i32 = linux_clock_gettime(SYSTEM_CLOCK_MONOTONIC, (?ts) :: *u8);
    if (r != 0) {
        ret 0;
    }

    ret (ts.tv_sec :: u64) * SECONDS + (ts.tv_nsec :: u64);
}
#! or (OS == OS_DARWIN)
pub val SYSTEM_CLOCK_MONOTONIC: i32 = 6;

pub fun now() u64 {
    var ts: Timespec;
    ts.tv_sec = 0;
    ts.tv_nsec = 0;

    val r: i32 = darwin_clock_gettime(SYSTEM_CLOCK_MONOTONIC, (?ts) :: *u8);
    if (r != 0) {
        ret 0;
    }

    ret (ts.tv_sec :: u64) * SECONDS + (ts.tv_nsec :: u64);
}
#! or (OS == OS_WINDOWS)
pub val SYSTEM_CLOCK_MONOTONIC: i32 = 1;

var win_perf_freq: u64;
var win_perf_ready: u8;

fun ensure_win_perf() u8 {
    if (win_perf_ready != 0) {
        ret 1;
    }

    var freq: i64 = 0;
    val ok: u32 = win_query_performance_frequency((?freq) :: *i64);
    if (ok == 0 || freq <= 0) {
        ret 0;
    }

    win_perf_freq = freq :: u64;
    win_perf_ready = 1;
    ret 1;
}

pub fun now() u64 {
    if (ensure_win_perf() == 0) {
        ret 0;
    }

    var counter: i64 = 0;
    val ok: u32 = win_query_performance_counter((?counter) :: *i64);
    if (ok == 0 || counter < 0) {
        ret 0;
    }

    val value: u64 = counter :: u64;
    ret (value * SECONDS) / win_perf_freq;
}
#! end
