$if (OS == OS_LINUX) {
    use memory: std.system.platform.linux.memory;
}

$if (OS == OS_DARWIN) {
    use memory: std.system.platform.darwin.memory;
}

$if (OS == OS_WINDOWS) {
    use memory: std.system.platform.windows.memory;
}

use std.types.bool;
use std.types.size;
use std.types.option;

pub fun raw_fill(p: ptr, value: u8, size: usize) {
    if (p == nil || size == 0) {
        ret;
    }

    var i: usize = 0;
    val bytes: *u8 = (p::*u8);
    for (i < size) {
        @(bytes + i) = value;
        i = i + 1;
    }
}

pub fun raw_copy(dst: ptr, src: ptr, size: usize) {
    if (dst == nil || src == nil || size == 0) {
        ret;
    }

    var i: usize = 0;
    val dst_bytes: *u8 = (dst::*u8);
    val src_bytes: *u8 = (src::*u8);
    for (i < size) {
        val b: u8 = @(src_bytes + i);
        @(dst_bytes + i) = b;
        i = i + 1;
    }
}

pub fun raw_zero(p: ptr, size: usize) {
    raw_fill(p, 0, size);
}

pub fun allocate[T](count: usize) Option[*T] {
    if (count == 0) {
        ret none[*T]();
    }

    val size:  usize = $size_of(T);
    val total: usize = size * count;
    if (size != 0 && total / size != count) {
        ret none[*T]();
    }

    val mem: *T = memory.allocate(total)::*T;
    if (mem == nil) {
        ret none[*T]();
    }

    ret some[*T](mem);
}

pub fun zallocate[T](count: usize) Option[*T] {
    val mem: Option[*T] = allocate[T](count);
    if (mem.is_none()) {
        ret none[*T]();
    }

    val p: *T = mem.unwrap();

    zero[T](p, count);

    ret some[*T](p);
}

pub fun deallocate[T](p: *T, count: usize) bool {
    if (p == nil || count == 0) {
        # NOTE: do not explicitly fail. Deallocating nil or zero size is a no-op.
        ret true;
    }

    ret memory.deallocate(p::ptr, $size_of(T) * count);
}

pub fun reallocate[T](p: *T, old_count: usize, new_count: usize) Option[*T] {
    if (new_count == 0) {
        ret none[*T]();
    }

    val elem_size: usize = $size_of(T);
    val old_size:  usize = elem_size * old_count;
    val new_size:  usize = elem_size * new_count;

    # check for size overflow
    if (elem_size != 0 && new_size / elem_size != new_count) {
        ret none[*T]();
    }

    # use platform-specific reallocate
    val new_mem: *T = memory.reallocate(p::ptr, old_size, new_size)::*T;
    if (new_mem == nil) {
        ret none[*T]();
    }

    ret some[*T](new_mem);
}

pub fun fill[T](p: *T, value: T, count: usize) {
    if (p == nil || count == 0) {
        ret;
    }

    var i: usize = 0;
    for (i < count) {
        @(p + i) = value;
        i = i + 1;
    }
}

pub fun copy[T](dst: *T, src: *T, count: usize) {
    if (dst == nil || src == nil || count == 0) {
        ret;
    }

    var i: usize = 0;
    for (i < count) {
        @(dst + i) = @(src + i);
        i = i + 1;
    }
}

pub fun zero[T](p: *T, count: usize) {
    if (p == nil || count == 0) {
        ret;
    }

    var size: usize = $size_of(T) * count;
    raw_zero(p::ptr, size);
}
