#@if (OS == OS_LINUX)
use sys: std.system.platform.linux.sys;
#@or (OS == OS_DARWIN)
use sys: std.system.platform.darwin.sys;
#@or (OS == OS_WINDOWS)
use sys: std.system.platform.windows.sys;
#@end

pub fun memory_zero(p: ptr, size: u64) {
    if (p == nil || size == 0) {
        ret;
    }

    var i: u64 = 0;
    val bytes: *u8 = (p :: *u8);
    for (i < size) {
        @(bytes + i) = 0;
        i = i + 1;
    }
}

#@symbol("memset")
pub fun memset(dest: ptr, value: i32, count: u64) ptr {
    if (dest == nil || count == 0) {
        ret dest;
    }

    var i: u64 = 0;
    val byte: u8 = (value :: u8);
    val bytes: *u8 = (dest :: *u8);
    for (i < count) {
        @(bytes + i) = byte;
        i = i + 1;
    }

    ret dest;
}

pub fun memory_fill(p: ptr, value: u8, size: u64) {
    if (p == nil || size == 0) {
        ret;
    }

    var i: u64 = 0;
    val bytes: *u8 = (p :: *u8);
    for (i < size) {
        @(bytes + i) = value;
        i = i + 1;
    }
}

pub fun memory_copy(dst: ptr, src: ptr, size: u64) {
    if (dst == nil || src == nil || size == 0) {
        ret;
    }

    var i: u64 = 0;
    val dst_bytes: *u8 = (dst :: *u8);
    val src_bytes: *u8 = (src :: *u8);
    for (i < size) {
        val b: u8 = @(src_bytes + i);
        @(dst_bytes + i) = b;
        i = i + 1;
    }
}

#@symbol("memcpy")
pub fun memcpy(dst: ptr, src: ptr, count: u64) ptr {
    if (dst == nil || src == nil || count == 0) {
        ret dst;
    }

    var i: u64 = 0;
    val dst_bytes: *u8 = (dst :: *u8);
    val src_bytes: *u8 = (src :: *u8);
    for (i < count) {
        val b: u8 = @(src_bytes + i);
        @(dst_bytes + i) = b;
        i = i + 1;
    }

    ret dst;
}

#@if (OS == OS_LINUX)
pub val SYSTEM_PROT_READ:   i32 = 1;
pub val SYSTEM_PROT_WRITE:  i32 = 2;
pub val SYSTEM_MAP_PRIVATE: i32 = 2;
pub val SYSTEM_MAP_ANON:    i32 = 32; # MAP_ANONYMOUS

pub fun allocate(size: u64) ptr {
    if (size == 0) {
        ret nil;
    }

    ret (sys.mmap(nil, size, SYSTEM_PROT_READ | SYSTEM_PROT_WRITE, SYSTEM_MAP_PRIVATE | SYSTEM_MAP_ANON, -1, 0) :: ptr);
}

pub fun deallocate(p: ptr, size: u64) u8 {
    if (p == nil || size == 0) {
        ret 0;
    }

    val r: i32 = sys.munmap((p :: *u8), size);
    if (r == 0) {
        ret 0;
    }

    ret 1;
}

pub fun reallocate(p: ptr, old_size: u64, new_size: u64) ptr {
    if (p == nil) {
        ret allocate(new_size);
    }

    if (new_size == 0) {
        deallocate(p, old_size);
        ret nil;
    }

    val n: ptr = allocate(new_size);
    if (n == nil) {
        ret nil;
    }

    var to_copy: u64 = old_size;
    if (new_size < to_copy) {
        to_copy = new_size;
    }

    memory_copy(n, p, to_copy);
    deallocate(p, old_size);

    ret n;
}
#@or (OS == OS_DARWIN)
pub val SYSTEM_PROT_READ:   i32 = 1;
pub val SYSTEM_PROT_WRITE:  i32 = 2;
pub val SYSTEM_MAP_PRIVATE: i32 = 2;
pub val SYSTEM_MAP_ANON:    i32 = 32; # MAP_ANONYMOUS

pub fun allocate(size: u64) ptr {
    if (size == 0) {
        ret nil;
    }

    ret (sys.mmap(nil, size, SYSTEM_PROT_READ | SYSTEM_PROT_WRITE, SYSTEM_MAP_PRIVATE | SYSTEM_MAP_ANON, -1, 0) :: ptr);
}

pub fun deallocate(p: ptr, size: u64) u8 {
    if (p == nil || size == 0) {
        ret 0;
    }

    val r: i32 = sys.munmap((p :: *u8), size);
    if (r == 0) {
        ret 0;
    }

    ret 1;
}

pub fun reallocate(p: ptr, old_size: u64, new_size: u64) ptr {
    if (p == nil) {
        ret allocate(new_size);
    }

    if (new_size == 0) {
        deallocate(p, old_size);
        ret nil;
    }

    val n: ptr = allocate(new_size);
    if (n == nil) {
        ret nil;
    }

    var to_copy: u64 = old_size;
    if (new_size < to_copy) {
        to_copy = new_size;
    }

    memory_copy(n, p, to_copy);
    deallocate(p, old_size);

    ret n;
}
#@or (OS == OS_WINDOWS)
pub fun allocate(size: u64) ptr {
    if (size == 0) {
        ret nil;
    }

    ret (sys.virt_alloc(size) :: ptr);
}

pub fun deallocate(p: ptr, size: u64) u8 {
    if (p == nil || size == 0) {
        ret 0;
    }

    val r: u32 = sys.virt_free((p :: *u8), size);
    if (r != 0) {
        ret 0;
    }

    ret 1;
}

pub fun reallocate(p: ptr, old_size: u64, new_size: u64) ptr {
    if (p == nil) {
        ret allocate(new_size);
    }

    if (new_size == 0) {
        deallocate(p, old_size);
        ret nil;
    }

    val n: ptr = allocate(new_size);
    if (n == nil) {
        ret nil;
    }

    var to_copy: u64 = old_size;
    if (new_size < to_copy) {
        to_copy = new_size;
    }

    memory_copy(n, p, to_copy);
    deallocate(p, old_size);

    ret n;
}
#@end

pub fun alloc<T>(count: u64) *T {
    if (count == 0) {
        ret nil;
    }

    val size: u64 = size_of(0 :: T);
    val total: u64 = size * count;
    if (size != 0 && total / size != count) {
        ret nil;
    }

    ret (allocate(total) :: *T);
}

pub fun dealloc<T>(p: *T, count: u64) u8 {
    if (p == nil || count == 0) {
        ret 0;
    }

    val size: u64 = size_of(0 :: T);
    val total: u64 = size * count;
    ret deallocate((p :: ptr), total);
}

pub fun realloc<T>(p: *T, old_count: u64, new_count: u64) *T {
    if (p == nil) {
        ret alloc<T>(new_count);
    }

    if (new_count == 0) {
        dealloc<T>(p, old_count);
        ret nil;
    }

    val size: u64 = size_of(0 :: T);
    val old_total: u64 = size * old_count;
    val new_total: u64 = size * new_count;

    if (size != 0 && new_total / size != new_count) {
        ret nil;
    }

    ret (reallocate((p :: ptr), old_total, new_total) :: *T);
}
