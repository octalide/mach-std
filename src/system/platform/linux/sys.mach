use std.system.platform.linux.syscall;

pub val LINUX_SYS_READ:          u64 = 0;
pub val LINUX_SYS_WRITE:         u64 = 1;
pub val LINUX_SYS_OPENAT:        u64 = 257;
pub val LINUX_SYS_CLOSE:         u64 = 3;
pub val LINUX_SYS_MMAP:          u64 = 9;
pub val LINUX_SYS_MUNMAP:        u64 = 11;
pub val LINUX_SYS_CLOCK_GETTIME: u64 = 228;

pub val LINUX_AT_FDCWD: i32 = -100;

fun sext_i32(value: i32) u64 {
	ret (value::i64)::u64;
}

pub fun linux_read(fd: i32, buf: *u8, count: u64) i64 {
	ret syscall3(LINUX_SYS_READ, sext_i32(fd), (buf::u64), count);
}

pub fun linux_write(fd: i32, buf: *u8, count: u64) i64 {
	ret syscall3(LINUX_SYS_WRITE, sext_i32(fd), (buf::u64), count);
}

pub fun linux_openat(dirfd: i32, path: *u8, flags: i32, mode: i32) i64 {
	ret syscall4(LINUX_SYS_OPENAT, sext_i32(dirfd), (path::u64), (flags::u64), (mode::u64));
}

pub fun linux_close(fd: i32) i64 {
	ret syscall1(LINUX_SYS_CLOSE, sext_i32(fd));
}

pub fun linux_mmap(addr: *u8, length: u64, prot: i32, flags: i32, fd: i32, offset: i64) *u8 {
	val res: i64 = syscall6(
		LINUX_SYS_MMAP,
		(addr::u64),
		length,
		(prot::u64),
		(flags::u64),
		sext_i32(fd),
		(offset::u64)
	);

	if (res < 0) {
		ret nil;
	}

	ret (res::u64)::*u8;
}

pub fun linux_munmap(addr: *u8, length: u64) i32 {
	val res: i64 = syscall2(LINUX_SYS_MUNMAP, (addr::u64), length);

	if (res < 0) {
		ret -1;
	}

	ret 0;
}

pub fun linux_clock_gettime(clock_id: i32, ts: *u8) i32 {
	val res: i64 = syscall2(LINUX_SYS_CLOCK_GETTIME, (clock_id::u64), (ts::u64));

	if (res < 0) {
		ret -1;
	}

	ret (res::i32);
}
