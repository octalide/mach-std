use      std.types.option;
use      std.types.size;
use      std.types.string;
use mem: std.system.memory;

val WORD_BYTES: usize = 8;

fun cstring_length(s: cstr) usize {
    if (s == nil) {
        ret 0;
    }

    var length: usize = 0;
    var cursor: cstr  = s;
    for {
        if (@cursor == 0::char) {
            brk;
        }
        length = length + 1;
        cursor = cursor + 1;
    }

    ret length;
}

pub fun build_args(argc: usize, stack: *u8) Option[[]str] {
    if (argc == 0) {
        ret some[[]str]([]str{ nil, 0 });
    }

    val entry_size:  usize = $size_of(str);
    val total_bytes: usize = argc * entry_size;
    if (total_bytes == 0) {
        ret some[[]str]([]str{ nil, 0 });
    }

    val storage_opt: Option[*u8] = mem.allocate[u8](total_bytes);
    if (storage_opt.is_none()) {
        ret none[[]str]();
    }

    val storage: *u8 = storage_opt.unwrap();

    val argv_base: *u8 = stack + WORD_BYTES;

    var index: usize = 0;
    for (index < argc) {
        val offset:  usize = index * WORD_BYTES;
        val addr:    *u8   = argv_base + offset;
        val raw:     usize = @(addr::*usize);
        val arg_ptr: cstr  = raw::cstr;
        val length:  usize = cstring_length(arg_ptr);

        val slot_offset: usize = index * entry_size;
        val slot_addr:   *u8   = storage + slot_offset;

        val data_slot: **char = slot_addr::**char;
        @data_slot = arg_ptr;

        val length_addr: *u8     = slot_addr + WORD_BYTES;
        val length_slot: *usize = length_addr::*usize;
        @length_slot = length;

        index = index + 1;
    }

    ret some[[]str]([]str{ storage::*str, argc });
}

pub fun get_argc(stack: *u8) usize {
    ret @(stack::*usize);
}

asm {
.text
.globl mach_runtime_exit
mach_runtime_exit:
    mov $60, %rax
    syscall
    hlt
}
