use std.types.option;
use std.types.result;
use std.types.bool;
use std.types.string;
use std.types.size;
use std.io.path;
use mem: std.system.memory;
use sys: std.system.platform.linux.sys;

# stat constants for linux
pub val AT_FDCWD:            i32 = -100;
pub val AT_SYMLINK_NOFOLLOW: i32 = 0x0100;
pub val AT_REMOVEDIR:        i32 = 0x0200;

# file type mask and values
val S_IFMT:  u32 = 0o170000;
val S_IFDIR: u32 = 0o040000;
val S_IFREG: u32 = 0o100000;
val S_IFLNK: u32 = 0o120000;

# error codes
val ERR_NO_MEM: i32 = -12;

# linux stat structure (x86_64)
rec stat_t {
    st_dev:        u64;
    st_ino:        u64;
    st_nlink:      u64;
    st_mode:       u32;
    st_uid:        u32;
    st_gid:        u32;
    pad0:          i32;
    st_rdev:       u64;
    st_size:       i64;
    st_blksize:    i64;
    st_blocks:     i64;
    st_atime:      i64;
    st_atime_nsec: i64;
    st_mtime:      i64;
    st_mtime_nsec: i64;
    st_ctime:      i64;
    st_ctime_nsec: i64;
    _reserved0:    i64;
    _reserved1:    i64;
    _reserved2:    i64;
}

# file metadata structure
pub rec FileInfo {
    size:       u64;
    mode:       u32;
    is_dir:     bool;
    is_file:    bool;
    is_symlink: bool;
    atime_sec:  i64;
    mtime_sec:  i64;
    ctime_sec:  i64;
}

fun stat_to_fileinfo(st: *stat_t) FileInfo {
    val mode: u32 = st.st_mode;

    var info: FileInfo;
    info.size       = st.st_size :: u64;
    info.mode       = mode;
    info.is_dir     = ((mode & S_IFMT) == S_IFDIR);
    info.is_file    = ((mode & S_IFMT) == S_IFREG);
    info.is_symlink = ((mode & S_IFMT) == S_IFLNK);
    info.atime_sec  = st.st_atime;
    info.mtime_sec  = st.st_mtime;
    info.ctime_sec  = st.st_ctime;

    ret info;
}

pub fun read_file(path: Path) Result[[]u8, i32] {
    val opt_cstr: Option[cstr] = path.as_cstr();
    if (opt_cstr.is_none()) {
        ret err[[]u8, i32](ERR_NO_MEM);
    }

    val path_c: cstr = opt_cstr.unwrap();
    val fd_res: i64 = sys.openat(AT_FDCWD, path_c, 0, 0);
    if (fd_res < 0) {
        ret err[[]u8, i32](fd_res :: i32);
    }

    val fd:        i32         = fd_res :: i32;
    var cap:       usize       = 4096;
    val buf_alloc: Option[*u8] = mem.allocate[u8](cap);
    if (buf_alloc.is_none()) {
        sys.close(fd);
        ret err[[]u8, i32](ERR_NO_MEM);
    }

    var buf: *u8 = buf_alloc.unwrap();

    var len: usize = 0;
    for {
        if (cap == len) {
            val ncap:        usize       = cap + (cap >> 1) + 1;
            val realloc_res: Option[*u8] = mem.reallocate[u8](buf, cap, ncap);
            if (realloc_res.is_none()) {
                mem.deallocate[u8](buf, cap);
                sys.close(fd);
                ret err[[]u8, i32](ERR_NO_MEM);
            }
            buf = realloc_res.unwrap();
            cap = ncap;
        }

        val space: usize = cap - len;
        val got:   i64   = sys.read(fd, (buf + len), space);
        if (got < 0) {
            mem.deallocate[u8](buf, cap);
            sys.close(fd);
            ret err[[]u8, i32](got :: i32);
        }
        or (got == 0) {
            brk;
        }

        len = len + (got :: usize);
    }

    sys.close(fd);

    if (len == 0) {
        mem.deallocate[u8](buf, cap);
        buf = nil;
        cap = 0;
    }
    or (len < cap) {
        val shrink_res: Option[*u8] = mem.reallocate[u8](buf, cap, len);
        if (shrink_res.is_some()) {
            buf = shrink_res.unwrap();
            cap = len;
        }
    }

    ret ok[[]u8, i32]([]u8{ buf, len });
}

pub fun write_file(path: Path, data: []u8, flags: i32, mode: i32) Result[u64, i32] {
    val opt_cstr: Option[cstr] = path.as_cstr();
    if (opt_cstr.is_none()) {
        ret err[u64, i32](ERR_NO_MEM);
    }

    val path_c: cstr = opt_cstr.unwrap();
    val fd_res: i64 = sys.openat(AT_FDCWD, path_c, flags, mode);
    if (fd_res < 0) {
        ret err[u64, i32](fd_res :: i32);
    }

    val fd: i32 = fd_res :: i32;
    var off: usize = 0;
    for (off < data.len) {
        val wrote: i64 = sys.write(fd, (data.data + off), (data.len - off));
        if (wrote <= 0) {
            sys.close(fd);
            ret err[u64, i32](wrote :: i32);
        }
        off = off + (wrote :: usize);
    }

    sys.close(fd);
    ret ok[u64, i32](data.len :: u64);
}

pub fun check_access(path: Path) bool {
    val opt_cstr: Option[cstr] = path.as_cstr();
    if (opt_cstr.is_none()) {
        ret false;
    }

    val path_c: cstr = opt_cstr.unwrap();
    val res: i64 = sys.faccessat(AT_FDCWD, path_c, 0, 0);
    ret (res == 0);
}

pub fun unlink_file(path: Path) Result[u64, i32] {
    val opt_cstr: Option[cstr] = path.as_cstr();
    if (opt_cstr.is_none()) {
        ret err[u64, i32](ERR_NO_MEM);
    }

    val path_c: cstr = opt_cstr.unwrap();
    val res: i64 = sys.unlinkat(AT_FDCWD, path_c, 0);
    if (res < 0) {
        ret err[u64, i32](res :: i32);
    }

    ret ok[u64, i32](0);
}

pub fun unlink_dir(path: Path) Result[u64, i32] {
    val opt_cstr: Option[cstr] = path.as_cstr();
    if (opt_cstr.is_none()) {
        ret err[u64, i32](ERR_NO_MEM);
    }

    val path_c: cstr = opt_cstr.unwrap();
    val res: i64 = sys.unlinkat(AT_FDCWD, path_c, AT_REMOVEDIR);
    if (res < 0) {
        ret err[u64, i32](res :: i32);
    }

    ret ok[u64, i32](0);
}

pub fun rename_path(oldpath: Path, newpath: Path) Result[u64, i32] {
    val opt_old: Option[cstr] = oldpath.as_cstr();
    if (opt_old.is_none()) {
        ret err[u64, i32](ERR_NO_MEM);
    }

    val opt_new: Option[cstr] = newpath.as_cstr();
    if (opt_new.is_none()) {
        ret err[u64, i32](ERR_NO_MEM);
    }

    val old_c: cstr = opt_old.unwrap();
    val new_c: cstr = opt_new.unwrap();
    val res: i64 = sys.renameat(AT_FDCWD, old_c, AT_FDCWD, new_c);
    if (res < 0) {
        ret err[u64, i32](res :: i32);
    }

    ret ok[u64, i32](0);
}

pub fun make_dir(path: Path, mode: i32) Result[u64, i32] {
    val opt_cstr: Option[cstr] = path.as_cstr();
    if (opt_cstr.is_none()) {
        ret err[u64, i32](ERR_NO_MEM);
    }

    val path_c: cstr = opt_cstr.unwrap();
    val res: i64 = sys.mkdirat(AT_FDCWD, path_c, mode);
    if (res < 0) {
        ret err[u64, i32](res :: i32);
    }

    ret ok[u64, i32](0);
}

pub fun get_stat(path: Path, follow_links: bool) Result[FileInfo, i32] {
    val opt_cstr: Option[cstr] = path.as_cstr();
    if (opt_cstr.is_none()) {
        ret err[FileInfo, i32](ERR_NO_MEM);
    }
    val path_c: cstr = opt_cstr.unwrap();

    var st:    stat_t;
    val flags: i32 = (follow_links == false) :: i32 * AT_SYMLINK_NOFOLLOW;
    val res:   i64 = sys.newfstatat(AT_FDCWD, path_c, (?st) :: *u8, flags);
    if (res < 0) {
        ret err[FileInfo, i32](res :: i32);
    }

    ret ok[FileInfo, i32](stat_to_fileinfo(?st));
}
