use sys: std.system.platform.darwin.sys;

pub rec Timespec {
    tv_sec:  i64;
    tv_nsec: i64;
}

pub rec Tm {
    tm_sec:   i32;  # seconds after the minute [0-60]
    tm_min:   i32;  # minutes after the hour [0-59]
    tm_hour:  i32;  # hours since midnight [0-23]
    tm_mday:  i32;  # day of the month [1-31]
    tm_mon:   i32;  # months since January [0-11]
    tm_year:  i32;  # years since 1900
    tm_wday:  i32;  # days since Sunday [0-6]
    tm_yday:  i32;  # days since January 1 [0-365]
    tm_isdst: i32;  # daylight saving time flag
}

pub val CLOCK_REALTIME:  i32 = 0;
pub val CLOCK_MONOTONIC: i32 = 6;

# get monotonic time in nanoseconds
pub fun monotonic_now() u64 {
    var ts: Timespec;
    ts.tv_sec = 0;
    ts.tv_nsec = 0;

    val r: i32 = sys.clock_gettime(CLOCK_MONOTONIC, (?ts) :: *u8);
    if (r != 0) {
        ret 0;
    }

    ret (ts.tv_sec :: u64) * 1000000000 + (ts.tv_nsec :: u64);
}

# get wall clock time in nanoseconds since Unix epoch
# returns i64 to support pre-epoch dates (negative timestamps)
pub fun realtime_now() i64 {
    var ts: Timespec;
    ts.tv_sec = 0;
    ts.tv_nsec = 0;

    val r: i32 = sys.clock_gettime(CLOCK_REALTIME, (?ts) :: *u8);
    if (r != 0) {
        ret 0;
    }

    ret ts.tv_sec * 1000000000 + ts.tv_nsec;
}

# get seconds and nanoseconds since Unix epoch
pub fun realtime_timespec(ts_ptr: *Timespec) i32 {
    ret sys.clock_gettime(CLOCK_REALTIME, (ts_ptr :: *u8));
}
