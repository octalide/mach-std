use      std.types.option;
use      std.types.size;
use mem: std.system.memory;

var env_blob_data: *u8;
var env_blob_len:  usize;
var env_loaded:    u8;

ext "C:_NSGetEnviron" darwin_ns_get_environ: fun() **u8;

fun copy_c_string(src: *u8) usize {
    var len: usize = 0;
    for {
        if (@(src + len) == 0) {
            ret len;
        }
        len = len + 1;
    }
    ret len;
}

fun load_env() u8 {
    val envp_ptr: **u8 = darwin_ns_get_environ();
    if (envp_ptr == nil) {
        ret 0;
    }

    var idx:   usize = 0;
    var total: usize = 0;

    for {
        val entry: *u8 = @(envp_ptr + idx);
        if (entry == nil) {
            brk;
        }
        total = total + copy_c_string(entry) + 1;
        idx = idx + 1;
    }

    if (total == 0) {
        env_blob_data = nil;
        env_blob_len  = 0;
        ret 1;
    }

    val alloc_res: Option[*u8] = mem.allocate[u8](total);
    if (alloc_res.is_none()) {
        ret 0;
    }

    val buf: *u8 = alloc_res.unwrap();

    idx = 0;
    var offset: usize = 0;
    for {
        val entry: *u8 = @(envp_ptr + idx);
        if (entry == nil) {
            brk;
        }

        val len: usize = copy_c_string(entry);
        mem.copy[u8](buf + offset, entry, len);
        @(buf + offset + len) = 0;
        offset = offset + len + 1;
        idx = idx + 1;
    }

    env_blob_data = buf;
    env_blob_len  = offset;
    ret 1;
}

pub fun ensure_env_blob() u8 {
    if (env_loaded != 0) {
        if (env_blob_data != nil && env_blob_len != 0) {
            ret 1;
        }
        ret 0;
    }

    env_loaded = 1;
    ret load_env();
}

pub fun get_env_blob() []u8 {
    ret []u8{ env_blob_data, env_blob_len };
}
