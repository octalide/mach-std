use std.types.size;
use std.types.bool;

use sys: std.system.platform.darwin.sys;

pub val SYSTEM_PROT_READ:   i32 = 1;
pub val SYSTEM_PROT_WRITE:  i32 = 2;
pub val SYSTEM_MAP_PRIVATE: i32 = 2;
pub val SYSTEM_MAP_ANON:    i32 = 32; # MAP_ANONYMOUS

pub fun allocate(size: usize) ptr {
    if (size == 0) {
        ret nil;
    }

    ret (sys.mmap(nil, size, SYSTEM_PROT_READ | SYSTEM_PROT_WRITE, SYSTEM_MAP_PRIVATE | SYSTEM_MAP_ANON, -1, 0)::ptr);
}

pub fun deallocate(p: ptr, size: usize) bool {
    if (p == nil || size == 0) {
        ret true;
    }

    val r: i32 = sys.munmap((p::*u8), size);
    if (r == 0) {
        ret true;
    }

    ret false;
}

pub fun reallocate(p: ptr, old_size: usize, new_size: usize) ptr {
    if (p == nil || old_size == 0) {
        ret allocate(new_size);
    }

    if (new_size == 0) {
        deallocate(p, old_size);
        ret nil;
    }

    # darwin/macos does not have mremap, so allocate new + copy + free old
    val new_p: ptr = allocate(new_size);
    if (new_p == nil) {
        ret nil;
    }

    # copy the minimum of old and new sizes
    var copy_size: usize = old_size;
    if (new_size < old_size) {
        copy_size = new_size;
    }

    # byte-by-byte copy
    var i: usize = 0;
    val src_bytes: *u8 = (p::*u8);
    val dst_bytes: *u8 = (new_p::*u8);
    for (i < copy_size) {
        @(dst_bytes + i) = @(src_bytes + i);
        i = i + 1;
    }

    deallocate(p, old_size);
    ret new_p;
}
