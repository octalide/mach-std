use std.types.size;

use sys: std.system.platform.windows.sys;

fun windows_handle(fd: i32) *u8 {
    # NOTE: these values correlate to the constants defined in `std.io.console`,
    # which in turn correlate to the POSIX standard file descriptors.
    if (fd == 0) {
        ret sys.get_std_handle(sys.STD_INPUT_HANDLE);
    }
    or (fd == 1) {
        ret sys.get_std_handle(sys.STD_OUTPUT_HANDLE);
    }
    or (fd == 2) {
        ret sys.get_std_handle(sys.STD_ERROR_HANDLE);
    }

    ret nil;
}

fun windows_chunked_io(handle: *u8, buffer: *u8, size: usize, is_write: u8) usize {
    var remaining: usize = size;
    var offset:    usize = 0;
    var total:     usize = 0;

    for (remaining > 0) {
        var chunk: usize = remaining;
        if (chunk > 0xffff_ffff) {
            chunk = 0xffff_ffff;
        }

        var count32: u32 = 0;
        var ok:      u32 = 0;
        if (is_write != 0) {
            ok = sys.write_file(handle, (buffer + offset), chunk::u32, (?count32)::*u32);
        } or {
            ok = sys.read_file(handle, (buffer + offset), chunk::u32, (?count32)::*u32);
        }

        if (ok == 0) {
            ret -1;
        }

        val processed: usize = count32::usize;
        if (processed == 0) {
            brk;
        }

        offset    = offset + processed;
        total     = total + processed;
        remaining = remaining - processed;
    }

    ret total;
}

pub fun write(fd: i32, data: *u8, size: usize) usize {
    val handle: *u8 = windows_handle(fd);
    if (handle == nil || (handle) == -1) {
        ret -1;
    }

    ret windows_chunked_io(handle, data, size, 1);
}

pub fun read(fd: i32, dest: *u8, max: usize) usize {
    val handle: *u8 = windows_handle(fd);
    if (handle == nil || (handle) == -1) {
        ret -1;
    }

    ret windows_chunked_io(handle, dest, max, 0);
}
