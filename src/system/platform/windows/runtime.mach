use      std.types.option;
use      std.types.size;
use      std.types.string;
use mem: std.system.memory;

val WORD_BYTES:  usize = 8;
val WIN_CP_UTF8: u32   = 65001;

ext "C:GetCommandLineW"     win32_get_command_line_w:      fun() *u16;
ext "C:CommandLineToArgvW"  win32_command_line_to_argv_w:  fun(*u16, *i32) **u16;
ext "C:LocalFree"           win32_local_free:              fun(*u8) *u8;
ext "C:WideCharToMultiByte" win32_wide_char_to_multi_byte: fun(u32, u32, *u16, i32, *u8, i32, *u8, *u8) i32;
ext "C:ExitProcess"         win32_exit_process:            fun(u32);

fun utf16_length(s: *u16) usize {
    if (s == nil) {
        ret 0;
    }

    var length: usize = 0;
    var cursor: *u16  = s;
    for {
        if (@cursor == 0::u16) {
            brk;
        }
        length = length + 1;
        cursor = cursor + 1;
    }

    ret length;
}

fun utf16_to_utf8(src: *u16) str {
    if (src == nil) {
        ret str{ nil, 0 };
    }

    val char_count64: usize = utf16_length(src);
    if (char_count64 == 0) {
        ret str{ nil, 0 };
    }

    val char_count:  i32          = char_count64::i32;
    val required:    i32          = win32_wide_char_to_multi_byte(WIN_CP_UTF8, 0, src, char_count, nil, 0, nil, nil);
    if (required <= 0) {
        ret str{ nil, 0 };
    }

    val buffer_size: usize        = required::usize;
    val alloc_res:   Option[*u8]  = mem.allocate[u8](buffer_size);
    if (alloc_res.is_none()) {
        ret str{ nil, 0 };
    }

    val buffer: *u8 = alloc_res.unwrap();

    val written: i32 = win32_wide_char_to_multi_byte(WIN_CP_UTF8, 0, src, char_count, buffer, required, nil, nil);
    if (written <= 0) {
        mem.deallocate[u8](buffer, buffer_size);
        ret str{ nil, 0 };
    }

    ret str{ buffer::*char, written::usize };
}

pub fun build_args(argc: usize, argv_wide: **u16) Option[[]str] {
    if (argv_wide == nil) {
        ret some[[]str]([]str{ nil, 0 });
    }

    val entry_size:  usize = $size_of(str);
    val total_bytes: usize = argc * entry_size;
    if (total_bytes == 0) {
        ret some[[]str]([]str{ nil, 0 });
    }

    val alloc_res: Option[*u8] = mem.allocate[u8](total_bytes);
    if (alloc_res.is_none()) {
        ret none[[]str]();
    }

    val storage: *u8 = alloc_res.unwrap();

    var index: usize = 0;
    for (index < argc) {
        val wide_arg: *u16 = @(argv_wide + index);
        val utf8:     str  = utf16_to_utf8(wide_arg);

        val slot_offset: usize = index * entry_size;
        val slot_addr:   *u8   = storage + slot_offset;

        val data_slot: **char = slot_addr::**char;
        @data_slot = utf8.data;

        val length_addr: *u8     = slot_addr + WORD_BYTES;
        val length_slot: *usize = length_addr::*usize;
        @length_slot = utf8.len;

        index = index + 1;
    }

    ret some[[]str]([]str{ storage::*str, argc });
}

pub fun collect_args() Option[[]str] {
    val cmd_line:  *u16  = win32_get_command_line_w();
    var argc32:    i32   = 0;
    val argv_wide: **u16 = win32_command_line_to_argv_w(cmd_line, (?argc32)::*i32);

    if (argv_wide == nil || argc32 <= 0) {
        if (argv_wide != nil) {
            win32_local_free(argv_wide::*u8);
        }
        ret none[[]str]();
    }

    val argc:     usize       = argc32::usize;
    val args_opt: Option[[]str] = build_args(argc, argv_wide);
    win32_local_free(argv_wide::*u8);
    ret args_opt;
}

asm {
.text
.globl mach_runtime_exit
mach_runtime_exit:
    mov %rcx, %rcx
    call ExitProcess
    hlt
}
