use std.types.option;
use std.types.result;
use std.types.bool;
use std.types.string;
use std.types.size;
use std.io.path;
use mem: std.system.memory;
use sys: std.system.platform.windows.sys;

# error codes (matching unix semantics where applicable)
val ERR_NOT_FOUND: i32 = -2;
val ERR_IO:        i32 = -5;
val ERR_NO_MEM:    i32 = -12;

# file metadata structure
pub rec FileInfo {
    size:        u64;
    mode:        u32;
    is_dir:      bool;
    is_file:     bool;
    is_symlink:  bool;
    atime_sec:   i64;
    mtime_sec:   i64;
    ctime_sec:   i64;
}

fun str_to_utf16(s: str) []u16 {
    val units:     usize       = s.len + 1;
    val alloc_res: Option[*u16] = mem.allocate[u16](units);
    if (alloc_res.is_none()) {
        ret []u16{ nil, 0 };
    }

    val buf16: *u16 = alloc_res.unwrap();
    var i: usize = 0;
    for (i < s.len) {
        val ch: u8 = @(s.data + i);
        if (ch >= 128) {
            mem.deallocate[u16](buf16, units);
            ret []u16{ nil, 0 };
        }
        @(buf16 + i) = ch :: u16;
        i = i + 1;
    }

    @(buf16 + s.len) = 0;

    ret []u16{ buf16, units };
}

pub fun read_file(path: Path) Result[[]u8, i32] {
    val w_path: []u16 = str_to_utf16(path.as_str());
    if (w_path.data == nil) {
        ret err[[]u8, i32](ERR_NO_MEM);
    }

    val handle: *u8 = sys.create_file_read(w_path.data);
    mem.deallocate[u16](w_path.data, w_path.len);
    if (handle == nil || (handle :: i64) == -1) {
        ret err[[]u8, i32](ERR_NOT_FOUND);
    }

    var cap:       usize       = 4096;
    val buf_alloc: Option[*u8] = mem.allocate[u8](cap);
    if (buf_alloc.is_none()) {
        sys.close_handle(handle);
        ret err[[]u8, i32](ERR_NO_MEM);
    }

    var buf: *u8 = buf_alloc.unwrap();

    var len: usize = 0;
    for {
        if (cap == len) {
            val ncap:        usize       = cap + (cap >> 1) + 1;
            val realloc_res: Option[*u8] = mem.reallocate[u8](buf, cap, ncap);
            if (realloc_res.is_none()) {
                mem.deallocate[u8](buf, cap);
                sys.close_handle(handle);
                ret err[[]u8, i32](ERR_NO_MEM);
            }
            buf = realloc_res.unwrap();
            cap = ncap;
        }

        var chunk: usize = cap - len;
        if (chunk > 0xffff_ffff) {
            chunk = 0xffff_ffff;
        }
        var read32: u32 = 0;
        val ok: u32 = sys.read_file(handle, (buf + len), chunk :: u32, (?read32) :: *u32);
        if (ok == 0) {
            mem.deallocate[u8](buf, cap);
            sys.close_handle(handle);
            ret err[[]u8, i32](ERR_IO);
        }
        or (read32 == 0) {
            brk;
        }

        len = len + (read32 :: usize);
    }

    sys.close_handle(handle);

    if (len == 0) {
        mem.deallocate[u8](buf, cap);
        buf = nil;
        cap = 0;
    }
    or (len < cap) {
        val shrink_res: Option[*u8] = mem.reallocate[u8](buf, cap, len);
        if (shrink_res.is_some()) {
            buf = shrink_res.unwrap();
            cap = len;
        }
    }

    ret ok[[]u8, i32]([]u8{ buf, len });
}

pub fun write_file(path: Path, data: []u8, flags: i32, mode: i32) Result[u64, i32] {
    val w_path: []u16 = str_to_utf16(path.as_str());
    if (w_path.data == nil) {
        ret err[u64, i32](ERR_NO_MEM);
    }

    # flags bit 0o2000 (1024) indicates append mode
    val is_append: u32 = ((flags & 0o2000) != 0) :: u32;
    val handle: *u8 = sys.create_file_write(w_path.data, (is_append == 0) :: u32);
    mem.deallocate[u16](w_path.data, w_path.len);
    if (handle == nil || (handle :: i64) == -1) {
        ret err[u64, i32](ERR_NOT_FOUND);
    }

    var off: usize = 0;
    for (off < data.len) {
        var chunk: usize = data.len - off;
        if (chunk > 0xffff_ffff) {
            chunk = 0xffff_ffff;
        }
        var written: u32 = 0;
        val ok: u32 = sys.write_file(handle, (data.data + off), chunk :: u32, (?written) :: *u32);
        if (ok == 0 || written == 0) {
            sys.close_handle(handle);
            ret err[u64, i32](ERR_IO);
        }
        off = off + (written :: usize);
    }

    sys.close_handle(handle);
    ret ok[u64, i32](data.len :: u64);
}

# stubs for windows - need proper implementation
pub fun check_access(path: Path) bool {
    ret false;
}

pub fun unlink_file(path: Path) Result[u64, i32] {
    ret err[u64, i32](-1);
}

pub fun unlink_dir(path: Path) Result[u64, i32] {
    ret err[u64, i32](-1);
}

pub fun rename_path(oldpath: Path, newpath: Path) Result[u64, i32] {
    ret err[u64, i32](-1);
}

pub fun make_dir(path: Path, mode: i32) Result[u64, i32] {
    ret err[u64, i32](-1);
}

pub fun get_stat(path: Path, follow_links: bool) Result[FileInfo, i32] {
    ret err[FileInfo, i32](-1);
}
