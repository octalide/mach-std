# windows runtime implementation

use      std.types.option;
use      std.types.size;
use      std.types.string;
use slice: std.collections.slice;
use mem:   std.system.memory;

# architecture dispatch
$if ($mach.build.target.arch.id == $mach.arch.x86_64.id) {
    use arch: std.system.arch.x86_64;
}
$if ($mach.build.target.arch.id == $mach.arch.aarch64.id) {
    use arch: std.system.arch.aarch64;
}

# windows api imports (these would be linked via external declarations)
ext "C:ExitProcess" ExitProcess: fun(u32);
ext "C:GetCommandLineW" GetCommandLineW: fun() *u16;
ext "C:GetStdHandle" GetStdHandle: fun(u32) ptr;
ext "C:WriteFile" WriteFile: fun(ptr, *u8, u32, *u32, ptr) i32;

val STD_OUTPUT_HANDLE: u32 = 0xFFFFFFF5;
val STD_ERROR_HANDLE:  u32 = 0xFFFFFFF4;

val WORD_BYTES: usize = arch.WORD_SIZE;

# parse wide string command line
fun parse_cmdline_w(cmdline: *u16) Option[slice.Slice[str]] {
    # simplified implementation - real one needs full parsing
    # this would need to handle quotes, escapes, etc.
    ret none[slice.Slice[str]]();
}

pub fun collect_args() Option[slice.Slice[str]] {
    val cmdline: *u16 = GetCommandLineW();
    ret parse_cmdline_w(cmdline);
}

pub fun exit(code: i64) {
    ExitProcess(code::u32);
}

pub fun write(fd: i32, buf: *u8, count: usize) i64 {
    var handle: ptr = nil;
    if (fd == 1) {
        handle = GetStdHandle(STD_OUTPUT_HANDLE);
    }
    or (fd == 2) {
        handle = GetStdHandle(STD_ERROR_HANDLE);
    }
    or {
        ret -1;
    }

    var written: u32 = 0;
    val result: i32 = WriteFile(handle, buf, count::u32, ?written, nil);
    if (result == 0) {
        ret -1;
    }
    ret written::i64;
}
