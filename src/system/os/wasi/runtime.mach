# wasi runtime implementation

use      std.types.option;
use      std.types.size;
use      std.types.string;
use      std.collections.slice;
use mem: std.system.memory;

# wasi imports
ext "wasi_snapshot_preview1:proc_exit" wasi_proc_exit: fun(i32);
ext "wasi_snapshot_preview1:fd_write" wasi_fd_write: fun(i32, *u8, i32, *i32) i32;
ext "wasi_snapshot_preview1:args_get" wasi_args_get: fun(**u8, *u8) i32;
ext "wasi_snapshot_preview1:args_sizes_get" wasi_args_sizes_get: fun(*i32, *i32) i32;

# iovec structure for wasi fd_write
rec IOVec {
    buf: *u8;
    len: u32;
}

pub fun collect_args() Option[Slice[str]] {
    var argc: i32 = 0;
    var argv_buf_size: i32 = 0;
    
    val result: i32 = wasi_args_sizes_get(?argc, ?argv_buf_size);
    if (result != 0) {
        ret none[Slice[str]]();
    }
    
    if (argc == 0) {
        ret some[Slice[str]](Slice[str]{ nil, 0 });
    }

    # allocate space for argv pointers and string buffer
    val argv_size: usize = argc::usize * $size_of(*u8);
    val argv_opt: Option[*u8] = mem.allocate[u8](argv_size);
    if (argv_opt.is_none()) {
        ret none[Slice[str]]();
    }

    val buf_opt: Option[*u8] = mem.allocate[u8](argv_buf_size::usize);
    if (buf_opt.is_none()) {
        ret none[Slice[str]]();
    }

    val argv: **u8 = argv_opt.unwrap()::**u8;
    val buf: *u8 = buf_opt.unwrap();

    val get_result: i32 = wasi_args_get(argv, buf);
    if (get_result != 0) {
        ret none[Slice[str]]();
    }

    # convert to Slice[str]
    val str_size: usize = argc::usize * $size_of(str);
    val str_storage_opt: Option[*u8] = mem.allocate[u8](str_size);
    if (str_storage_opt.is_none()) {
        ret none[Slice[str]]();
    }

    val str_storage: *u8 = str_storage_opt.unwrap();

    var i: usize = 0;
    for (i < argc::usize) {
        val arg_ptr: *u8 = argv[i];
        
        # find length
        var len: usize = 0;
        var p: *u8 = arg_ptr;
        for (p[0] != 0) {
            len = len + 1;
            p = p + 1;
        }

        # write str to storage
        val str_offset: usize = i * $size_of(str);
        val str_addr: *u8 = str_storage + str_offset;
        
        val data_slot: **u8 = str_addr::**u8;
        data_slot[0] = arg_ptr;
        
        val len_slot: *usize = (str_addr + $size_of(*u8))::*usize;
        len_slot[0] = len;

        i = i + 1;
    }

    ret some[Slice[str]](Slice[str]{ str_storage::*str, argc::usize });
}

pub fun exit(code: i64) {
    wasi_proc_exit(code::i32);
}

pub fun write(fd: i32, buf: *u8, count: usize) i64 {
    var iov: IOVec;
    iov.buf = buf;
    iov.len = count::u32;

    var written: i32 = 0;
    val result: i32 = wasi_fd_write(fd, ?iov::*u8, 1, ?written);
    if (result != 0) {
        ret -1;
    }
    ret written::i64;
}
