# linux runtime implementation

use      std.types.option;
use      std.types.size;
use      std.types.string;
use      std.collections.slice;
use mem: std.system.memory;

# architecture dispatch
$if ($mach.build.target.arch.id == $mach.arch.x86_64.id) {
    use arch: std.system.arch.x86_64;
}
$if ($mach.build.target.arch.id == $mach.arch.aarch64.id) {
    use arch: std.system.arch.aarch64;
}
$if ($mach.build.target.arch.id == $mach.arch.arm.id) {
    use arch: std.system.arch.arm;
}
$if ($mach.build.target.arch.id == $mach.arch.riscv64.id) {
    use arch: std.system.arch.riscv64;
}
$if ($mach.build.target.arch.id == $mach.arch.riscv32.id) {
    use arch: std.system.arch.riscv32;
}

# syscall numbers (x86_64)
$if ($mach.build.target.arch.id == $mach.arch.x86_64.id) {
    val SYS_EXIT: u64 = 60;
    val SYS_WRITE: u64 = 1;
    val SYS_BRK: u64 = 12;
}

# syscall numbers (aarch64)
$if ($mach.build.target.arch.id == $mach.arch.aarch64.id) {
    val SYS_EXIT: u64 = 93;
    val SYS_WRITE: u64 = 64;
    val SYS_BRK: u64 = 214;
}

# syscall numbers (arm)
$if ($mach.build.target.arch.id == $mach.arch.arm.id) {
    val SYS_EXIT: u32 = 1;
    val SYS_WRITE: u32 = 4;
    val SYS_BRK: u32 = 45;
}

# syscall numbers (riscv64)
$if ($mach.build.target.arch.id == $mach.arch.riscv64.id) {
    val SYS_EXIT: u64 = 93;
    val SYS_WRITE: u64 = 64;
    val SYS_BRK: u64 = 214;
}

# syscall numbers (riscv32)
$if ($mach.build.target.arch.id == $mach.arch.riscv32.id) {
    val SYS_EXIT: u32 = 93;
    val SYS_WRITE: u32 = 64;
    val SYS_BRK: u32 = 214;
}

val WORD_BYTES: usize = arch.WORD_SIZE;

fun cstring_length(s: cstr) usize {
    if (s == nil) {
        ret 0;
    }

    var length: usize = 0;
    var cursor: cstr  = s;
    for {
        if (cursor[0] == 0::char) {
            brk;
        }
        length = length + 1;
        cursor = cursor + 1;
    }

    ret length;
}

pub fun build_args(argc: usize, stack: *u8) Option[Slice[str]] {
    if (argc == 0) {
        ret some[Slice[str]](Slice[str]{ nil, 0 });
    }

    val entry_size:  usize = $size_of(str);
    val total_bytes: usize = argc * entry_size;
    if (total_bytes == 0) {
        ret some[Slice[str]](Slice[str]{ nil, 0 });
    }

    val storage_opt: Option[*u8] = mem.allocate[u8](total_bytes);
    if (storage_opt.is_none()) {
        ret none[Slice[str]]();
    }

    val storage: *u8 = storage_opt.unwrap();

    val argv_base: *u8 = stack + WORD_BYTES;

    var index: usize = 0;
    for (index < argc) {
        val offset:  usize = index * WORD_BYTES;
        val addr:    *u8   = argv_base + offset;
        val raw:     usize = (addr::*usize)[0];
        val arg_ptr: cstr  = raw::cstr;
        val length:  usize = cstring_length(arg_ptr);

        val slot_offset: usize = index * entry_size;
        val slot_addr:   *u8   = storage + slot_offset;

        val data_slot: **char = slot_addr::**char;
        data_slot[0] = arg_ptr;

        val length_addr: *u8     = slot_addr + WORD_BYTES;
        val length_slot: *usize = length_addr::*usize;
        length_slot[0] = length;

        index = index + 1;
    }

    ret some[Slice[str]](Slice[str]{ storage::*str, argc });
}

pub fun get_argc(stack: *u8) usize {
    ret (stack::*usize)[0];
}

pub fun exit(code: i64) {
    $if ($mach.build.target.arch.id == $mach.arch.x86_64.id || $mach.build.target.arch.id == $mach.arch.aarch64.id || $mach.build.target.arch.id == $mach.arch.riscv64.id) {
        arch.syscall1(SYS_EXIT, code::u64);
    }
    $if ($mach.build.target.arch.id == $mach.arch.arm.id || $mach.build.target.arch.id == $mach.arch.riscv32.id) {
        arch.syscall1(SYS_EXIT, code::u32);
    }
    arch.halt();
}

pub fun write(fd: i32, buf: *u8, count: usize) i64 {
    $if ($mach.build.target.arch.id == $mach.arch.x86_64.id || $mach.build.target.arch.id == $mach.arch.aarch64.id || $mach.build.target.arch.id == $mach.arch.riscv64.id) {
        val result: u64 = arch.syscall3(SYS_WRITE, fd::u64, buf::ptr::u64, count::u64);
        ret result::i64;
    }
    $if ($mach.build.target.arch.id == $mach.arch.arm.id || $mach.build.target.arch.id == $mach.arch.riscv32.id) {
        val result: u32 = arch.syscall3(SYS_WRITE, fd::u32, buf::ptr::u32, count::u32);
        ret result::i64;
    }
    ret -1;
}

pub fun brk(addr: *u8) *u8 {
    $if ($mach.build.target.arch.id == $mach.arch.x86_64.id || $mach.build.target.arch.id == $mach.arch.aarch64.id || $mach.build.target.arch.id == $mach.arch.riscv64.id) {
        val result: u64 = arch.syscall1(SYS_BRK, addr::ptr::u64);
        ret result::ptr::*u8;
    }
    $if ($mach.build.target.arch.id == $mach.arch.arm.id || $mach.build.target.arch.id == $mach.arch.riscv32.id) {
        val result: u32 = arch.syscall1(SYS_BRK, addr::ptr::u32);
        ret result::ptr::*u8;
    }
    ret nil;
}
