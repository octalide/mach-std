use target;
use std.mem;
use std.os.linux.sys;
use std.types.string;

fun path_to_cstr(path: string) []u8 {
    val size: u64 = path.length + 1;
    val buf: *u8 = allocate(size);
    if (buf == nil) {
        ret []u8{ nil, 0 };
    }

    if (path.length > 0) {
        mem_copy(buf, path.data, path.length);
    }
    @(buf + path.length) = 0;

    ret []u8{ buf, size };
}

# basic posix flags subset for open(2)
pub val O_RDONLY: i32 = 0;
pub val O_WRONLY: i32 = 1;
pub val O_RDWR:   i32 = 2;
pub val O_CREAT:  i32 = 64;   # 0o100
pub val O_TRUNC:  i32 = 512;  # 0o1000

# unix style permissions subset
pub val MODE_644: i32 = 420;  # 0644
pub val MODE_600: i32 = 384;  # 0600

pub fun fs_read_all(path: string) []u8 {
    if (OS != OS_LINUX) {
        ret []u8{ nil, 0 };
    }

    val c_path: []u8 = path_to_cstr(path);
    if (c_path.data == nil) {
        ret []u8{ nil, 0 };
    }

    val fd_res: i64 = sys_openat(AT_FDCWD, c_path.data, O_RDONLY, 0);
    deallocate(c_path.data, c_path.length);

    if (fd_res < 0) {
        ret []u8{ nil, 0 };
    }

    val fd: i32 = fd_res :: i32;

    # grow buffer progressively
    var cap: u64 = 4096;
    var buf: *u8 = allocate(cap);
    if (buf == nil) {
        sys_close(fd);
        ret []u8{nil, 0};
    }

    var len: u64 = 0;
    for {
        val space: u64 = cap - len;
        if (space == 0) {
            val ncap: u64 = cap + (cap >> 1) + 1;
            val nbuf: *u8 = reallocate(buf, cap, ncap);

            if (nbuf == nil) {
                deallocate(buf, cap);
                sys_close(fd);
                ret []u8{ nil, 0 };
            }

            buf = nbuf;
            cap = ncap;
        }

        val got: i64 = sys_read(fd, (buf + len), (cap - len));
        
        if (got < 0) {
            deallocate(buf, cap);
            sys_close(fd);

            ret []u8{ nil, 0 };
        }
        or (got == 0) {
            brk;
        }

        len = len + (got::u64);
    }
    sys_close(fd);

    # shrink to fit
    if (len < cap) {
        val nbuf: *u8 = reallocate(buf, cap, len);
        if (nbuf != nil) {
            buf = nbuf;
            cap = len;
        }
    }

    ret []u8{ buf, len };
}

pub fun fs_write_all(path: string, data: []u8) i32 {
    if (OS != OS_LINUX) {
        ret -1;
    }

    val c_path: []u8 = path_to_cstr(path);
    if (c_path.data == nil) {
        ret -1;
    }

    val fd_res: i64 = sys_openat(AT_FDCWD, c_path.data, O_WRONLY | O_CREAT | O_TRUNC, MODE_644);
    deallocate(c_path.data, c_path.length);

    if (fd_res < 0) {
        ret -1;
    }

    val fd: i32 = fd_res :: i32;
    
    var off: u64 = 0;
    var res: i64 = 0;
    for (off < data.length) {
        res = sys_write(fd, (data.data + off), (data.length - off));
        if (res <= 0) {
            sys_close(fd);
            ret -1;
        }

        off = off + (res::u64);
    }

    sys_close(fd);

    ret 0;
}
