use std.system.memory;
use std.types.string;

#! if (OS == OS_LINUX)
use std.system.platform.linux.sys;
#! or (OS == OS_DARWIN)
use std.system.platform.darwin.sys;
#! or (OS == OS_WINDOWS)
use std.system.platform.windows.sys;
#! end

#! if ((OS == OS_LINUX) || (OS == OS_DARWIN))
fun path_to_cstr(path: string) []u8 {
    val size: u64 = path.length + 1;
    val buf: *u8 = allocate(size);
    if (buf == nil) {
        ret []u8{ nil, 0 };
    }

    if (path.length > 0) {
        memory_copy(buf, path.data, path.length);
    }
    @(buf + path.length) = 0;

    ret []u8{ buf, size };
}

#! end

#! if (OS == OS_WINDOWS)
fun path_to_utf16(path: string) []u16 {
    val units: u64 = path.length + 1;
    val bytes: u64 = units * 2;
    val buf_raw: *u8 = allocate(bytes);
    if (buf_raw == nil) {
        ret []u16{ nil, 0 };
    }

    val buf16: *u16 = buf_raw :: *u16;
    var i: u64 = 0;
    for (i < path.length) {
        val ch: u8 = @(path.data + i);
        if (ch >= 128) {
            deallocate(buf_raw, bytes);
            ret []u16{ nil, 0 };
        }
        @(buf16 + i) = ch :: u16;
        i = i + 1;
    }

    @(buf16 + path.length) = 0;

    ret []u16{ buf16, units };
}
#! end

# basic posix flags subset for open(2)
pub val O_RDONLY: i32 = 0;
pub val O_WRONLY: i32 = 1;
pub val O_RDWR:   i32 = 2;
pub val O_CREAT:  i32 = 64;   # 0o100
pub val O_TRUNC:  i32 = 512;  # 0o1000

# unix style permissions subset
pub val MODE_644: i32 = 420;  # 0644
pub val MODE_600: i32 = 384;  # 0600

#! if (OS == OS_LINUX)

pub fun fs_read_all(path: string) []u8 {
    val c_path: []u8 = path_to_cstr(path);
    if (c_path.data == nil) {
        ret []u8{ nil, 0 };
    }

    val fd_res: i64 = linux_openat(LINUX_AT_FDCWD, c_path.data, O_RDONLY, 0);
    deallocate(c_path.data, c_path.length);
    if (fd_res < 0) {
        ret []u8{ nil, 0 };
    }

    val fd: i32 = fd_res :: i32;
    var cap: u64 = 4096;
    var buf: *u8 = allocate(cap);
    if (buf == nil) {
        linux_close(fd);
        ret []u8{ nil, 0 };
    }

    var len: u64 = 0;
    for {
        if (cap == len) {
            val ncap: u64 = cap + (cap >> 1) + 1;
            val nbuf: *u8 = reallocate(buf, cap, ncap);
            if (nbuf == nil) {
                deallocate(buf, cap);
                linux_close(fd);
                ret []u8{ nil, 0 };
            }
            buf = nbuf;
            cap = ncap;
        }

        val space: u64 = cap - len;
        val got: i64 = linux_read(fd, (buf + len), space);
        if (got < 0) {
            deallocate(buf, cap);
            linux_close(fd);
            ret []u8{ nil, 0 };
        }
        or (got == 0) {
            brk;
        }

        len = len + (got :: u64);
    }

    linux_close(fd);

    if (len < cap) {
        val nbuf: *u8 = reallocate(buf, cap, len);
        if (nbuf != nil) {
            buf = nbuf;
        }
    }

    ret []u8{ buf, len };
}

pub fun fs_write_all(path: string, data: []u8) i32 {
    val c_path: []u8 = path_to_cstr(path);
    if (c_path.data == nil) {
        ret -1;
    }

    val fd_res: i64 = linux_openat(LINUX_AT_FDCWD, c_path.data, O_WRONLY | O_CREAT | O_TRUNC, MODE_644);
    deallocate(c_path.data, c_path.length);
    if (fd_res < 0) {
        ret -1;
    }

    val fd: i32 = fd_res :: i32;
    var off: u64 = 0;
    for (off < data.length) {
        val wrote: i64 = linux_write(fd, (data.data + off), (data.length - off));
        if (wrote <= 0) {
            linux_close(fd);
            ret -1;
        }
        off = off + (wrote :: u64);
    }

    linux_close(fd);
    ret 0;
}

#! or (OS == OS_DARWIN)

pub fun fs_read_all(path: string) []u8 {
    val c_path: []u8 = path_to_cstr(path);
    if (c_path.data == nil) {
        ret []u8{ nil, 0 };
    }

    val fd_res: i64 = darwin_openat(DARWIN_AT_FDCWD, c_path.data, O_RDONLY, 0);
    deallocate(c_path.data, c_path.length);
    if (fd_res < 0) {
        ret []u8{ nil, 0 };
    }

    val fd: i32 = fd_res :: i32;
    var cap: u64 = 4096;
    var buf: *u8 = allocate(cap);
    if (buf == nil) {
        darwin_close(fd);
        ret []u8{ nil, 0 };
    }

    var len: u64 = 0;
    for {
        if (cap == len) {
            val ncap: u64 = cap + (cap >> 1) + 1;
            val nbuf: *u8 = reallocate(buf, cap, ncap);
            if (nbuf == nil) {
                deallocate(buf, cap);
                darwin_close(fd);
                ret []u8{ nil, 0 };
            }
            buf = nbuf;
            cap = ncap;
        }

        val space: u64 = cap - len;
        val got: i64 = darwin_read(fd, (buf + len), space);
        if (got < 0) {
            deallocate(buf, cap);
            darwin_close(fd);
            ret []u8{ nil, 0 };
        }
        or (got == 0) {
            brk;
        }

        len = len + (got :: u64);
    }

    darwin_close(fd);

    if (len < cap) {
        val nbuf: *u8 = reallocate(buf, cap, len);
        if (nbuf != nil) {
            buf = nbuf;
        }
    }

    ret []u8{ buf, len };
}

pub fun fs_write_all(path: string, data: []u8) i32 {
    val c_path: []u8 = path_to_cstr(path);
    if (c_path.data == nil) {
        ret -1;
    }

    val fd_res: i64 = darwin_openat(DARWIN_AT_FDCWD, c_path.data, O_WRONLY | O_CREAT | O_TRUNC, MODE_644);
    deallocate(c_path.data, c_path.length);
    if (fd_res < 0) {
        ret -1;
    }

    val fd: i32 = fd_res :: i32;
    var off: u64 = 0;
    for (off < data.length) {
        val wrote: i64 = darwin_write(fd, (data.data + off), (data.length - off));
        if (wrote <= 0) {
            darwin_close(fd);
            ret -1;
        }
        off = off + (wrote :: u64);
    }

    darwin_close(fd);
    ret 0;
}

#! or (OS == OS_WINDOWS)

pub fun fs_read_all(path: string) []u8 {
    val w_path: []u16 = path_to_utf16(path);
    if (w_path.data == nil) {
        ret []u8{ nil, 0 };
    }

    val handle: *u8 = win_create_file_read(w_path.data);
    deallocate((w_path.data :: *u8), w_path.length * 2);
    if (handle == nil || (handle :: i64) == -1) {
        ret []u8{ nil, 0 };
    }

    var cap: u64 = 4096;
    var buf: *u8 = allocate(cap);
    if (buf == nil) {
        win_close_handle(handle);
        ret []u8{ nil, 0 };
    }

    var len: u64 = 0;
    for {
        if (cap == len) {
            val ncap: u64 = cap + (cap >> 1) + 1;
            val nbuf: *u8 = reallocate(buf, cap, ncap);
            if (nbuf == nil) {
                deallocate(buf, cap);
                win_close_handle(handle);
                ret []u8{ nil, 0 };
            }
            buf = nbuf;
            cap = ncap;
        }

        var chunk: u64 = cap - len;
        if (chunk > 0xffff_ffff) {
            chunk = 0xffff_ffff;
        }
        var read32: u32 = 0;
        val ok: u32 = win_read_file(handle, (buf + len), chunk :: u32, (?read32) :: *u32);
        if (ok == 0) {
            deallocate(buf, cap);
            win_close_handle(handle);
            ret []u8{ nil, 0 };
        }
        or (read32 == 0) {
            brk;
        }

        len = len + (read32 :: u64);
    }

    win_close_handle(handle);

    if (len < cap) {
        val nbuf: *u8 = reallocate(buf, cap, len);
        if (nbuf != nil) {
            buf = nbuf;
        }
    }

    ret []u8{ buf, len };
}

pub fun fs_write_all(path: string, data: []u8) i32 {
    val w_path: []u16 = path_to_utf16(path);
    if (w_path.data == nil) {
        ret -1;
    }

    val handle: *u8 = win_create_file_write(w_path.data, 1);
    deallocate((w_path.data :: *u8), w_path.length * 2);
    if (handle == nil || (handle :: i64) == -1) {
        ret -1;
    }

    var off: u64 = 0;
    for (off < data.length) {
        var chunk: u64 = data.length - off;
        if (chunk > 0xffff_ffff) {
            chunk = 0xffff_ffff;
        }
        var written: u32 = 0;
        val ok: u32 = win_write_file(handle, (data.data + off), chunk :: u32, (?written) :: *u32);
        if (ok == 0 || written == 0) {
            win_close_handle(handle);
            ret -1;
        }
        off = off + (written :: u64);
    }

    win_close_handle(handle);
    ret 0;
}

#! end
