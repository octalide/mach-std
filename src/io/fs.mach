use mem: std.system.memory;
use std.types.string;

#@if (OS == OS_LINUX)
use sys: std.system.platform.linux.sys;
#@or (OS == OS_DARWIN)
use sys: std.system.platform.darwin.sys;
#@or (OS == OS_WINDOWS)
use sys: std.system.platform.windows.sys;
#@end

#@if ((OS == OS_LINUX) || (OS == OS_DARWIN))
fun path_to_cstr(path: string) []u8 {
    val size: u64 = path.len + 1;
    val buf: *u8 = mem.allocate(size);
    if (buf == nil) {
        ret []u8{ nil, 0 };
    }

    if (path.len > 0) {
        mem.raw_copy(buf, path.data, path.len);
    }
    @(buf + path.len) = 0;

    ret []u8{ buf, size };
}

#@end

#@if (OS == OS_WINDOWS)
fun path_to_utf16(path: string) []u16 {
    val units: u64 = path.len + 1;
    val bytes: u64 = units * 2;
    val buf_raw: *u8 = mem.allocate(bytes);
    if (buf_raw == nil) {
        ret []u16{ nil, 0 };
    }

    val buf16: *u16 = buf_raw :: *u16;
    var i: u64 = 0;
    for (i < path.len) {
        val ch: u8 = @(path.data + i);
        if (ch >= 128) {
            mem.deallocate(buf_raw, bytes);
            ret []u16{ nil, 0 };
        }
        @(buf16 + i) = ch :: u16;
        i = i + 1;
    }

    @(buf16 + path.len) = 0;

    ret []u16{ buf16, units };
}
#@end

pub val AT_FDCWD: i32 = -100;

# basic posix flags subset for open(2)
pub val O_RDONLY: i32 = 0;
pub val O_WRONLY: i32 = 1;
pub val O_RDWR:   i32 = 2;
pub val O_CREAT:  i32 = 64;   # 0o100
pub val O_TRUNC:  i32 = 512;  # 0o1000

# unix style permissions subset
pub val MODE_644: i32 = 420;  # 0644
pub val MODE_600: i32 = 384;  # 0600

#@if (OS == OS_LINUX)

pub fun fs_read_all(path: string) []u8 {
    val c_path: []u8 = path_to_cstr(path);
    if (c_path.data == nil) {
        ret []u8{ nil, 0 };
    }

    val fd_res: i64 = sys.openat(AT_FDCWD, c_path.data, O_RDONLY, 0);
    mem.deallocate(c_path.data, c_path.len);
    if (fd_res < 0) {
        ret []u8{ nil, 0 };
    }

    val fd: i32 = fd_res :: i32;
    var cap: u64 = 4096;
    var buf: *u8 = mem.allocate(cap);
    if (buf == nil) {
        sys.close(fd);
        ret []u8{ nil, 0 };
    }

    var len: u64 = 0;
    for {
        if (cap == len) {
            val ncap: u64 = cap + (cap >> 1) + 1;
            val nbuf: *u8 = mem.reallocate(buf, cap, ncap);
            if (nbuf == nil) {
                mem.deallocate(buf, cap);
                sys.close(fd);
                ret []u8{ nil, 0 };
            }
            buf = nbuf;
            cap = ncap;
        }

        val space: u64 = cap - len;
        val got: i64 = sys.read(fd, (buf + len), space);
        if (got < 0) {
            mem.deallocate(buf, cap);
            sys.close(fd);
            ret []u8{ nil, 0 };
        }
        or (got == 0) {
            brk;
        }

        len = len + (got :: u64);
    }

    sys.close(fd);

    if (len < cap) {
        val nbuf: *u8 = mem.reallocate(buf, cap, len);
        if (nbuf != nil) {
            buf = nbuf;
        }
    }

    ret []u8{ buf, len };
}

pub fun fs_write_all(path: string, data: []u8) i32 {
    val c_path: []u8 = path_to_cstr(path);
    if (c_path.data == nil) {
        ret -1;
    }

    val fd_res: i64 = sys.openat(AT_FDCWD, c_path.data, O_WRONLY | O_CREAT | O_TRUNC, MODE_644);
    mem.deallocate(c_path.data, c_path.len);
    if (fd_res < 0) {
        ret -1;
    }

    val fd: i32 = fd_res :: i32;
    var off: u64 = 0;
    for (off < data.len) {
        val wrote: i64 = sys.write(fd, (data.data + off), (data.len - off));
        if (wrote <= 0) {
            sys.close(fd);
            ret -1;
        }
        off = off + (wrote :: u64);
    }

    sys.close(fd);
    ret 0;
}

#@or (OS == OS_DARWIN)

pub fun fs_read_all(path: string) []u8 {
    val c_path: []u8 = path_to_cstr(path);
    if (c_path.data == nil) {
        ret []u8{ nil, 0 };
    }

    val fd_res: i64 = sys.openat(AT_FDCWD, c_path.data, O_RDONLY, 0);
    mem.deallocate(c_path.data, c_path.len);
    if (fd_res < 0) {
        ret []u8{ nil, 0 };
    }

    val fd: i32 = fd_res :: i32;
    var cap: u64 = 4096;
    var buf: *u8 = mem.allocate(cap);
    if (buf == nil) {
        sys.close(fd);
        ret []u8{ nil, 0 };
    }

    var len: u64 = 0;
    for {
        if (cap == len) {
            val ncap: u64 = cap + (cap >> 1) + 1;
            val nbuf: *u8 = mem.reallocate(buf, cap, ncap);
            if (nbuf == nil) {
                mem.deallocate(buf, cap);
                sys.close(fd);
                ret []u8{ nil, 0 };
            }
            buf = nbuf;
            cap = ncap;
        }

        val space: u64 = cap - len;
        val got: i64 = sys.read(fd, (buf + len), space);
        if (got < 0) {
            mem.deallocate(buf, cap);
            sys.close(fd);
            ret []u8{ nil, 0 };
        }
        or (got == 0) {
            brk;
        }

        len = len + (got :: u64);
    }

    sys.close(fd);

    if (len < cap) {
        val nbuf: *u8 = mem.reallocate(buf, cap, len);
        if (nbuf != nil) {
            buf = nbuf;
        }
    }

    ret []u8{ buf, len };
}

pub fun fs_write_all(path: string, data: []u8) i32 {
    val c_path: []u8 = path_to_cstr(path);
    if (c_path.data == nil) {
        ret -1;
    }

    val fd_res: i64 = sys.openat(AT_FDCWD, c_path.data, O_WRONLY | O_CREAT | O_TRUNC, MODE_644);
    mem.deallocate(c_path.data, c_path.len);
    if (fd_res < 0) {
        ret -1;
    }

    val fd: i32 = fd_res :: i32;
    var off: u64 = 0;
    for (off < data.len) {
        val wrote: i64 = sys.write(fd, (data.data + off), (data.len - off));
        if (wrote <= 0) {
            sys.close(fd);
            ret -1;
        }
        off = off + (wrote :: u64);
    }

    sys.close(fd);
    ret 0;
}

#@or (OS == OS_WINDOWS)

pub fun fs_read_all(path: string) []u8 {
    val w_path: []u16 = path_to_utf16(path);
    if (w_path.data == nil) {
        ret []u8{ nil, 0 };
    }

    val handle: *u8 = sys.create_file_read(w_path.data);
    mem.deallocate((w_path.data :: *u8), w_path.len * 2);
    if (handle == nil || (handle :: i64) == -1) {
        ret []u8{ nil, 0 };
    }

    var cap: u64 = 4096;
    var buf: *u8 = mem.allocate(cap);
    if (buf == nil) {
        sys.close_handle(handle);
        ret []u8{ nil, 0 };
    }

    var len: u64 = 0;
    for {
        if (cap == len) {
            val ncap: u64 = cap + (cap >> 1) + 1;
            val nbuf: *u8 = mem.reallocate(buf, cap, ncap);
            if (nbuf == nil) {
                mem.deallocate(buf, cap);
                sys.close_handle(handle);
                ret []u8{ nil, 0 };
            }
            buf = nbuf;
            cap = ncap;
        }

        var chunk: u64 = cap - len;
        if (chunk > 0xffff_ffff) {
            chunk = 0xffff_ffff;
        }
        var read32: u32 = 0;
        val ok: u32 = sys.read_file(handle, (buf + len), chunk :: u32, (?read32) :: *u32);
        if (ok == 0) {
            mem.deallocate(buf, cap);
            sys.close_handle(handle);
            ret []u8{ nil, 0 };
        }
        or (read32 == 0) {
            brk;
        }

        len = len + (read32 :: u64);
    }

    sys.close_handle(handle);

    if (len < cap) {
        val nbuf: *u8 = mem.reallocate(buf, cap, len);
        if (nbuf != nil) {
            buf = nbuf;
        }
    }

    ret []u8{ buf, len };
}

pub fun fs_write_all(path: string, data: []u8) i32 {
    val w_path: []u16 = path_to_utf16(path);
    if (w_path.data == nil) {
        ret -1;
    }

    val handle: *u8 = sys.create_file_write(w_path.data, 1);
    mem.deallocate((w_path.data :: *u8), w_path.len * 2);
    if (handle == nil || (handle :: i64) == -1) {
        ret -1;
    }

    var off: u64 = 0;
    for (off < data.len) {
        var chunk: u64 = data.len - off;
        if (chunk > 0xffff_ffff) {
            chunk = 0xffff_ffff;
        }
        var written: u32 = 0;
        val ok: u32 = sys.write_file(handle, (data.data + off), chunk :: u32, (?written) :: *u32);
        if (ok == 0 || written == 0) {
            sys.close_handle(handle);
            ret -1;
        }
        off = off + (written :: u64);
    }

    sys.close_handle(handle);
    ret 0;
}

#@end
