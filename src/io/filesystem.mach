use std.types.string;
use std.types.result;
use std.types.bool;
use std.io.path;

$if (target.os == OS_LINUX) {
    use platform: std.system.platform.linux.filesystem;
}

$if (target.os == OS_DARWIN) {
    use platform: std.system.platform.darwin.filesystem;
}

$if (target.os == OS_WINDOWS) {
    use platform: std.system.platform.windows.filesystem;
}

pub rec FileInfo {
    size:        u64;
    mode:        u32;
    is_dir:      bool;
    is_file:     bool;
    is_symlink:  bool;
    atime_sec:   i64;
    mtime_sec:   i64;
    ctime_sec:   i64;
}

fun fileinfo_from_platform(info: platform.FileInfo) FileInfo {
    var fi: FileInfo;
    fi.size       = info.size;
    fi.mode       = info.mode;
    fi.is_dir     = info.is_dir;
    fi.is_file    = info.is_file;
    fi.is_symlink = info.is_symlink;
    fi.atime_sec  = info.atime_sec;
    fi.mtime_sec  = info.mtime_sec;
    fi.ctime_sec  = info.ctime_sec;
    ret fi;
}

# error codes
val ERR_NONE:          i32 = 0;
val ERR_NOT_FOUND:     i32 = -2;   # ENOENT
val ERR_PERMISSION:    i32 = -13;  # EACCES
val ERR_EXISTS:        i32 = -17;  # EEXIST
val ERR_NOT_DIR:       i32 = -20;  # ENOTDIR
val ERR_IS_DIR:        i32 = -21;  # EISDIR
val ERR_INVALID:       i32 = -22;  # EINVAL
val ERR_NO_SPACE:      i32 = -28;  # ENOSPC
val ERR_READ_ONLY:     i32 = -30;  # EROFS
val ERR_NAME_TOO_LONG: i32 = -36;  # ENAMETOOLONG
val ERR_NOT_EMPTY:     i32 = -39;  # ENOTEMPTY
val ERR_IO:            i32 = -5;   # EIO
val ERR_NO_MEM:        i32 = -12;  # ENOMEM
val ERR_UNKNOWN:       i32 = -1;

# file open flags
pub val O_RDONLY:  i32 = 0x0000;
pub val O_WRONLY:  i32 = 0x0001;
pub val O_RDWR:    i32 = 0x0002;
pub val O_CREAT:   i32 = 0o100;
pub val O_EXCL:    i32 = 0o200;
pub val O_TRUNC:   i32 = 0o1000;
pub val O_APPEND:  i32 = 0o2000;

# unix style permissions
pub val MODE_644: i32 = 0o644;  # rw-r--r--
pub val MODE_600: i32 = 0o600;  # rw-------
pub val MODE_755: i32 = 0o755;  # rwxr-xr-x
pub val MODE_700: i32 = 0o700;  # rwx------

# convert error code to human-readable message
fun error_string(code: i32) str {
    if (code == ERR_NONE)          { ret "no error"; }
    if (code == ERR_NOT_FOUND)     { ret "file not found"; }
    if (code == ERR_PERMISSION)    { ret "permission denied"; }
    if (code == ERR_EXISTS)        { ret "file already exists"; }
    if (code == ERR_NOT_DIR)       { ret "not a directory"; }
    if (code == ERR_IS_DIR)        { ret "is a directory"; }
    if (code == ERR_INVALID)       { ret "invalid argument"; }
    if (code == ERR_NO_SPACE)      { ret "no space left on device"; }
    if (code == ERR_READ_ONLY)     { ret "read-only file system"; }
    if (code == ERR_NAME_TOO_LONG) { ret "file name too long"; }
    if (code == ERR_NOT_EMPTY)     { ret "directory not empty"; }
    if (code == ERR_IO)            { ret "input/output error"; }
    if (code == ERR_NO_MEM)        { ret "out of memory"; }
    ret "unknown error";
}

# read entire file into memory
pub fun read_all(path: Path) Result[[]u8, str] {
    val res: Result[[]u8, i32] = platform.read_file(path);
    if (res.is_err()) {
        ret err[[]u8, str](error_string(res.unwrap_err()));
    }
    ret ok[[]u8, str](res.unwrap_ok());
}

# write data to file, truncating if exists
pub fun write_all(path: Path, data: []u8) Result[u64, str] {
    val res: Result[u64, i32] = platform.write_file(path, data, O_WRONLY | O_CREAT | O_TRUNC, MODE_644);
    if (res.is_err()) {
        ret err[u64, str](error_string(res.unwrap_err()));
    }
    ret ok[u64, str](res.unwrap_ok());
}

# append data to file
pub fun append_all(path: Path, data: []u8) Result[u64, str] {
    val res: Result[u64, i32] = platform.write_file(path, data, O_WRONLY | O_CREAT | O_APPEND, MODE_644);
    if (res.is_err()) {
        ret err[u64, str](error_string(res.unwrap_err()));
    }
    ret ok[u64, str](res.unwrap_ok());
}

# check if file or directory exists
pub fun exists(path: Path) bool {
    ret platform.check_access(path);
}

# remove a file
pub fun remove(path: Path) Result[u64, str] {
    val res: Result[u64, i32] = platform.unlink_file(path);
    if (res.is_err()) {
        ret err[u64, str](error_string(res.unwrap_err()));
    }
    ret ok[u64, str](res.unwrap_ok());
}

# remove an empty directory
pub fun remove_dir(path: Path) Result[u64, str] {
    val res: Result[u64, i32] = platform.unlink_dir(path);
    if (res.is_err()) {
        ret err[u64, str](error_string(res.unwrap_err()));
    }
    ret ok[u64, str](res.unwrap_ok());
}

# rename or move a file/directory
pub fun rename(oldpath: Path, newpath: Path) Result[u64, str] {
    val res: Result[u64, i32] = platform.rename_path(oldpath, newpath);
    if (res.is_err()) {
        ret err[u64, str](error_string(res.unwrap_err()));
    }
    ret ok[u64, str](res.unwrap_ok());
}

# create a new directory
pub fun create_dir(path: Path, mode: i32) Result[u64, str] {
    val res: Result[u64, i32] = platform.make_dir(path, mode);
    if (res.is_err()) {
        ret err[u64, str](error_string(res.unwrap_err()));
    }
    ret ok[u64, str](res.unwrap_ok());
}

# get file metadata, following symbolic links
pub fun stat(path: Path) Result[FileInfo, str] {
    val res: Result[platform.FileInfo, i32] = platform.get_stat(path, true);
    if (res.is_err()) {
        ret err[FileInfo, str](error_string(res.unwrap_err()));
    }
    ret ok[FileInfo, str](fileinfo_from_platform(res.unwrap_ok()));
}

# get file metadata, not following symbolic links
pub fun lstat(path: Path) Result[FileInfo, str] {
    val res: Result[platform.FileInfo, i32] = platform.get_stat(path, false);
    if (res.is_err()) {
        ret err[FileInfo, str](error_string(res.unwrap_err()));
    }
    ret ok[FileInfo, str](fileinfo_from_platform(res.unwrap_ok()));
}

# check if path is a directory
pub fun is_dir(path: Path) bool {
    val res: Result[FileInfo, str] = stat(path);
    if (res.is_err()) {
        ret false;
    }
    ret res.unwrap_ok().is_dir;
}

# check if path is a regular file
pub fun is_file(path: Path) bool {
    val res: Result[FileInfo, str] = stat(path);
    if (res.is_err()) {
        ret false;
    }
    ret res.unwrap_ok().is_file;
}

# get file size in bytes
pub fun file_size(path: Path) Result[u64, str] {
    val res: Result[FileInfo, str] = stat(path);
    if (res.is_err()) {
        ret err[u64, str](res.unwrap_err());
    }
    ret ok[u64, str](res.unwrap_ok().size);
}
